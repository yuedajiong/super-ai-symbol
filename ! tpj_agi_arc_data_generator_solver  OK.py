F = False
T = True

ZERO = 0
ONE = 1
TWO = 2
THREE = 3
FOUR = 4
FIVE = 5
SIX = 6
SEVEN = 7
EIGHT = 8
NINE = 9
TEN = 10

NEG_ONE = -1
NEG_TWO = -2

DOWN = (1, 0)
RIGHT = (0, 1)
UP = (-1, 0)
LEFT = (0, -1)

ORIGIN = (0, 0)
UNITY = (1, 1)
NEG_UNITY = (-1, -1)
UP_RIGHT = (-1, 1)
DOWN_LEFT = (1, -1)

ZERO_BY_TWO = (0, 2)
TWO_BY_ZERO = (2, 0)
TWO_BY_TWO = (2, 2)
THREE_BY_THREE = (3, 3)

import typing
Iterable = typing.Iterable
List = typing.List
Union = typing.Union
Tuple = typing.Tuple
Any = typing.Any
Container = typing.Container
FrozenSet = typing.FrozenSet
Callable = typing.Callable 

Boolean = bool
Integer = int
IntegerTuple = Tuple[Integer, Integer]
Numerical = Union[Integer, IntegerTuple]
IntegerSet = FrozenSet[Integer]
Grid = Tuple[Tuple[Integer]]
Cell = Tuple[Integer, IntegerTuple]
Object = FrozenSet[Cell]
Objects = FrozenSet[Object]
Indices = FrozenSet[IntegerTuple]
IndicesSet = FrozenSet[Indices]
Patch = Union[Object, Indices]
Element = Union[Object, Grid]
Piece = Union[Grid, Patch]
TupleTuple = Tuple[Tuple]
ContainerContainer = Container[Container]

class Worker:  #求解动作  #lambda: lbind rbind compose chain matcher fork
    def identity(
        x: Any
    ) -> Any:
        """ identity function """
        return x

    def add(
        a: Numerical,
        b: Numerical
    ) -> Numerical:
        """ addition """
        if isinstance(a, int) and isinstance(b, int):
            return a + b
        elif isinstance(a, tuple) and isinstance(b, tuple):
            return (a[0] + b[0], a[1] + b[1])
        elif isinstance(a, int) and isinstance(b, tuple):
            return (a + b[0], a + b[1])
        return (a[0] + b, a[1] + b)

    def subtract(
        a: Numerical,
        b: Numerical
    ) -> Numerical:
        """ subtraction """
        if isinstance(a, int) and isinstance(b, int):
            return a - b
        elif isinstance(a, tuple) and isinstance(b, tuple):
            return (a[0] - b[0], a[1] - b[1])
        elif isinstance(a, int) and isinstance(b, tuple):
            return (a - b[0], a - b[1])
        return (a[0] - b, a[1] - b)

    def multiply(
        a: Numerical,
        b: Numerical
    ) -> Numerical:
        """ multiplication """
        if isinstance(a, int) and isinstance(b, int):
            return a * b
        elif isinstance(a, tuple) and isinstance(b, tuple):
            return (a[0] * b[0], a[1] * b[1])
        elif isinstance(a, int) and isinstance(b, tuple):
            return (a * b[0], a * b[1])
        return (a[0] * b, a[1] * b)
        

    def divide(
        a: Numerical,
        b: Numerical
    ) -> Numerical:
        """ floor division """
        if isinstance(a, int) and isinstance(b, int):
            return a // b
        elif isinstance(a, tuple) and isinstance(b, tuple):
            return (a[0] // b[0], a[1] // b[1])
        elif isinstance(a, int) and isinstance(b, tuple):
            return (a // b[0], a // b[1])
        return (a[0] // b, a[1] // b)

    def invert(
        n: Numerical
    ) -> Numerical:
        """ inversion with respect to addition """
        return -n if isinstance(n, int) else (-n[0], -n[1])

    def even(
        n: Integer
    ) -> Boolean:
        """ evenness """
        return n % 2 == 0

    def double(
        n: Numerical
    ) -> Numerical:
        """ scaling by two """
        return n * 2 if isinstance(n, int) else (n[0] * 2, n[1] * 2)

    def halve(
        n: Numerical
    ) -> Numerical:
        """ scaling by one half """
        return n // 2 if isinstance(n, int) else (n[0] // 2, n[1] // 2)

    def flip(
        b: Boolean
    ) -> Boolean:
        """ logical not """
        return not b

    def equality(
        a: Any,
        b: Any
    ) -> Boolean:
        """ equality """
        return a == b

    def contained(
        value: Any,
        container: Container
    ) -> Boolean:
        """ element of """
        return value in container

    def combine(
        a: Container,
        b: Container
    ) -> Container:
        """ union """
        return type(a)((*a, *b))

    def intersection(
        a: FrozenSet,
        b: FrozenSet
    ) -> FrozenSet:
        """ returns the intersection of two containers """
        return a & b

    def difference(
        a: FrozenSet,
        b: FrozenSet
    ) -> FrozenSet:
        """ set difference """
        return type(a)(e for e in a if e not in b)

    def dedupe(
        tup: Tuple
    ) -> Tuple:
        """ remove duplicates """
        return tuple(e for i, e in enumerate(tup) if tup.index(e) == i)

    def order(
        container: Container,
        compfunc: Callable
    ) -> Tuple:
        """ order container by custom key """
        return tuple(sorted(container, key=compfunc))

    def repeat(
        item: Any,
        num: Integer
    ) -> Tuple:
        """ repetition of item within vector """
        return tuple(item for i in range(num))

    def greater(
        a: Integer,
        b: Integer
    ) -> Boolean:
        """ greater """
        return a > b

    def size(
        container: Container
    ) -> Integer:
        """ cardinality """
        return len(container)

    def merge(
        containers: ContainerContainer
    ) -> Container:
        """ merging """
        return type(containers)(e for c in containers for e in c)

    def maximum(
        container: IntegerSet
    ) -> Integer:
        """ maximum """
        return max(container, default=0)

    def minimum(
        container: IntegerSet
    ) -> Integer:
        """ minimum """
        return min(container, default=0)

    def valmax(
        container: Container,
        compfunc: Callable
    ) -> Integer:
        """ maximum by custom function """
        return compfunc(max(container, key=compfunc, default=0))

    def valmin(
        container: Container,
        compfunc: Callable
    ) -> Integer:
        """ minimum by custom function """
        return compfunc(min(container, key=compfunc, default=0))

    def argmax(
        container: Container,
        compfunc: Callable
    ) -> Any:
        """ largest item by custom order """
        return max(container, key=compfunc)

    def argmin(
        container: Container,
        compfunc: Callable
    ) -> Any:
        """ smallest item by custom order """
        return min(container, key=compfunc)

    def mostcommon(
        container: Container
    ) -> Any:
        """ most common item """
        return max(set(container), key=container.count)

    def leastcommon(
        container: Container
    ) -> Any:
        """ least common item """
        return min(set(container), key=container.count)

    def initset(
        value: Any
    ) -> FrozenSet:
        """ initialize container """
        return frozenset({value})

    def both(
        a: Boolean,
        b: Boolean
    ) -> Boolean:
        """ logical and """
        return a and b

    def either(
        a: Boolean,
        b: Boolean
    ) -> Boolean:
        """ logical or """
        return a or b

    def increment(
        x: Numerical
    ) -> Numerical:
        """ incrementing """
        return x + 1 if isinstance(x, int) else (x[0] + 1, x[1] + 1)

    def decrement(
        x: Numerical
    ) -> Numerical:
        """ decrementing """
        return x - 1 if isinstance(x, int) else (x[0] - 1, x[1] - 1)

    def crement(
        x: Numerical
    ) -> Numerical:
        """ incrementing positive and decrementing negative """
        if isinstance(x, int):
            return 0 if x == 0 else (x + 1 if x > 0 else x - 1)
        return (
            0 if x[0] == 0 else (x[0] + 1 if x[0] > 0 else x[0] - 1),
            0 if x[1] == 0 else (x[1] + 1 if x[1] > 0 else x[1] - 1)
        )

    def sign(
        x: Numerical
    ) -> Numerical:
        """ sign """
        if isinstance(x, int):
            return 0 if x == 0 else (1 if x > 0 else -1)
        return (
            0 if x[0] == 0 else (1 if x[0] > 0 else -1),
            0 if x[1] == 0 else (1 if x[1] > 0 else -1)
        )

    def positive(
        x: Integer
    ) -> Boolean:
        """ positive """
        return x > 0

    def toivec(
        i: Integer
    ) -> IntegerTuple:
        """ vector pointing vertically """
        return (i, 0)

    def tojvec(
        j: Integer
    ) -> IntegerTuple:
        """ vector pointing horizontally """
        return (0, j)

    def sfilter(
        container: Container,
        condition: Callable
    ) -> Container:
        """ keep elements in container that satisfy condition """
        return type(container)(e for e in container if condition(e))

    def mfilter(
        container: Container,
        function: Callable
    ) -> FrozenSet:
        """ filter and merge """
        return merge(sfilter(container, function))

    def extract(
        container: Container,
        condition: Callable
    ) -> Any:
        """ first element of container that satisfies condition """
        return next(e for e in container if condition(e))

    def totuple(
        container: FrozenSet
    ) -> Tuple:
        """ conversion to tuple """
        return tuple(container)

    def first(
        container: Container
    ) -> Any:
        """ first item of container """
        return next(iter(container))

    def last(
        container: Container
    ) -> Any:
        """ last item of container """
        return max(enumerate(container))[1]

    def insert(
        value: Any,
        container: FrozenSet
    ) -> FrozenSet:
        """ insert item into container """
        return container.union(frozenset({value}))

    def remove(
        value: Any,
        container: Container
    ) -> Container:
        """ remove item from container """
        return type(container)(e for e in container if e != value)

    def other(
        container: Container,
        value: Any
    ) -> Any:
        """ other value in the container """
        return first(remove(value, container))

    def interval(
        start: Integer,
        stop: Integer,
        step: Integer
    ) -> Tuple:
        """ range """
        return tuple(range(start, stop, step))

    def astuple(
        a: Integer,
        b: Integer
    ) -> IntegerTuple:
        """ constructs a tuple """
        return (a, b)

    def product(
        a: Container,
        b: Container
    ) -> FrozenSet:
        """ cartesian product """
        return frozenset((i, j) for j in b for i in a)

    def pair(
        a: Tuple,
        b: Tuple
    ) -> TupleTuple:
        """ zipping of two tuples """
        return tuple(zip(a, b))

    def branch(
        condition: Boolean,
        a: Any,
        b: Any
    ) -> Any:
        """ if else branching """
        return a if condition else b

    def compose(
        outer: Callable,
        inner: Callable
    ) -> Callable:
        """ function composition """
        return lambda x: outer(inner(x))

    def chain(
        h: Callable,
        g: Callable,
        f: Callable,
    ) -> Callable:
        """ function composition with three functions """
        return lambda x: h(g(f(x)))

    def matcher(
        function: Callable,
        target: Any
    ) -> Callable:
        """ construction of equality function """
        return lambda x: function(x) == target

    def rbind(
        function: Callable,
        fixed: Any
    ) -> Callable:
        """ fix the rightmost argument """
        n = function.__code__.co_argcount
        if n == 2:
            return lambda x: function(x, fixed)
        elif n == 3:
            return lambda x, y: function(x, y, fixed)
        else:
            return lambda x, y, z: function(x, y, z, fixed)

    def lbind(
        function: Callable,
        fixed: Any
    ) -> Callable:
        """ fix the leftmost argument """
        n = function.__code__.co_argcount
        if n == 2:
            return lambda y: function(fixed, y)
        elif n == 3:
            return lambda y, z: function(fixed, y, z)
        else:
            return lambda y, z, a: function(fixed, y, z, a)

    def power(
        function: Callable,
        n: Integer
    ) -> Callable:
        """ power of function """
        if n == 1:
            return function
        return compose(function, power(function, n - 1))

    def fork(
        outer: Callable,
        a: Callable,
        b: Callable
    ) -> Callable:
        """ creates a wrapper function """
        return lambda x: outer(a(x), b(x))

    def apply(
        function: Callable,
        container: Container
    ) -> Container:
        """ apply function to each item in container """
        return type(container)(function(e) for e in container)

    def rapply(
        functions: Container,
        value: Any
    ) -> Container:
        """ apply each function in container to value """
        return type(functions)(function(value) for function in functions)

    def mapply(
        function: Callable,
        container: ContainerContainer
    ) -> FrozenSet:
        """ apply and merge """
        return merge(apply(function, container))

    def papply(
        function: Callable,
        a: Tuple,
        b: Tuple
    ) -> Tuple:
        """ apply function on two vectors """
        return tuple(function(i, j) for i, j in zip(a, b))

    def mpapply(
        function: Callable,
        a: Tuple,
        b: Tuple
    ) -> Tuple:
        """ apply function on two vectors and merge """
        return merge(papply(function, a, b))

    def prapply(
        function,
        a: Container,
        b: Container
    ) -> FrozenSet:
        """ apply function on cartesian product """
        return frozenset(function(i, j) for j in b for i in a)

    def mostcolor(
        element: Element
    ) -> Integer:
        """ most common color """
        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]
        return max(set(values), key=values.count)
        

    def leastcolor(
        element: Element
    ) -> Integer:
        """ least common color """
        values = [v for r in element for v in r] if isinstance(element, tuple) else [v for v, _ in element]
        return min(set(values), key=values.count)

    def height(
        piece: Piece
    ) -> Integer:
        """ height of grid or patch """
        if len(piece) == 0:
            return 0
        if isinstance(piece, tuple):
            return len(piece)
        return lowermost(piece) - uppermost(piece) + 1

    def width(
        piece: Piece
    ) -> Integer:
        """ width of grid or patch """
        if len(piece) == 0:
            return 0
        if isinstance(piece, tuple):
            return len(piece[0])
        return rightmost(piece) - leftmost(piece) + 1

    def shape(
        piece: Piece
    ) -> IntegerTuple:
        """ height and width of grid or patch """
        return (height(piece), width(piece))

    def portrait(
        piece: Piece
    ) -> Boolean:
        """ whether height is greater than width """
        return height(piece) > width(piece)

    def colorcount(
        element: Element,
        value: Integer
    ) -> Integer:
        """ number of cells with color """
        if isinstance(element, tuple):
            return sum(row.count(value) for row in element)
        return sum(v == value for v, _ in element)

    def colorfilter(
        objs: Objects,
        value: Integer
    ) -> Objects:
        """ filter objects by color """
        return frozenset(obj for obj in objs if next(iter(obj))[0] == value)

    def sizefilter(
        container: Container,
        n: Integer
    ) -> FrozenSet:
        """ filter items by size """
        return frozenset(item for item in container if len(item) == n)

    def asindices(
        grid: Grid
    ) -> Indices:
        """ indices of all grid cells """
        return frozenset((i, j) for i in range(len(grid)) for j in range(len(grid[0])))

    def ofcolor(
        grid: Grid,
        value: Integer
    ) -> Indices:
        """ indices of all grid cells with value """
        return frozenset((i, j) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value)

    def ulcorner(
        patch: Patch
    ) -> IntegerTuple:
        """ index of upper left corner """
        return tuple(map(min, zip(*toindices(patch))))

    def urcorner(
        patch: Patch
    ) -> IntegerTuple:
        """ index of upper right corner """
        return tuple(map(lambda ix: {0: min, 1: max}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))

    def llcorner(
        patch: Patch
    ) -> IntegerTuple:
        """ index of lower left corner """
        return tuple(map(lambda ix: {0: max, 1: min}[ix[0]](ix[1]), enumerate(zip(*toindices(patch)))))

    def lrcorner(
        patch: Patch
    ) -> IntegerTuple:
        """ index of lower right corner """
        return tuple(map(max, zip(*toindices(patch))))

    def crop(
        grid: Grid,
        start: IntegerTuple,
        dims: IntegerTuple
    ) -> Grid:
        """ subgrid specified by start and dimension """
        return tuple(r[start[1]:start[1]+dims[1]] for r in grid[start[0]:start[0]+dims[0]])

    def toindices(
        patch: Patch
    ) -> Indices:
        """ indices of object cells """
        if len(patch) == 0:
            return frozenset()
        if isinstance(next(iter(patch))[1], tuple):
            return frozenset(index for value, index in patch)
        return patch

    def recolor(
        value: Integer,
        patch: Patch
    ) -> Object:
        """ recolor patch """
        return frozenset((value, index) for index in toindices(patch))

    def shift(
        patch: Patch,
        directions: IntegerTuple
    ) -> Patch:
        """ shift patch """
        if len(patch) == 0:
            return patch
        di, dj = directions
        if isinstance(next(iter(patch))[1], tuple):
            return frozenset((value, (i + di, j + dj)) for value, (i, j) in patch)
        return frozenset((i + di, j + dj) for i, j in patch)

    def normalize(
        patch: Patch
    ) -> Patch:
        """ moves upper left corner to origin """
        if len(patch) == 0:
            return patch
        return shift(patch, (-uppermost(patch), -leftmost(patch)))

    def dneighbors(
        loc: IntegerTuple
    ) -> Indices:
        """ directly adjacent indices """
        return frozenset({(loc[0] - 1, loc[1]), (loc[0] + 1, loc[1]), (loc[0], loc[1] - 1), (loc[0], loc[1] + 1)})

    def ineighbors(
        loc: IntegerTuple
    ) -> Indices:
        """ diagonally adjacent indices """
        return frozenset({(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1] + 1), (loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})

    def neighbors(
        loc: IntegerTuple
    ) -> Indices:
        """ adjacent indices """
        return dneighbors(loc) | ineighbors(loc)

    def objects(
        grid: Grid,
        univalued: Boolean,
        diagonal: Boolean,
        without_bg: Boolean
    ) -> Objects:
        """ objects occurring on the grid """
        bg = mostcolor(grid) if without_bg else None
        objs = set()
        occupied = set()
        h, w = len(grid), len(grid[0])
        unvisited = asindices(grid)
        diagfun = neighbors if diagonal else dneighbors
        for loc in unvisited:
            if loc in occupied:
                continue
            val = grid[loc[0]][loc[1]]
            if val == bg:
                continue
            obj = {(val, loc)}
            cands = {loc}
            while len(cands) > 0:
                neighborhood = set()
                for cand in cands:
                    v = grid[cand[0]][cand[1]]
                    if (val == v) if univalued else (v != bg):
                        obj.add((v, cand))
                        occupied.add(cand)
                        neighborhood |= {
                            (i, j) for i, j in diagfun(cand) if 0 <= i < h and 0 <= j < w
                        }
                cands = neighborhood - occupied
            objs.add(frozenset(obj))
        return frozenset(objs)

    def partition(
        grid: Grid
    ) -> Objects:
        """ each cell with the same value part of the same object """
        return frozenset(
            frozenset(
                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value
            ) for value in palette(grid)
        )

    def fgpartition(
        grid: Grid
    ) -> Objects:
        """ each cell with the same value part of the same object without background """
        return frozenset(
            frozenset(
                (v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r) if v == value
            ) for value in palette(grid) - {mostcolor(grid)}
        )

    def uppermost(
        patch: Patch
    ) -> Integer:
        """ row index of uppermost occupied cell """
        return min(i for i, j in toindices(patch))

    def lowermost(
        patch: Patch
    ) -> Integer:
        """ row index of lowermost occupied cell """
        return max(i for i, j in toindices(patch))

    def leftmost(
        patch: Patch
    ) -> Integer:
        """ column index of leftmost occupied cell """
        return min(j for i, j in toindices(patch))

    def rightmost(
        patch: Patch
    ) -> Integer:
        """ column index of rightmost occupied cell """
        return max(j for i, j in toindices(patch))

    def square(
        piece: Piece
    ) -> Boolean:
        """ whether the piece forms a square """
        return len(piece) == len(piece[0]) if isinstance(piece, tuple) else height(piece) * width(piece) == len(piece) and height(piece) == width(piece)

    def vline(
        patch: Patch
    ) -> Boolean:
        """ whether the piece forms a vertical line """
        return height(patch) == len(patch) and width(patch) == 1

    def hline(
        patch: Patch
    ) -> Boolean:
        """ whether the piece forms a horizontal line """
        return width(patch) == len(patch) and height(patch) == 1

    def hmatching(
        a: Patch,
        b: Patch
    ) -> Boolean:
        """ whether there exists a row for which both patches have cells """
        return len(set(i for i, j in toindices(a)) & set(i for i, j in toindices(b))) > 0

    def vmatching(
        a: Patch,
        b: Patch
    ) -> Boolean:
        """ whether there exists a column for which both patches have cells """
        return len(set(j for i, j in toindices(a)) & set(j for i, j in toindices(b))) > 0

    def manhattan(
        a: Patch,
        b: Patch
    ) -> Integer:
        """ closest manhattan distance between two patches """
        return min(abs(ai - bi) + abs(aj - bj) for ai, aj in toindices(a) for bi, bj in toindices(b))

    def adjacent(
        a: Patch,
        b: Patch
    ) -> Boolean:
        """ whether two patches are adjacent """
        return manhattan(a, b) == 1

    def bordering(
        patch: Patch,
        grid: Grid
    ) -> Boolean:
        """ whether a patch is adjacent to a grid border """
        return uppermost(patch) == 0 or leftmost(patch) == 0 or lowermost(patch) == len(grid) - 1 or rightmost(patch) == len(grid[0]) - 1

    def centerofmass(
        patch: Patch
    ) -> IntegerTuple:
        """ center of mass """
        return tuple(map(lambda x: sum(x) // len(patch), zip(*toindices(patch))))

    def palette(
        element: Element
    ) -> IntegerSet:
        """ colors occurring in object or grid """
        if isinstance(element, tuple):
            return frozenset({v for r in element for v in r})
        return frozenset({v for v, _ in element})

    def numcolors(
        element: Element
    ) -> IntegerSet:
        """ number of colors occurring in object or grid """
        return len(palette(element))

    def color(
        obj: Object
    ) -> Integer:
        """ color of object """
        return next(iter(obj))[0]

    def toobject(
        patch: Patch,
        grid: Grid
    ) -> Object:
        """ object from patch and grid """
        h, w = len(grid), len(grid[0])
        return frozenset((grid[i][j], (i, j)) for i, j in toindices(patch) if 0 <= i < h and 0 <= j < w)

    def asobject(
        grid: Grid
    ) -> Object:
        """ conversion of grid to object """
        return frozenset((v, (i, j)) for i, r in enumerate(grid) for j, v in enumerate(r))

    def rot90(
        grid: Grid
    ) -> Grid:
        """ quarter clockwise rotation """
        return tuple(row for row in zip(*grid[::-1]))

    def rot180(
        grid: Grid
    ) -> Grid:
        """ half rotation """
        return tuple(tuple(row[::-1]) for row in grid[::-1])

    def rot270(
        grid: Grid
    ) -> Grid:
        """ quarter anticlockwise rotation """
        return tuple(tuple(row[::-1]) for row in zip(*grid[::-1]))[::-1]

    def hmirror(
        piece: Piece
    ) -> Piece:
        """ mirroring along horizontal """
        if isinstance(piece, tuple):
            return piece[::-1]
        d = ulcorner(piece)[0] + lrcorner(piece)[0]
        if isinstance(next(iter(piece))[1], tuple):
            return frozenset((v, (d - i, j)) for v, (i, j) in piece)
        return frozenset((d - i, j) for i, j in piece)

    def vmirror(
        piece: Piece
    ) -> Piece:
        """ mirroring along vertical """
        if isinstance(piece, tuple):
            return tuple(row[::-1] for row in piece)
        d = ulcorner(piece)[1] + lrcorner(piece)[1]
        if isinstance(next(iter(piece))[1], tuple):
            return frozenset((v, (i, d - j)) for v, (i, j) in piece)
        return frozenset((i, d - j) for i, j in piece)

    def dmirror(
        piece: Piece
    ) -> Piece:
        """ mirroring along diagonal """
        if isinstance(piece, tuple):
            return tuple(zip(*piece))
        a, b = ulcorner(piece)
        if isinstance(next(iter(piece))[1], tuple):
            return frozenset((v, (j - b + a, i - a + b)) for v, (i, j) in piece)
        return frozenset((j - b + a, i - a + b) for i, j in piece)

    def cmirror(
        piece: Piece
    ) -> Piece:
        """ mirroring along counterdiagonal """
        if isinstance(piece, tuple):
            return tuple(zip(*(r[::-1] for r in piece[::-1])))
        return vmirror(dmirror(vmirror(piece)))

    def fill(
        grid: Grid,
        value: Integer,
        patch: Patch
    ) -> Grid:
        """ fill value at indices """
        h, w = len(grid), len(grid[0])
        grid_filled = list(list(row) for row in grid)
        for i, j in toindices(patch):
            if 0 <= i < h and 0 <= j < w:
                grid_filled[i][j] = value
        return tuple(tuple(row) for row in grid_filled)

    def paint(
        grid: Grid,
        obj: Object
    ) -> Grid:
        """ paint object to grid """
        h, w = len(grid), len(grid[0])
        grid_painted = list(list(row) for row in grid)
        for value, (i, j) in obj:
            if 0 <= i < h and 0 <= j < w:
                grid_painted[i][j] = value
        return tuple(tuple(row) for row in grid_painted)

    def underfill(
        grid: Grid,
        value: Integer,
        patch: Patch
    ) -> Grid:
        """ fill value at indices that are background """
        h, w = len(grid), len(grid[0])
        bg = mostcolor(grid)
        g = list(list(r) for r in grid)
        for i, j in toindices(patch):
            if 0 <= i < h and 0 <= j < w:
                if g[i][j] == bg:
                    g[i][j] = value
        return tuple(tuple(r) for r in g)

    def underpaint(
        grid: Grid,
        obj: Object
    ) -> Grid:
        """ paint object to grid where there is background """
        h, w = len(grid), len(grid[0])
        bg = mostcolor(grid)
        g = list(list(r) for r in grid)
        for value, (i, j) in obj:
            if 0 <= i < h and 0 <= j < w:
                if g[i][j] == bg:
                    g[i][j] = value
        return tuple(tuple(r) for r in g)

    def hupscale(
        grid: Grid,
        factor: Integer
    ) -> Grid:
        """ upscale grid horizontally """
        g = tuple()
        for row in grid:
            r = tuple()
            for value in row:
                r = r + tuple(value for num in range(factor))
            g = g + (r,)
        return g

    def vupscale(
        grid: Grid,
        factor: Integer
    ) -> Grid:
        """ upscale grid vertically """
        g = tuple()
        for row in grid:
            g = g + tuple(row for num in range(factor))
        return g

    def upscale(
        element: Element,
        factor: Integer
    ) -> Element:
        """ upscale object or grid """
        if isinstance(element, tuple):
            g = tuple()
            for row in element:
                upscaled_row = tuple()
                for value in row:
                    upscaled_row = upscaled_row + tuple(value for num in range(factor))
                g = g + tuple(upscaled_row for num in range(factor))
            return g
        else:
            if len(element) == 0:
                return frozenset()
            di_inv, dj_inv = ulcorner(element)
            di, dj = (-di_inv, -dj_inv)
            normed_obj = shift(element, (di, dj))
            o = set()
            for value, (i, j) in normed_obj:
                for io in range(factor):
                    for jo in range(factor):
                        o.add((value, (i * factor + io, j * factor + jo)))
            return shift(frozenset(o), (di_inv, dj_inv))

    def downscale(
        grid: Grid,
        factor: Integer
    ) -> Grid:
        """ downscale grid """
        h, w = len(grid), len(grid[0])
        g = tuple()
        for i in range(h):
            r = tuple()
            for j in range(w):
                if j % factor == 0:
                    r = r + (grid[i][j],)
            g = g + (r, )
        h = len(g)
        dsg = tuple()
        for i in range(h):
            if i % factor == 0:
                dsg = dsg + (g[i],)
        return dsg

    def hconcat(
        a: Grid,
        b: Grid
    ) -> Grid:
        """ concatenate two grids horizontally """
        return tuple(i + j for i, j in zip(a, b))

    def vconcat(
        a: Grid,
        b: Grid
    ) -> Grid:
        """ concatenate two grids vertically """
        return a + b

    def subgrid(
        patch: Patch,
        grid: Grid
    ) -> Grid:
        """ smallest subgrid containing object """
        return crop(grid, ulcorner(patch), shape(patch))

    def hsplit(
        grid: Grid,
        n: Integer
    ) -> Tuple:
        """ split grid horizontally """
        h, w = len(grid), len(grid[0]) // n
        offset = len(grid[0]) % n != 0
        return tuple(crop(grid, (0, w * i + i * offset), (h, w)) for i in range(n))

    def vsplit(
        grid: Grid,
        n: Integer
    ) -> Tuple:
        """ split grid vertically """
        h, w = len(grid) // n, len(grid[0])
        offset = len(grid) % n != 0
        return tuple(crop(grid, (h * i + i * offset, 0), (h, w)) for i in range(n))

    def cellwise(
        a: Grid,
        b: Grid,
        fallback: Integer
    ) -> Grid:
        """ cellwise match of two grids """
        h, w = len(a), len(a[0])
        resulting_grid = tuple()
        for i in range(h):
            row = tuple()
            for j in range(w):
                a_value = a[i][j]
                value = a_value if a_value == b[i][j] else fallback
                row = row + (value,)
            resulting_grid = resulting_grid + (row, )
        return resulting_grid

    def replace(
        grid: Grid,
        replacee: Integer,
        replacer: Integer
    ) -> Grid:
        """ color substitution """
        return tuple(tuple(replacer if v == replacee else v for v in r) for r in grid)

    def switch(
        grid: Grid,
        a: Integer,
        b: Integer
    ) -> Grid:
        """ color switching """
        return tuple(tuple(v if (v != a and v != b) else {a: b, b: a}[v] for v in r) for r in grid)

    def center(
        patch: Patch
    ) -> IntegerTuple:
        """ center of the patch """
        return (uppermost(patch) + height(patch) // 2, leftmost(patch) + width(patch) // 2)

    def position(
        a: Patch,
        b: Patch
    ) -> IntegerTuple:
        """ relative position between two patches """
        ia, ja = center(toindices(a))
        ib, jb = center(toindices(b))
        if ia == ib:
            return (0, 1 if ja < jb else -1)
        elif ja == jb:
            return (1 if ia < ib else -1, 0)
        elif ia < ib:
            return (1, 1 if ja < jb else -1)
        elif ia > ib:
            return (-1, 1 if ja < jb else -1)

    def index(
        grid: Grid,
        loc: IntegerTuple
    ) -> Integer:
        """ color at location """
        i, j = loc
        h, w = len(grid), len(grid[0])
        if not (0 <= i < h and 0 <= j < w):
            return None
        return grid[loc[0]][loc[1]] 

    def canvas(
        value: Integer,
        dimensions: IntegerTuple
    ) -> Grid:
        """ grid construction """
        return tuple(tuple(value for j in range(dimensions[1])) for i in range(dimensions[0]))

    def corners(
        patch: Patch
    ) -> Indices:
        """ indices of corners """
        return frozenset({ulcorner(patch), urcorner(patch), llcorner(patch), lrcorner(patch)})

    def connect(
        a: IntegerTuple,
        b: IntegerTuple
    ) -> Indices:
        """ line between two points """
        ai, aj = a
        bi, bj = b
        si = min(ai, bi)
        ei = max(ai, bi) + 1
        sj = min(aj, bj)
        ej = max(aj, bj) + 1
        if ai == bi:
            return frozenset((ai, j) for j in range(sj, ej))
        elif aj == bj:
            return frozenset((i, aj) for i in range(si, ei))
        elif bi - ai == bj - aj:
            return frozenset((i, j) for i, j in zip(range(si, ei), range(sj, ej)))
        elif bi - ai == aj - bj:
            return frozenset((i, j) for i, j in zip(range(si, ei), range(ej - 1, sj - 1, -1)))
        return frozenset()

    def cover(
        grid: Grid,
        patch: Patch
    ) -> Grid:
        """ remove object from grid """
        return fill(grid, mostcolor(grid), toindices(patch))

    def trim(
        grid: Grid
    ) -> Grid:
        """ trim border of grid """
        return tuple(r[1:-1] for r in grid[1:-1])

    def move(
        grid: Grid,
        obj: Object,
        offset: IntegerTuple
    ) -> Grid:
        """ move object on grid """
        return paint(cover(grid, obj), shift(obj, offset))

    def tophalf(
        grid: Grid
    ) -> Grid:
        """ upper half of grid """
        return grid[:len(grid) // 2]

    def bottomhalf(
        grid: Grid
    ) -> Grid:
        """ lower half of grid """
        return grid[len(grid) // 2 + len(grid) % 2:]

    def lefthalf(
        grid: Grid
    ) -> Grid:
        """ left half of grid """
        return rot270(tophalf(rot90(grid)))

    def righthalf(
        grid: Grid
    ) -> Grid:
        """ right half of grid """
        return rot270(bottomhalf(rot90(grid)))

    def vfrontier(
        location: IntegerTuple
    ) -> Indices:
        """ vertical frontier """
        return frozenset((i, location[1]) for i in range(30))

    def hfrontier(
        location: IntegerTuple
    ) -> Indices:
        """ horizontal frontier """
        return frozenset((location[0], j) for j in range(30))

    def backdrop(
        patch: Patch
    ) -> Indices:
        """ indices in bounding box of patch """
        if len(patch) == 0:
            return frozenset({})
        indices = toindices(patch)
        si, sj = ulcorner(indices)
        ei, ej = lrcorner(patch)
        return frozenset((i, j) for i in range(si, ei + 1) for j in range(sj, ej + 1))

    def delta(
        patch: Patch
    ) -> Indices:
        """ indices in bounding box but not part of patch """
        if len(patch) == 0:
            return frozenset({})
        return backdrop(patch) - toindices(patch)

    def gravitate(
        source: Patch,
        destination: Patch
    ) -> IntegerTuple:
        """ direction to move source until adjacent to destination """
        si, sj = center(source)
        di, dj = center(destination)
        i, j = 0, 0
        if vmatching(source, destination):
            i = 1 if si < di else -1
        else:
            j = 1 if sj < dj else -1
        gi, gj = i, j
        c = 0
        while not adjacent(source, destination) and c < 42:
            c += 1
            gi += i
            gj += j
            source = shift(source, (i, j))
        return (gi - i, gj - j)

    def inbox(
        patch: Patch
    ) -> Indices:
        """ inbox for patch """
        ai, aj = uppermost(patch) + 1, leftmost(patch) + 1
        bi, bj = lowermost(patch) - 1, rightmost(patch) - 1
        si, sj = min(ai, bi), min(aj, bj)
        ei, ej = max(ai, bi), max(aj, bj)
        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}
        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}
        return frozenset(vlines | hlines)

    def outbox(
        patch: Patch
    ) -> Indices:
        """ outbox for patch """
        ai, aj = uppermost(patch) - 1, leftmost(patch) - 1
        bi, bj = lowermost(patch) + 1, rightmost(patch) + 1
        si, sj = min(ai, bi), min(aj, bj)
        ei, ej = max(ai, bi), max(aj, bj)
        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}
        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}
        return frozenset(vlines | hlines)

    def box(
        patch: Patch
    ) -> Indices:
        """ outline of patch """
        if len(patch) == 0:
            return patch
        ai, aj = ulcorner(patch)
        bi, bj = lrcorner(patch)
        si, sj = min(ai, bi), min(aj, bj)
        ei, ej = max(ai, bi), max(aj, bj)
        vlines = {(i, sj) for i in range(si, ei + 1)} | {(i, ej) for i in range(si, ei + 1)}
        hlines = {(si, j) for j in range(sj, ej + 1)} | {(ei, j) for j in range(sj, ej + 1)}
        return frozenset(vlines | hlines)

    def shoot(
        start: IntegerTuple,
        direction: IntegerTuple
    ) -> Indices:
        """ line from starting point and direction """
        return connect(start, (start[0] + 42 * direction[0], start[1] + 42 * direction[1]))

    def occurrences(
        grid: Grid,
        obj: Object
    ) -> Indices:
        """ locations of occurrences of object in grid """
        occs = set()
        normed = normalize(obj)
        h, w = len(grid), len(grid[0])
        oh, ow = shape(obj)
        h2, w2 = h - oh + 1, w - ow + 1
        for i in range(h2):
            for j in range(w2):
                occurs = True
                for v, (a, b) in shift(normed, (i, j)):
                    if not (0 <= a < h and 0 <= b < w and grid[a][b] == v):
                        occurs = False
                        break
                if occurs:
                    occs.add((i, j))
        return frozenset(occs)

    def frontiers(
        grid: Grid
    ) -> Objects:
        """ set of frontiers """
        h, w = len(grid), len(grid[0])
        row_indices = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)
        column_indices = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)
        hfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for j in range(w)}) for i in row_indices})
        vfrontiers = frozenset({frozenset({(grid[i][j], (i, j)) for i in range(h)}) for j in column_indices})
        return hfrontiers | vfrontiers

    def compress(
        grid: Grid
    ) -> Grid:
        """ removes frontiers from grid """
        ri = tuple(i for i, r in enumerate(grid) if len(set(r)) == 1)
        ci = tuple(j for j, c in enumerate(dmirror(grid)) if len(set(c)) == 1)
        return tuple(tuple(v for j, v in enumerate(r) if j not in ci) for i, r in enumerate(grid) if i not in ri)

    def hperiod(
        obj: Object
    ) -> Integer:
        """ horizontal periodicity """
        normalized = normalize(obj)
        w = width(normalized)
        for p in range(1, w):
            offsetted = shift(normalized, (0, -p))
            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if j >= 0})
            if pruned.issubset(normalized):
                return p
        return w

    def vperiod(
        obj: Object
    ) -> Integer:
        """ vertical periodicity """
        normalized = normalize(obj)
        h = height(normalized)
        for p in range(1, h):
            offsetted = shift(normalized, (-p, 0))
            pruned = frozenset({(c, (i, j)) for c, (i, j) in offsetted if i >= 0})
            if pruned.issubset(normalized):
                return p
        return h

class Seeker:  #求解任务  #multi-solution@re-arc
    def solve_67a3c6ac(I):
        O = vmirror(I)
        return O

    def solve_68b16354(I):
        O = hmirror(I)
        return O

    def solve_74dd1130(I):
        O = dmirror(I)
        return O

    def solve_3c9b0459(I):
        O = rot180(I)
        return O

    def solve_6150a2bd(I):
        O = rot180(I)
        return O

    def solve_9172f3a0(I):
        O = upscale(I, THREE)
        return O

    def solve_9dfd6313(I):
        O = dmirror(I)
        return O

    def solve_a416b8f3(I):
        O = hconcat(I, I)
        return O

    def solve_b1948b0a(I):
        O = replace(I, SIX, TWO)
        return O

    def solve_c59eb873(I):
        O = upscale(I, TWO)
        return O

    def solve_c8f0f002(I):
        O = replace(I, SEVEN, FIVE)
        return O

    def solve_d10ecb37(I):
        O = crop(I, ORIGIN, TWO_BY_TWO)
        return O

    def solve_d511f180(I):
        O = switch(I, FIVE, EIGHT)
        return O

    def solve_ed36ccf7(I):
        O = rot270(I)
        return O

    def solve_4c4377d9(I):
        x1 = hmirror(I)
        O = vconcat(x1, I)
        return O

    def solve_6d0aefbc(I):
        x1 = vmirror(I)
        O = hconcat(I, x1)
        return O

    def solve_6fa7a44f(I):
        x1 = hmirror(I)
        O = vconcat(I, x1)
        return O

    def solve_5614dbcf(I):
        x1 = replace(I, FIVE, ZERO)
        O = downscale(x1, THREE)
        return O

    def solve_5bd6f4ac(I):
        x1 = tojvec(SIX)
        O = crop(I, x1, THREE_BY_THREE)
        return O

    def solve_5582e5ca(I):
        x1 = mostcolor(I)
        O = canvas(x1, THREE_BY_THREE)
        return O

    def solve_8be77c9e(I):
        x1 = hmirror(I)
        O = vconcat(I, x1)
        return O

    def solve_c9e6f938(I):
        x1 = vmirror(I)
        O = hconcat(I, x1)
        return O

    def solve_2dee498d(I):
        x1 = hsplit(I, THREE)
        O = first(x1)
        return O

    def solve_1cf80156(I):
        x1 = objects(I, T, T, T)
        x2 = first(x1)
        O = subgrid(x2, I)
        return O

    def solve_32597951(I):
        x1 = ofcolor(I, EIGHT)
        x2 = delta(x1)
        O = fill(I, THREE, x2)
        return O

    def solve_25ff71a9(I):
        x1 = objects(I, T, T, T)
        x2 = first(x1)
        O = move(I, x2, DOWN)
        return O

    def solve_0b148d64(I):
        x1 = partition(I)
        x2 = argmin(x1, size)
        O = subgrid(x2, I)
        return O

    def solve_1f85a75f(I):
        x1 = objects(I, T, T, T)
        x2 = argmax(x1, size)
        O = subgrid(x2, I)
        return O

    def solve_23b5c85d(I):
        x1 = objects(I, T, T, T)
        x2 = argmin(x1, size)
        O = subgrid(x2, I)
        return O

    def solve_9ecd008a(I):
        x1 = vmirror(I)
        x2 = ofcolor(I, ZERO)
        O = subgrid(x2, x1)
        return O

    def solve_ac0a08a4(I):
        x1 = colorcount(I, ZERO)
        x2 = subtract(NINE, x1)
        O = upscale(I, x2)
        return O

    def solve_be94b721(I):
        x1 = objects(I, T, F, T)
        x2 = argmax(x1, size)
        O = subgrid(x2, I)
        return O

    def solve_c909285e(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        O = subgrid(x2, I)
        return O

    def solve_f25ffba3(I):
        x1 = bottomhalf(I)
        x2 = hmirror(x1)
        O = vconcat(x2, x1)
        return O

    def solve_c1d99e64(I):
        x1 = frontiers(I)
        x2 = merge(x1)
        O = fill(I, TWO, x2)
        return O

    def solve_b91ae062(I):
        x1 = numcolors(I)
        x2 = decrement(x1)
        O = upscale(I, x2)
        return O

    def solve_3aa6fb7a(I):
        x1 = objects(I, T, F, T)
        x2 = mapply(corners, x1)
        O = underfill(I, ONE, x2)
        return O

    def solve_7b7f7511(I):
        x1 = portrait(I)
        x2 = branch(x1, tophalf, lefthalf)
        O = x2(I)
        return O

    def solve_4258a5f9(I):
        x1 = ofcolor(I, FIVE)
        x2 = mapply(neighbors, x1)
        O = fill(I, ONE, x2)
        return O

    def solve_2dc579da(I):
        x1 = vsplit(I, TWO)
        x2 = rbind(hsplit, TWO)
        x3 = mapply(x2, x1)
        O = argmax(x3, numcolors)
        return O

    def solve_28bf18c6(I):
        x1 = objects(I, T, T, T)
        x2 = first(x1)
        x3 = subgrid(x2, I)
        O = hconcat(x3, x3)
        return O

    def solve_3af2c5a8(I):
        x1 = vmirror(I)
        x2 = hconcat(I, x1)
        x3 = hmirror(x2)
        O = vconcat(x2, x3)
        return O

    def solve_44f52bb0(I):
        x1 = vmirror(I)
        x2 = equality(x1, I)
        x3 = branch(x2, ONE, SEVEN)
        O = canvas(x3, UNITY)
        return O

    def solve_62c24649(I):
        x1 = vmirror(I)
        x2 = hconcat(I, x1)
        x3 = hmirror(x2)
        O = vconcat(x2, x3)
        return O

    def solve_67e8384a(I):
        x1 = vmirror(I)
        x2 = hconcat(I, x1)
        x3 = hmirror(x2)
        O = vconcat(x2, x3)
        return O

    def solve_7468f01a(I):
        x1 = objects(I, F, T, T)
        x2 = first(x1)
        x3 = subgrid(x2, I)
        O = vmirror(x3)
        return O

    def solve_662c240a(I):
        x1 = vsplit(I, THREE)
        x2 = fork(equality, dmirror, identity)
        x3 = compose(flip, x2)
        O = extract(x1, x3)
        return O

    def solve_42a50994(I):
        x1 = objects(I, T, T, T)
        x2 = sizefilter(x1, ONE)
        x3 = merge(x2)
        O = cover(I, x3)
        return O

    def solve_56ff96f3(I):
        x1 = fgpartition(I)
        x2 = fork(recolor, color, backdrop)
        x3 = mapply(x2, x1)
        O = paint(I, x3)
        return O

    def solve_50cb2852(I):
        x1 = objects(I, T, F, T)
        x2 = compose(backdrop, inbox)
        x3 = mapply(x2, x1)
        O = fill(I, EIGHT, x3)
        return O

    def solve_4347f46a(I):
        x1 = objects(I, T, F, T)
        x2 = fork(difference, toindices, box)
        x3 = mapply(x2, x1)
        O = fill(I, ZERO, x3)
        return O

    def solve_46f33fce(I):
        x1 = rot180(I)
        x2 = downscale(x1, TWO)
        x3 = rot180(x2)
        O = upscale(x3, FOUR)
        return O

    def solve_a740d043(I):
        x1 = objects(I, T, T, T)
        x2 = merge(x1)
        x3 = subgrid(x2, I)
        O = replace(x3, ONE, ZERO)
        return O

    def solve_a79310a0(I):
        x1 = objects(I, T, F, T)
        x2 = first(x1)
        x3 = move(I, x2, DOWN)
        O = replace(x3, EIGHT, TWO)
        return O

    def solve_aabf363d(I):
        x1 = leastcolor(I)
        x2 = replace(I, x1, ZERO)
        x3 = leastcolor(x2)
        O = replace(x2, x3, x1)
        return O

    def solve_ae4f1146(I):
        x1 = objects(I, F, F, T)
        x2 = rbind(colorcount, ONE)
        x3 = argmax(x1, x2)
        O = subgrid(x3, I)
        return O

    def solve_b27ca6d3(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, TWO)
        x3 = mapply(outbox, x2)
        O = fill(I, THREE, x3)
        return O

    def solve_ce22a75a(I):
        x1 = objects(I, T, F, T)
        x2 = apply(outbox, x1)
        x3 = mapply(backdrop, x2)
        O = fill(I, ONE, x3)
        return O

    def solve_dc1df850(I):
        x1 = objects(I, T, F, T)
        x2 = colorfilter(x1, TWO)
        x3 = mapply(outbox, x2)
        O = fill(I, ONE, x3)
        return O

    def solve_f25fbde4(I):
        x1 = objects(I, T, T, T)
        x2 = first(x1)
        x3 = subgrid(x2, I)
        O = upscale(x3, TWO)
        return O

    def solve_44d8ac46(I):
        x1 = objects(I, T, F, T)
        x2 = apply(delta, x1)
        x3 = mfilter(x2, square)
        O = fill(I, TWO, x3)
        return O

    def solve_1e0a9b12(I):
        x1 = rot270(I)
        x2 = rbind(order, identity)
        x3 = apply(x2, x1)
        O = rot90(x3)
        return O

    def solve_0d3d703e(I):
        x1 = switch(I, THREE, FOUR)
        x2 = switch(x1, EIGHT, NINE)
        x3 = switch(x2, TWO, SIX)
        O = switch(x3, ONE, FIVE)
        return O

    def solve_3618c87e(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = merge(x2)
        O = move(I, x3, TWO_BY_ZERO)
        return O

    def solve_1c786137(I):
        x1 = objects(I, T, F, F)
        x2 = argmax(x1, height)
        x3 = subgrid(x2, I)
        O = trim(x3)
        return O

    def solve_8efcae92(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ONE)
        x3 = compose(size, delta)
        x4 = argmax(x2, x3)
        O = subgrid(x4, I)
        return O

    def solve_445eab21(I):
        x1 = objects(I, T, F, T)
        x2 = fork(multiply, height, width)
        x3 = argmax(x1, x2)
        x4 = color(x3)
        O = canvas(x4, TWO_BY_TWO)
        return O

    def solve_6f8cd79b(I):
        x1 = asindices(I)
        x2 = apply(initset, x1)
        x3 = rbind(bordering, I)
        x4 = mfilter(x2, x3)
        O = fill(I, EIGHT, x4)
        return O

    def solve_2013d3e2(I):
        x1 = objects(I, F, T, T)
        x2 = first(x1)
        x3 = subgrid(x2, I)
        x4 = lefthalf(x3)
        O = tophalf(x4)
        return O

    def solve_41e4d17e(I):
        x1 = objects(I, T, F, T)
        x2 = fork(combine, vfrontier, hfrontier)
        x3 = compose(x2, center)
        x4 = mapply(x3, x1)
        O = underfill(I, SIX, x4)
        return O

    def solve_9565186b(I):
        x1 = shape(I)
        x2 = objects(I, T, F, F)
        x3 = argmax(x2, size)
        x4 = canvas(FIVE, x1)
        O = paint(x4, x3)
        return O

    def solve_aedd82e4(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, TWO)
        x3 = sizefilter(x2, ONE)
        x4 = merge(x3)
        O = fill(I, ONE, x4)
        return O

    def solve_bb43febb(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, FIVE)
        x3 = compose(backdrop, inbox)
        x4 = mapply(x3, x2)
        O = fill(I, TWO, x4)
        return O

    def solve_e98196ab(I):
        x1 = tophalf(I)
        x2 = bottomhalf(I)
        x3 = objects(x1, T, F, T)
        x4 = merge(x3)
        O = paint(x2, x4)
        return O

    def solve_f76d97a5(I):
        x1 = palette(I)
        x2 = first(x1)
        x3 = last(x1)
        x4 = switch(I, x2, x3)
        O = replace(x4, FIVE, ZERO)
        return O

    def solve_ce9e57f2(I):
        x1 = objects(I, T, F, T)
        x2 = fork(connect, ulcorner, centerofmass)
        x3 = mapply(x2, x1)
        x4 = fill(I, EIGHT, x3)
        O = switch(x4, EIGHT, TWO)
        return O

    def solve_22eb0ac0(I):
        x1 = fgpartition(I)
        x2 = fork(recolor, color, backdrop)
        x3 = apply(x2, x1)
        x4 = mfilter(x3, hline)
        O = paint(I, x4)
        return O

    def solve_9f236235(I):
        x1 = compress(I)
        x2 = objects(I, T, F, F)
        x3 = vmirror(x1)
        x4 = valmin(x2, width)
        O = downscale(x3, x4)
        return O

    def solve_a699fb00(I):
        x1 = ofcolor(I, ONE)
        x2 = shift(x1, RIGHT)
        x3 = shift(x1, LEFT)
        x4 = intersection(x2, x3)
        O = fill(I, TWO, x4)
        return O

    def solve_46442a0e(I):
        x1 = rot90(I)
        x2 = rot180(I)
        x3 = rot270(I)
        x4 = hconcat(I, x1)
        x5 = hconcat(x3, x2)
        O = vconcat(x4, x5)
        return O

    def solve_7fe24cdd(I):
        x1 = rot90(I)
        x2 = rot180(I)
        x3 = rot270(I)
        x4 = hconcat(I, x1)
        x5 = hconcat(x3, x2)
        O = vconcat(x4, x5)
        return O

    def solve_0ca9ddb6(I):
        x1 = ofcolor(I, ONE)
        x2 = ofcolor(I, TWO)
        x3 = mapply(dneighbors, x1)
        x4 = mapply(ineighbors, x2)
        x5 = fill(I, SEVEN, x3)
        O = fill(x5, FOUR, x4)
        return O

    def solve_543a7ed5(I):
        x1 = objects(I, T, F, T)
        x2 = colorfilter(x1, SIX)
        x3 = mapply(outbox, x2)
        x4 = fill(I, THREE, x3)
        x5 = mapply(delta, x2)
        O = fill(x4, FOUR, x5)
        return O

    def solve_0520fde7(I):
        x1 = vmirror(I)
        x2 = lefthalf(x1)
        x3 = righthalf(x1)
        x4 = vmirror(x3)
        x5 = cellwise(x2, x4, ZERO)
        O = replace(x5, ONE, TWO)
        return O

    def solve_dae9d2b5(I):
        x1 = lefthalf(I)
        x2 = righthalf(I)
        x3 = ofcolor(x1, FOUR)
        x4 = ofcolor(x2, THREE)
        x5 = combine(x3, x4)
        O = fill(x1, SIX, x5)
        return O

    def solve_8d5021e8(I):
        x1 = vmirror(I)
        x2 = hconcat(x1, I)
        x3 = hmirror(x2)
        x4 = vconcat(x2, x3)
        x5 = vconcat(x4, x2)
        O = hmirror(x5)
        return O

    def solve_928ad970(I):
        x1 = ofcolor(I, FIVE)
        x2 = subgrid(x1, I)
        x3 = trim(x2)
        x4 = leastcolor(x3)
        x5 = inbox(x1)
        O = fill(I, x4, x5)
        return O

    def solve_b60334d2(I):
        x1 = ofcolor(I, FIVE)
        x2 = replace(I, FIVE, ZERO)
        x3 = mapply(dneighbors, x1)
        x4 = mapply(ineighbors, x1)
        x5 = fill(x2, ONE, x3)
        O = fill(x5, FIVE, x4)
        return O

    def solve_b94a9452(I):
        x1 = objects(I, F, F, T)
        x2 = first(x1)
        x3 = subgrid(x2, I)
        x4 = leastcolor(x3)
        x5 = mostcolor(x3)
        O = switch(x3, x4, x5)
        return O

    def solve_d037b0a7(I):
        x1 = objects(I, T, F, T)
        x2 = rbind(shoot, DOWN)
        x3 = compose(x2, center)
        x4 = fork(recolor, color, x3)
        x5 = mapply(x4, x1)
        O = paint(I, x5)
        return O

    def solve_d0f5fe59(I):
        x1 = objects(I, T, F, T)
        x2 = size(x1)
        x3 = astuple(x2, x2)
        x4 = canvas(ZERO, x3)
        x5 = shoot(ORIGIN, UNITY)
        O = fill(x4, EIGHT, x5)
        return O

    def solve_e3497940(I):
        x1 = lefthalf(I)
        x2 = righthalf(I)
        x3 = vmirror(x2)
        x4 = objects(x3, T, F, T)
        x5 = merge(x4)
        O = paint(x1, x5)
        return O

    def solve_e9afcf9a(I):
        x1 = astuple(TWO, ONE)
        x2 = crop(I, ORIGIN, x1)
        x3 = hmirror(x2)
        x4 = hconcat(x2, x3)
        x5 = hconcat(x4, x4)
        O = hconcat(x5, x4)
        return O

    def solve_48d8fb45(I):
        x1 = objects(I, T, T, T)
        x2 = matcher(size, ONE)
        x3 = extract(x1, x2)
        x4 = lbind(adjacent, x3)
        x5 = extract(x1, x4)
        O = subgrid(x5, I)
        return O

    def solve_d406998b(I):
        x1 = vmirror(I)
        x2 = ofcolor(x1, FIVE)
        x3 = compose(even, last)
        x4 = sfilter(x2, x3)
        x5 = fill(x1, THREE, x4)
        O = vmirror(x5)
        return O

    def solve_5117e062(I):
        x1 = objects(I, F, T, T)
        x2 = matcher(numcolors, TWO)
        x3 = extract(x1, x2)
        x4 = subgrid(x3, I)
        x5 = mostcolor(x3)
        O = replace(x4, EIGHT, x5)
        return O

    def solve_3906de3d(I):
        x1 = rot270(I)
        x2 = rbind(order, identity)
        x3 = switch(x1, ONE, TWO)
        x4 = apply(x2, x3)
        x5 = switch(x4, ONE, TWO)
        O = cmirror(x5)
        return O

    def solve_00d62c1b(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = rbind(bordering, I)
        x4 = compose(flip, x3)
        x5 = mfilter(x2, x4)
        O = fill(I, FOUR, x5)
        return O

    def solve_7b6016b9(I):
        x1 = objects(I, T, F, F)
        x2 = rbind(bordering, I)
        x3 = compose(flip, x2)
        x4 = mfilter(x1, x3)
        x5 = fill(I, TWO, x4)
        O = replace(x5, ZERO, THREE)
        return O

    def solve_67385a82(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, THREE)
        x3 = sizefilter(x2, ONE)
        x4 = difference(x2, x3)
        x5 = merge(x4)
        O = fill(I, EIGHT, x5)
        return O

    def solve_a5313dff(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = rbind(bordering, I)
        x4 = compose(flip, x3)
        x5 = mfilter(x2, x4)
        O = fill(I, ONE, x5)
        return O

    def solve_ea32f347(I):
        x1 = objects(I, T, F, T)
        x2 = replace(I, FIVE, FOUR)
        x3 = argmin(x1, size)
        x4 = argmax(x1, size)
        x5 = fill(x2, ONE, x4)
        O = fill(x5, TWO, x3)
        return O

    def solve_d631b094(I):
        x1 = palette(I)
        x2 = other(x1, ZERO)
        x3 = ofcolor(I, x2)
        x4 = size(x3)
        x5 = astuple(ONE, x4)
        O = canvas(x2, x5)
        return O

    def solve_10fcaaa3(I):
        x1 = leastcolor(I)
        x2 = hconcat(I, I)
        x3 = vconcat(x2, x2)
        x4 = ofcolor(x3, x1)
        x5 = mapply(ineighbors, x4)
        O = underfill(x3, EIGHT, x5)
        return O

    def solve_007bbfb7(I):
        x1 = hupscale(I, THREE)
        x2 = vupscale(x1, THREE)
        x3 = hconcat(I, I)
        x4 = hconcat(x3, I)
        x5 = vconcat(x4, x4)
        x6 = vconcat(x5, x4)
        O = cellwise(x2, x6, ZERO)
        return O

    def solve_496994bd(I):
        x1 = width(I)
        x2 = height(I)
        x3 = halve(x2)
        x4 = astuple(x3, x1)
        x5 = crop(I, ORIGIN, x4)
        x6 = hmirror(x5)
        O = vconcat(x5, x6)
        return O

    def solve_1f876c06(I):
        x1 = fgpartition(I)
        x2 = compose(last, first)
        x3 = power(last, TWO)
        x4 = fork(connect, x2, x3)
        x5 = fork(recolor, color, x4)
        x6 = mapply(x5, x1)
        O = paint(I, x6)
        return O

    def solve_05f2a901(I):
        x1 = objects(I, T, F, T)
        x2 = colorfilter(x1, TWO)
        x3 = first(x2)
        x4 = colorfilter(x1, EIGHT)
        x5 = first(x4)
        x6 = gravitate(x3, x5)
        O = move(I, x3, x6)
        return O

    def solve_39a8645d(I):
        x1 = objects(I, T, T, T)
        x2 = totuple(x1)
        x3 = apply(color, x2)
        x4 = mostcommon(x3)
        x5 = matcher(color, x4)
        x6 = extract(x1, x5)
        O = subgrid(x6, I)
        return O

    def solve_1b2d62fb(I):
        x1 = lefthalf(I)
        x2 = righthalf(I)
        x3 = ofcolor(x1, ZERO)
        x4 = ofcolor(x2, ZERO)
        x5 = intersection(x3, x4)
        x6 = replace(x1, NINE, ZERO)
        O = fill(x6, EIGHT, x5)
        return O

    def solve_90c28cc7(I):
        x1 = objects(I, F, F, T)
        x2 = first(x1)
        x3 = subgrid(x2, I)
        x4 = dedupe(x3)
        x5 = rot90(x4)
        x6 = dedupe(x5)
        O = rot270(x6)
        return O

    def solve_b6afb2da(I):
        x1 = objects(I, T, F, F)
        x2 = replace(I, FIVE, TWO)
        x3 = colorfilter(x1, FIVE)
        x4 = mapply(box, x3)
        x5 = fill(x2, FOUR, x4)
        x6 = mapply(corners, x3)
        O = fill(x5, ONE, x6)
        return O

    def solve_b9b7f026(I):
        x1 = objects(I, T, F, F)
        x2 = argmin(x1, size)
        x3 = rbind(adjacent, x2)
        x4 = remove(x2, x1)
        x5 = extract(x4, x3)
        x6 = color(x5)
        O = canvas(x6, UNITY)
        return O

    def solve_ba97ae07(I):
        x1 = objects(I, T, F, T)
        x2 = totuple(x1)
        x3 = apply(color, x2)
        x4 = mostcommon(x3)
        x5 = ofcolor(I, x4)
        x6 = backdrop(x5)
        O = fill(I, x4, x6)
        return O

    def solve_c9f8e694(I):
        x1 = height(I)
        x2 = width(I)
        x3 = ofcolor(I, ZERO)
        x4 = astuple(x1, ONE)
        x5 = crop(I, ORIGIN, x4)
        x6 = hupscale(x5, x2)
        O = fill(x6, ZERO, x3)
        return O

    def solve_d23f8c26(I):
        x1 = asindices(I)
        x2 = width(I)
        x3 = halve(x2)
        x4 = matcher(last, x3)
        x5 = compose(flip, x4)
        x6 = sfilter(x1, x5)
        O = fill(I, ZERO, x6)
        return O

    def solve_d5d6de2d(I):
        x1 = objects(I, T, F, T)
        x2 = sfilter(x1, square)
        x3 = difference(x1, x2)
        x4 = compose(backdrop, inbox)
        x5 = mapply(x4, x3)
        x6 = replace(I, TWO, ZERO)
        O = fill(x6, THREE, x5)
        return O

    def solve_dbc1a6ce(I):
        x1 = ofcolor(I, ONE)
        x2 = product(x1, x1)
        x3 = fork(connect, first, last)
        x4 = apply(x3, x2)
        x5 = fork(either, vline, hline)
        x6 = mfilter(x4, x5)
        O = underfill(I, EIGHT, x6)
        return O

    def solve_ded97339(I):
        x1 = ofcolor(I, EIGHT)
        x2 = product(x1, x1)
        x3 = fork(connect, first, last)
        x4 = apply(x3, x2)
        x5 = fork(either, vline, hline)
        x6 = mfilter(x4, x5)
        O = underfill(I, EIGHT, x6)
        return O

    def solve_ea786f4a(I):
        x1 = width(I)
        x2 = shoot(ORIGIN, UNITY)
        x3 = decrement(x1)
        x4 = tojvec(x3)
        x5 = shoot(x4, DOWN_LEFT)
        x6 = combine(x2, x5)
        O = fill(I, ZERO, x6)
        return O

    def solve_08ed6ac7(I):
        x1 = objects(I, T, F, T)
        x2 = totuple(x1)
        x3 = order(x1, height)
        x4 = size(x2)
        x5 = interval(x4, ZERO, NEG_ONE)
        x6 = mpapply(recolor, x5, x3)
        O = paint(I, x6)
        return O

    def solve_40853293(I):
        x1 = partition(I)
        x2 = fork(recolor, color, backdrop)
        x3 = apply(x2, x1)
        x4 = mfilter(x3, hline)
        x5 = mfilter(x3, vline)
        x6 = paint(I, x4)
        O = paint(x6, x5)
        return O

    def solve_5521c0d9(I):
        x1 = objects(I, T, F, T)
        x2 = merge(x1)
        x3 = cover(I, x2)
        x4 = chain(toivec, invert, height)
        x5 = fork(shift, identity, x4)
        x6 = mapply(x5, x1)
        O = paint(x3, x6)
        return O

    def solve_f8ff0b80(I):
        x1 = objects(I, T, T, T)
        x2 = order(x1, size)
        x3 = apply(color, x2)
        x4 = rbind(canvas, UNITY)
        x5 = apply(x4, x3)
        x6 = merge(x5)
        O = hmirror(x6)
        return O

    def solve_85c4e7cd(I):
        x1 = objects(I, T, F, F)
        x2 = compose(invert, size)
        x3 = order(x1, size)
        x4 = order(x1, x2)
        x5 = apply(color, x4)
        x6 = mpapply(recolor, x5, x3)
        O = paint(I, x6)
        return O

    def solve_d2abd087(I):
        x1 = objects(I, T, F, T)
        x2 = matcher(size, SIX)
        x3 = compose(flip, x2)
        x4 = mfilter(x1, x2)
        x5 = mfilter(x1, x3)
        x6 = fill(I, TWO, x4)
        O = fill(x6, ONE, x5)
        return O

    def solve_017c7c7b(I):
        x1 = tophalf(I)
        x2 = bottomhalf(I)
        x3 = equality(x1, x2)
        x4 = crop(I, TWO_BY_ZERO, THREE_BY_THREE)
        x5 = branch(x3, x2, x4)
        x6 = vconcat(I, x5)
        O = replace(x6, ONE, TWO)
        return O

    def solve_363442ee(I):
        x1 = ofcolor(I, ONE)
        x2 = crop(I, ORIGIN, THREE_BY_THREE)
        x3 = asobject(x2)
        x4 = lbind(shift, x3)
        x5 = compose(x4, decrement)
        x6 = mapply(x5, x1)
        O = paint(I, x6)
        return O

    def solve_5168d44c(I):
        x1 = ofcolor(I, THREE)
        x2 = height(x1)
        x3 = equality(x2, ONE)
        x4 = branch(x3, ZERO_BY_TWO, TWO_BY_ZERO)
        x5 = ofcolor(I, TWO)
        x6 = recolor(TWO, x5)
        O = move(I, x6, x4)
        return O

    def solve_e9614598(I):
        x1 = ofcolor(I, ONE)
        x2 = fork(add, first, last)
        x3 = x2(x1)
        x4 = halve(x3)
        x5 = dneighbors(x4)
        x6 = insert(x4, x5)
        O = fill(I, THREE, x6)
        return O

    def solve_d9fac9be(I):
        x1 = palette(I)
        x2 = objects(I, T, F, T)
        x3 = argmax(x2, size)
        x4 = color(x3)
        x5 = remove(ZERO, x1)
        x6 = other(x5, x4)
        O = canvas(x6, UNITY)
        return O

    def solve_e50d258f(I):
        x1 = width(I)
        x2 = astuple(NINE, x1)
        x3 = canvas(ZERO, x2)
        x4 = vconcat(I, x3)
        x5 = objects(x4, F, F, T)
        x6 = rbind(colorcount, TWO)
        x7 = argmax(x5, x6)
        O = subgrid(x7, I)
        return O

    def solve_810b9b61(I):
        x1 = objects(I, T, T, T)
        x2 = apply(toindices, x1)
        x3 = fork(either, vline, hline)
        x4 = sfilter(x2, x3)
        x5 = difference(x2, x4)
        x6 = fork(equality, identity, box)
        x7 = mfilter(x5, x6)
        O = fill(I, THREE, x7)
        return O

    def solve_54d82841(I):
        x1 = height(I)
        x2 = objects(I, T, F, T)
        x3 = compose(last, center)
        x4 = apply(x3, x2)
        x5 = decrement(x1)
        x6 = lbind(astuple, x5)
        x7 = apply(x6, x4)
        O = fill(I, FOUR, x7)
        return O

    def solve_60b61512(I):
        x1 = objects(I, T, T, T)
        x2 = mapply(delta, x1)
        O = fill(I, SEVEN, x2)
        return O

    def solve_25d8a9c8(I):
        x1 = asindices(I)
        x2 = objects(I, T, F, F)
        x3 = sizefilter(x2, THREE)
        x4 = mfilter(x3, hline)
        x5 = toindices(x4)
        x6 = difference(x1, x5)
        x7 = fill(I, FIVE, x5)
        O = fill(x7, ZERO, x6)
        return O

    def solve_239be575(I):
        x1 = objects(I, F, T, T)
        x2 = lbind(contained, TWO)
        x3 = compose(x2, palette)
        x4 = sfilter(x1, x3)
        x5 = size(x4)
        x6 = greater(x5, ONE)
        x7 = branch(x6, ZERO, EIGHT)
        O = canvas(x7, UNITY)
        return O

    def solve_67a423a3(I):
        x1 = leastcolor(I)
        x2 = objects(I, T, F, T)
        x3 = colorfilter(x2, x1)
        x4 = merge(x3)
        x5 = delta(x4)
        x6 = first(x5)
        x7 = neighbors(x6)
        O = fill(I, FOUR, x7)
        return O

    def solve_5c0a986e(I):
        x1 = ofcolor(I, TWO)
        x2 = ofcolor(I, ONE)
        x3 = lrcorner(x1)
        x4 = ulcorner(x2)
        x5 = shoot(x3, UNITY)
        x6 = shoot(x4, NEG_UNITY)
        x7 = fill(I, TWO, x5)
        O = fill(x7, ONE, x6)
        return O

    def solve_6430c8c4(I):
        x1 = tophalf(I)
        x2 = bottomhalf(I)
        x3 = astuple(FOUR, FOUR)
        x4 = ofcolor(x1, ZERO)
        x5 = ofcolor(x2, ZERO)
        x6 = intersection(x4, x5)
        x7 = canvas(ZERO, x3)
        O = fill(x7, THREE, x6)
        return O

    def solve_94f9d214(I):
        x1 = tophalf(I)
        x2 = bottomhalf(I)
        x3 = ofcolor(x1, ZERO)
        x4 = ofcolor(x2, ZERO)
        x5 = astuple(FOUR, FOUR)
        x6 = canvas(ZERO, x5)
        x7 = intersection(x3, x4)
        O = fill(x6, TWO, x7)
        return O

    def solve_a1570a43(I):
        x1 = ofcolor(I, TWO)
        x2 = ofcolor(I, THREE)
        x3 = recolor(TWO, x1)
        x4 = ulcorner(x2)
        x5 = ulcorner(x1)
        x6 = subtract(x4, x5)
        x7 = increment(x6)
        O = move(I, x3, x7)
        return O

    def solve_ce4f8723(I):
        x1 = tophalf(I)
        x2 = bottomhalf(I)
        x3 = ofcolor(x1, ZERO)
        x4 = ofcolor(x2, ZERO)
        x5 = intersection(x3, x4)
        x6 = astuple(FOUR, FOUR)
        x7 = canvas(THREE, x6)
        O = fill(x7, ZERO, x5)
        return O

    def solve_d13f3404(I):
        x1 = objects(I, T, F, T)
        x2 = rbind(shoot, UNITY)
        x3 = compose(x2, center)
        x4 = fork(recolor, color, x3)
        x5 = mapply(x4, x1)
        x6 = astuple(SIX, SIX)
        x7 = canvas(ZERO, x6)
        O = paint(x7, x5)
        return O

    def solve_dc433765(I):
        x1 = ofcolor(I, THREE)
        x2 = ofcolor(I, FOUR)
        x3 = first(x1)
        x4 = first(x2)
        x5 = subtract(x4, x3)
        x6 = sign(x5)
        x7 = recolor(THREE, x1)
        O = move(I, x7, x6)
        return O

    def solve_f2829549(I):
        x1 = lefthalf(I)
        x2 = righthalf(I)
        x3 = ofcolor(x1, ZERO)
        x4 = ofcolor(x2, ZERO)
        x5 = intersection(x3, x4)
        x6 = shape(x1)
        x7 = canvas(ZERO, x6)
        O = fill(x7, THREE, x5)
        return O

    def solve_fafffa47(I):
        x1 = tophalf(I)
        x2 = bottomhalf(I)
        x3 = shape(x2)
        x4 = ofcolor(x1, ZERO)
        x5 = ofcolor(x2, ZERO)
        x6 = intersection(x4, x5)
        x7 = canvas(ZERO, x3)
        O = fill(x7, TWO, x6)
        return O

    def solve_fcb5c309(I):
        x1 = leastcolor(I)
        x2 = objects(I, T, F, T)
        x3 = colorfilter(x2, x1)
        x4 = difference(x2, x3)
        x5 = argmax(x4, size)
        x6 = color(x5)
        x7 = subgrid(x5, I)
        O = replace(x7, x6, x1)
        return O

    def solve_ff805c23(I):
        x1 = hmirror(I)
        x2 = vmirror(I)
        x3 = ofcolor(I, ONE)
        x4 = subgrid(x3, x1)
        x5 = subgrid(x3, x2)
        x6 = palette(x4)
        x7 = contained(ONE, x6)
        O = branch(x7, x5, x4)
        return O

    def solve_e76a88a6(I):
        x1 = objects(I, F, F, T)
        x2 = argmax(x1, numcolors)
        x3 = normalize(x2)
        x4 = remove(x2, x1)
        x5 = apply(ulcorner, x4)
        x6 = lbind(shift, x3)
        x7 = mapply(x6, x5)
        O = paint(I, x7)
        return O

    def solve_7c008303(I):
        x1 = ofcolor(I, THREE)
        x2 = subgrid(x1, I)
        x3 = ofcolor(x2, ZERO)
        x4 = replace(I, THREE, ZERO)
        x5 = replace(x4, EIGHT, ZERO)
        x6 = compress(x5)
        x7 = upscale(x6, THREE)
        O = fill(x7, ZERO, x3)
        return O

    def solve_7f4411dc(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        x3 = rbind(difference, x2)
        x4 = rbind(greater, TWO)
        x5 = chain(x4, size, x3)
        x6 = compose(x5, dneighbors)
        x7 = sfilter(x2, x6)
        O = fill(I, ZERO, x7)
        return O

    def solve_b230c067(I):
        x1 = objects(I, T, T, T)
        x2 = totuple(x1)
        x3 = apply(normalize, x2)
        x4 = leastcommon(x3)
        x5 = matcher(normalize, x4)
        x6 = extract(x1, x5)
        x7 = replace(I, EIGHT, ONE)
        O = fill(x7, TWO, x6)
        return O

    def solve_e8593010(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = sizefilter(x1, TWO)
        x4 = merge(x2)
        x5 = fill(I, THREE, x4)
        x6 = merge(x3)
        x7 = fill(x5, TWO, x6)
        O = replace(x7, ZERO, ONE)
        return O

    def solve_6d75e8bb(I):
        x1 = objects(I, T, F, T)
        x2 = first(x1)
        x3 = ulcorner(x2)
        x4 = subgrid(x2, I)
        x5 = replace(x4, ZERO, TWO)
        x6 = asobject(x5)
        x7 = shift(x6, x3)
        O = paint(I, x7)
        return O

    def solve_3f7978a0(I):
        x1 = fgpartition(I)
        x2 = matcher(color, FIVE)
        x3 = extract(x1, x2)
        x4 = ulcorner(x3)
        x5 = subtract(x4, DOWN)
        x6 = shape(x3)
        x7 = add(x6, TWO_BY_ZERO)
        O = crop(I, x5, x7)
        return O

    def solve_1190e5a7(I):
        x1 = mostcolor(I)
        x2 = frontiers(I)
        x3 = sfilter(x2, vline)
        x4 = difference(x2, x3)
        x5 = astuple(x4, x3)
        x6 = apply(size, x5)
        x7 = increment(x6)
        O = canvas(x1, x7)
        return O

    def solve_6e02f1e3(I):
        x1 = numcolors(I)
        x2 = canvas(ZERO, THREE_BY_THREE)
        x3 = equality(x1, THREE)
        x4 = equality(x1, TWO)
        x5 = branch(x3, TWO_BY_ZERO, ORIGIN)
        x6 = branch(x4, TWO_BY_TWO, ZERO_BY_TWO)
        x7 = connect(x5, x6)
        O = fill(x2, FIVE, x7)
        return O

    def solve_a61f2674(I):
        x1 = objects(I, T, F, T)
        x2 = argmax(x1, size)
        x3 = argmin(x1, size)
        x4 = replace(I, FIVE, ZERO)
        x5 = recolor(ONE, x2)
        x6 = recolor(TWO, x3)
        x7 = combine(x5, x6)
        O = paint(x4, x7)
        return O

    def solve_fcc82909(I):
        x1 = objects(I, F, T, T)
        x2 = rbind(add, DOWN)
        x3 = compose(x2, llcorner)
        x4 = compose(toivec, numcolors)
        x5 = fork(add, lrcorner, x4)
        x6 = fork(astuple, x3, x5)
        x7 = compose(box, x6)
        x8 = mapply(x7, x1)
        O = fill(I, THREE, x8)
        return O

    def solve_72ca375d(I):
        x1 = objects(I, T, T, T)
        x2 = totuple(x1)
        x3 = rbind(subgrid, I)
        x4 = apply(x3, x2)
        x5 = apply(vmirror, x4)
        x6 = papply(equality, x4, x5)
        x7 = pair(x4, x6)
        x8 = extract(x7, last)
        O = first(x8)
        return O

    def solve_253bf280(I):
        x1 = ofcolor(I, EIGHT)
        x2 = prapply(connect, x1, x1)
        x3 = rbind(greater, ONE)
        x4 = compose(x3, size)
        x5 = sfilter(x2, x4)
        x6 = fork(either, vline, hline)
        x7 = mfilter(x5, x6)
        x8 = fill(I, THREE, x7)
        O = fill(x8, EIGHT, x1)
        return O

    def solve_694f12f3(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, FOUR)
        x3 = compose(backdrop, inbox)
        x4 = argmin(x2, size)
        x5 = argmax(x2, size)
        x6 = x3(x4)
        x7 = x3(x5)
        x8 = fill(I, ONE, x6)
        O = fill(x8, TWO, x7)
        return O

    def solve_1f642eb9(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = difference(x1, x2)
        x4 = first(x3)
        x5 = rbind(gravitate, x4)
        x6 = compose(crement, x5)
        x7 = fork(shift, identity, x6)
        x8 = mapply(x7, x2)
        O = paint(I, x8)
        return O

    def solve_31aa019c(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        x3 = first(x2)
        x4 = neighbors(x3)
        x5 = astuple(TEN, TEN)
        x6 = canvas(ZERO, x5)
        x7 = initset(x3)
        x8 = fill(x6, x1, x7)
        O = fill(x8, TWO, x4)
        return O

    def solve_27a28665(I):
        x1 = objects(I, T, F, F)
        x2 = valmax(x1, size)
        x3 = equality(x2, ONE)
        x4 = equality(x2, FOUR)
        x5 = equality(x2, FIVE)
        x6 = branch(x3, TWO, ONE)
        x7 = branch(x4, THREE, x6)
        x8 = branch(x5, SIX, x7)
        O = canvas(x8, UNITY)
        return O

    def solve_7ddcd7ec(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = difference(x1, x2)
        x4 = first(x3)
        x5 = color(x4)
        x6 = lbind(position, x4)
        x7 = fork(shoot, center, x6)
        x8 = mapply(x7, x2)
        O = fill(I, x5, x8)
        return O

    def solve_3bd67248(I):
        x1 = height(I)
        x2 = decrement(x1)
        x3 = decrement(x2)
        x4 = astuple(x3, ONE)
        x5 = astuple(x2, ONE)
        x6 = shoot(x4, UP_RIGHT)
        x7 = shoot(x5, RIGHT)
        x8 = fill(I, TWO, x6)
        O = fill(x8, FOUR, x7)
        return O

    def solve_73251a56(I):
        x1 = dmirror(I)
        x2 = papply(pair, I, x1)
        x3 = lbind(apply, maximum)
        x4 = apply(x3, x2)
        x5 = mostcolor(x4)
        x6 = replace(x4, ZERO, x5)
        x7 = index(x6, ORIGIN)
        x8 = shoot(ORIGIN, UNITY)
        O = fill(x6, x7, x8)
        return O

    def solve_25d487eb(I):
        x1 = leastcolor(I)
        x2 = objects(I, T, F, T)
        x3 = ofcolor(I, x1)
        x4 = center(x3)
        x5 = merge(x2)
        x6 = center(x5)
        x7 = subtract(x6, x4)
        x8 = shoot(x4, x7)
        O = underfill(I, x1, x8)
        return O

    def solve_8f2ea7aa(I):
        x1 = objects(I, T, F, T)
        x2 = merge(x1)
        x3 = subgrid(x2, I)
        x4 = upscale(x3, THREE)
        x5 = hconcat(x3, x3)
        x6 = hconcat(x5, x3)
        x7 = vconcat(x6, x6)
        x8 = vconcat(x7, x6)
        O = cellwise(x4, x8, ZERO)
        return O

    def solve_b8825c91(I):
        x1 = replace(I, FOUR, ZERO)
        x2 = dmirror(x1)
        x3 = papply(pair, x1, x2)
        x4 = lbind(apply, maximum)
        x5 = apply(x4, x3)
        x6 = cmirror(x5)
        x7 = papply(pair, x5, x6)
        x8 = apply(x4, x7)
        O = cmirror(x8)
        return O

    def solve_cce03e0d(I):
        x1 = upscale(I, THREE)
        x2 = hconcat(I, I)
        x3 = hconcat(x2, I)
        x4 = vconcat(x3, x3)
        x5 = vconcat(x4, x3)
        x6 = ofcolor(x1, ZERO)
        x7 = ofcolor(x1, ONE)
        x8 = combine(x6, x7)
        O = fill(x5, ZERO, x8)
        return O

    def solve_d364b489(I):
        x1 = ofcolor(I, ONE)
        x2 = shift(x1, DOWN)
        x3 = fill(I, EIGHT, x2)
        x4 = shift(x1, UP)
        x5 = fill(x3, TWO, x4)
        x6 = shift(x1, RIGHT)
        x7 = fill(x5, SIX, x6)
        x8 = shift(x1, LEFT)
        O = fill(x7, SEVEN, x8)
        return O

    def solve_a5f85a15(I):
        x1 = objects(I, T, T, T)
        x2 = interval(ONE, NINE, ONE)
        x3 = apply(double, x2)
        x4 = apply(decrement, x3)
        x5 = papply(astuple, x4, x4)
        x6 = apply(ulcorner, x1)
        x7 = lbind(shift, x5)
        x8 = mapply(x7, x6)
        O = fill(I, FOUR, x8)
        return O

    def solve_3ac3eb23(I):
        x1 = objects(I, T, F, T)
        x2 = chain(ineighbors, last, first)
        x3 = fork(recolor, color, x2)
        x4 = mapply(x3, x1)
        x5 = paint(I, x4)
        x6 = vsplit(x5, THREE)
        x7 = first(x6)
        x8 = vconcat(x7, x7)
        O = vconcat(x7, x8)
        return O

    def solve_444801d8(I):
        x1 = objects(I, T, F, T)
        x2 = colorfilter(x1, ONE)
        x3 = rbind(toobject, I)
        x4 = chain(leastcolor, x3, delta)
        x5 = rbind(shift, UP)
        x6 = compose(x5, backdrop)
        x7 = fork(recolor, x4, x6)
        x8 = mapply(x7, x2)
        O = underpaint(I, x8)
        return O

    def solve_22168020(I):
        x1 = palette(I)
        x2 = remove(ZERO, x1)
        x3 = lbind(ofcolor, I)
        x4 = lbind(prapply, connect)
        x5 = fork(x4, x3, x3)
        x6 = compose(merge, x5)
        x7 = fork(recolor, identity, x6)
        x8 = mapply(x7, x2)
        O = paint(I, x8)
        return O

    def solve_6e82a1ae(I):
        x1 = objects(I, T, F, T)
        x2 = lbind(sizefilter, x1)
        x3 = compose(merge, x2)
        x4 = x3(TWO)
        x5 = x3(THREE)
        x6 = x3(FOUR)
        x7 = fill(I, THREE, x4)
        x8 = fill(x7, TWO, x5)
        O = fill(x8, ONE, x6)
        return O

    def solve_b2862040(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, NINE)
        x3 = colorfilter(x1, ONE)
        x4 = rbind(bordering, I)
        x5 = compose(flip, x4)
        x6 = mfilter(x2, x5)
        x7 = rbind(adjacent, x6)
        x8 = mfilter(x3, x7)
        O = fill(I, EIGHT, x8)
        return O

    def solve_868de0fa(I):
        x1 = objects(I, T, F, F)
        x2 = sfilter(x1, square)
        x3 = compose(even, height)
        x4 = sfilter(x2, x3)
        x5 = difference(x2, x4)
        x6 = merge(x4)
        x7 = merge(x5)
        x8 = fill(I, TWO, x6)
        O = fill(x8, SEVEN, x7)
        return O

    def solve_681b3aeb(I):
        x1 = rot270(I)
        x2 = objects(x1, T, F, T)
        x3 = argmax(x2, size)
        x4 = argmin(x2, size)
        x5 = color(x4)
        x6 = canvas(x5, THREE_BY_THREE)
        x7 = normalize(x3)
        x8 = paint(x6, x7)
        O = rot90(x8)
        return O

    def solve_8e5a5113(I):
        x1 = crop(I, ORIGIN, THREE_BY_THREE)
        x2 = rot90(x1)
        x3 = rot180(x1)
        x4 = astuple(x2, x3)
        x5 = astuple(FOUR, EIGHT)
        x6 = apply(tojvec, x5)
        x7 = apply(asobject, x4)
        x8 = mpapply(shift, x7, x6)
        O = paint(I, x8)
        return O

    def solve_025d127b(I):
        x1 = objects(I, T, F, T)
        x2 = apply(color, x1)
        x3 = merge(x1)
        x4 = lbind(colorfilter, x1)
        x5 = rbind(argmax, rightmost)
        x6 = compose(x5, x4)
        x7 = mapply(x6, x2)
        x8 = difference(x3, x7)
        O = move(I, x8, RIGHT)
        return O

    def solve_2281f1f4(I):
        x1 = ofcolor(I, FIVE)
        x2 = product(x1, x1)
        x3 = power(first, TWO)
        x4 = power(last, TWO)
        x5 = fork(astuple, x3, x4)
        x6 = apply(x5, x2)
        x7 = urcorner(x1)
        x8 = remove(x7, x6)
        O = underfill(I, TWO, x8)
        return O

    def solve_cf98881b(I):
        x1 = hsplit(I, THREE)
        x2 = first(x1)
        x3 = remove(x2, x1)
        x4 = first(x3)
        x5 = last(x3)
        x6 = ofcolor(x4, NINE)
        x7 = ofcolor(x2, FOUR)
        x8 = fill(x5, NINE, x6)
        O = fill(x8, FOUR, x7)
        return O

    def solve_d4f3cd78(I):
        x1 = ofcolor(I, FIVE)
        x2 = delta(x1)
        x3 = fill(I, EIGHT, x2)
        x4 = box(x1)
        x5 = difference(x4, x1)
        x6 = position(x4, x5)
        x7 = first(x5)
        x8 = shoot(x7, x6)
        O = fill(x3, EIGHT, x8)
        return O

    def solve_bda2d7a6(I):
        x1 = partition(I)
        x2 = order(x1, size)
        x3 = apply(color, x2)
        x4 = last(x2)
        x5 = remove(x4, x2)
        x6 = repeat(x4, ONE)
        x7 = combine(x6, x5)
        x8 = mpapply(recolor, x3, x7)
        O = paint(I, x8)
        return O

    def solve_137eaa0f(I):
        x1 = objects(I, F, T, T)
        x2 = matcher(first, FIVE)
        x3 = rbind(sfilter, x2)
        x4 = chain(invert, center, x3)
        x5 = fork(shift, identity, x4)
        x6 = canvas(ZERO, THREE_BY_THREE)
        x7 = mapply(x5, x1)
        x8 = shift(x7, UNITY)
        O = paint(x6, x8)
        return O

    def solve_6455b5f5(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = argmax(x1, size)
        x4 = valmin(x1, size)
        x5 = sizefilter(x2, x4)
        x6 = recolor(ONE, x3)
        x7 = merge(x5)
        x8 = paint(I, x6)
        O = fill(x8, EIGHT, x7)
        return O

    def solve_b8cdaf2b(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        x3 = shift(x2, UP)
        x4 = ulcorner(x3)
        x5 = urcorner(x3)
        x6 = shoot(x4, NEG_UNITY)
        x7 = shoot(x5, UP_RIGHT)
        x8 = combine(x6, x7)
        O = underfill(I, x1, x8)
        return O

    def solve_bd4472b8(I):
        x1 = width(I)
        x2 = astuple(TWO, x1)
        x3 = crop(I, ORIGIN, x2)
        x4 = tophalf(x3)
        x5 = dmirror(x4)
        x6 = hupscale(x5, x1)
        x7 = repeat(x6, TWO)
        x8 = merge(x7)
        O = vconcat(x3, x8)
        return O

    def solve_4be741c5(I):
        x1 = portrait(I)
        x2 = branch(x1, dmirror, identity)
        x3 = branch(x1, height, width)
        x4 = x3(I)
        x5 = astuple(ONE, x4)
        x6 = x2(I)
        x7 = crop(x6, ORIGIN, x5)
        x8 = apply(dedupe, x7)
        O = x2(x8)
        return O

    def solve_bbc9ae5d(I):
        x1 = width(I)
        x2 = palette(I)
        x3 = halve(x1)
        x4 = vupscale(I, x3)
        x5 = rbind(shoot, UNITY)
        x6 = other(x2, ZERO)
        x7 = ofcolor(x4, x6)
        x8 = mapply(x5, x7)
        O = fill(x4, x6, x8)
        return O

    def solve_d90796e8(I):
        x1 = objects(I, F, F, T)
        x2 = sizefilter(x1, TWO)
        x3 = lbind(contained, TWO)
        x4 = compose(x3, palette)
        x5 = mfilter(x2, x4)
        x6 = cover(I, x5)
        x7 = matcher(first, THREE)
        x8 = sfilter(x5, x7)
        O = fill(x6, EIGHT, x8)
        return O

    def solve_2c608aff(I):
        x1 = leastcolor(I)
        x2 = objects(I, T, F, T)
        x3 = argmax(x2, size)
        x4 = toindices(x3)
        x5 = ofcolor(I, x1)
        x6 = prapply(connect, x4, x5)
        x7 = fork(either, vline, hline)
        x8 = mfilter(x6, x7)
        O = underfill(I, x1, x8)
        return O

    def solve_f8b3ba0a(I):
        x1 = compress(I)
        x2 = astuple(THREE, ONE)
        x3 = palette(x1)
        x4 = lbind(colorcount, x1)
        x5 = compose(invert, x4)
        x6 = order(x3, x5)
        x7 = rbind(canvas, UNITY)
        x8 = apply(x7, x6)
        x9 = merge(x8)
        O = crop(x9, DOWN, x2)
        return O

    def solve_80af3007(I):
        x1 = objects(I, T, T, T)
        x2 = first(x1)
        x3 = subgrid(x2, I)
        x4 = upscale(x3, THREE)
        x5 = hconcat(x3, x3)
        x6 = hconcat(x5, x3)
        x7 = vconcat(x6, x6)
        x8 = vconcat(x7, x6)
        x9 = cellwise(x4, x8, ZERO)
        O = downscale(x9, THREE)
        return O

    def solve_83302e8f(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = sfilter(x2, square)
        x4 = difference(x2, x3)
        x5 = merge(x3)
        x6 = recolor(THREE, x5)
        x7 = merge(x4)
        x8 = recolor(FOUR, x7)
        x9 = paint(I, x6)
        O = paint(x9, x8)
        return O

    def solve_1fad071e(I):
        x1 = objects(I, T, F, T)
        x2 = colorfilter(x1, ONE)
        x3 = sizefilter(x2, FOUR)
        x4 = size(x3)
        x5 = subtract(FIVE, x4)
        x6 = astuple(ONE, x4)
        x7 = canvas(ONE, x6)
        x8 = astuple(ONE, x5)
        x9 = canvas(ZERO, x8)
        O = hconcat(x7, x9)
        return O

    def solve_11852cab(I):
        x1 = objects(I, T, T, T)
        x2 = merge(x1)
        x3 = hmirror(x2)
        x4 = vmirror(x2)
        x5 = dmirror(x2)
        x6 = cmirror(x2)
        x7 = paint(I, x3)
        x8 = paint(x7, x4)
        x9 = paint(x8, x5)
        O = paint(x9, x6)
        return O

    def solve_3428a4f5(I):
        x1 = tophalf(I)
        x2 = bottomhalf(I)
        x3 = astuple(SIX, FIVE)
        x4 = ofcolor(x1, TWO)
        x5 = ofcolor(x2, TWO)
        x6 = combine(x4, x5)
        x7 = intersection(x4, x5)
        x8 = difference(x6, x7)
        x9 = canvas(ZERO, x3)
        O = fill(x9, THREE, x8)
        return O

    def solve_178fcbfb(I):
        x1 = objects(I, T, F, T)
        x2 = ofcolor(I, TWO)
        x3 = mapply(vfrontier, x2)
        x4 = fill(I, TWO, x3)
        x5 = colorfilter(x1, TWO)
        x6 = difference(x1, x5)
        x7 = compose(hfrontier, center)
        x8 = fork(recolor, color, x7)
        x9 = mapply(x8, x6)
        O = paint(x4, x9)
        return O

    def solve_3de23699(I):
        x1 = fgpartition(I)
        x2 = sizefilter(x1, FOUR)
        x3 = first(x2)
        x4 = difference(x1, x2)
        x5 = first(x4)
        x6 = color(x3)
        x7 = color(x5)
        x8 = subgrid(x3, I)
        x9 = trim(x8)
        O = replace(x9, x7, x6)
        return O

    def solve_54d9e175(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = compose(neighbors, center)
        x4 = fork(recolor, color, x3)
        x5 = mapply(x4, x2)
        x6 = paint(I, x5)
        x7 = replace(x6, ONE, SIX)
        x8 = replace(x7, TWO, SEVEN)
        x9 = replace(x8, THREE, EIGHT)
        O = replace(x9, FOUR, NINE)
        return O

    def solve_5ad4f10b(I):
        x1 = objects(I, T, T, T)
        x2 = argmax(x1, size)
        x3 = color(x2)
        x4 = subgrid(x2, I)
        x5 = leastcolor(x4)
        x6 = replace(x4, x5, ZERO)
        x7 = replace(x6, x3, x5)
        x8 = height(x7)
        x9 = divide(x8, THREE)
        O = downscale(x7, x9)
        return O

    def solve_623ea044(I):
        x1 = objects(I, T, F, T)
        x2 = first(x1)
        x3 = center(x2)
        x4 = color(x2)
        x5 = astuple(UNITY, NEG_UNITY)
        x6 = astuple(UP_RIGHT, DOWN_LEFT)
        x7 = combine(x5, x6)
        x8 = lbind(shoot, x3)
        x9 = mapply(x8, x7)
        O = fill(I, x4, x9)
        return O

    def solve_6b9890af(I):
        x1 = objects(I, T, T, T)
        x2 = ofcolor(I, TWO)
        x3 = argmin(x1, size)
        x4 = subgrid(x2, I)
        x5 = width(x4)
        x6 = divide(x5, THREE)
        x7 = upscale(x3, x6)
        x8 = normalize(x7)
        x9 = shift(x8, UNITY)
        O = paint(x4, x9)
        return O

    def solve_794b24be(I):
        x1 = ofcolor(I, ONE)
        x2 = size(x1)
        x3 = decrement(x2)
        x4 = canvas(ZERO, THREE_BY_THREE)
        x5 = tojvec(x3)
        x6 = connect(ORIGIN, x5)
        x7 = equality(x2, FOUR)
        x8 = insert(UNITY, x6)
        x9 = branch(x7, x8, x6)
        O = fill(x4, TWO, x9)
        return O

    def solve_88a10436(I):
        x1 = objects(I, F, F, T)
        x2 = colorfilter(x1, FIVE)
        x3 = first(x2)
        x4 = center(x3)
        x5 = difference(x1, x2)
        x6 = first(x5)
        x7 = normalize(x6)
        x8 = shift(x7, x4)
        x9 = shift(x8, NEG_UNITY)
        O = paint(I, x9)
        return O

    def solve_88a62173(I):
        x1 = lefthalf(I)
        x2 = righthalf(I)
        x3 = tophalf(x1)
        x4 = tophalf(x2)
        x5 = bottomhalf(x1)
        x6 = bottomhalf(x2)
        x7 = astuple(x3, x4)
        x8 = astuple(x5, x6)
        x9 = combine(x7, x8)
        O = leastcommon(x9)
        return O

    def solve_890034e9(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        x3 = inbox(x2)
        x4 = recolor(ZERO, x3)
        x5 = occurrences(I, x4)
        x6 = normalize(x2)
        x7 = shift(x6, NEG_UNITY)
        x8 = lbind(shift, x7)
        x9 = mapply(x8, x5)
        O = fill(I, x1, x9)
        return O

    def solve_99b1bc43(I):
        x1 = tophalf(I)
        x2 = bottomhalf(I)
        x3 = ofcolor(x1, ZERO)
        x4 = ofcolor(x2, ZERO)
        x5 = combine(x3, x4)
        x6 = intersection(x3, x4)
        x7 = difference(x5, x6)
        x8 = shape(x1)
        x9 = canvas(ZERO, x8)
        O = fill(x9, THREE, x7)
        return O

    def solve_a9f96cdd(I):
        x1 = ofcolor(I, TWO)
        x2 = replace(I, TWO, ZERO)
        x3 = shift(x1, NEG_UNITY)
        x4 = fill(x2, THREE, x3)
        x5 = shift(x1, UP_RIGHT)
        x6 = fill(x4, SIX, x5)
        x7 = shift(x1, DOWN_LEFT)
        x8 = fill(x6, EIGHT, x7)
        x9 = shift(x1, UNITY)
        O = fill(x8, SEVEN, x9)
        return O

    def solve_af902bf9(I):
        x1 = ofcolor(I, FOUR)
        x2 = prapply(connect, x1, x1)
        x3 = fork(either, vline, hline)
        x4 = mfilter(x2, x3)
        x5 = underfill(I, NEG_ONE, x4)
        x6 = objects(x5, F, F, T)
        x7 = compose(backdrop, inbox)
        x8 = mapply(x7, x6)
        x9 = fill(x5, TWO, x8)
        O = replace(x9, NEG_ONE, ZERO)
        return O

    def solve_b548a754(I):
        x1 = objects(I, T, F, T)
        x2 = replace(I, EIGHT, ZERO)
        x3 = leastcolor(x2)
        x4 = replace(x2, x3, ZERO)
        x5 = leastcolor(x4)
        x6 = merge(x1)
        x7 = backdrop(x6)
        x8 = box(x6)
        x9 = fill(I, x3, x7)
        O = fill(x9, x5, x8)
        return O

    def solve_bdad9b1f(I):
        x1 = ofcolor(I, TWO)
        x2 = ofcolor(I, EIGHT)
        x3 = center(x1)
        x4 = center(x2)
        x5 = hfrontier(x3)
        x6 = vfrontier(x4)
        x7 = intersection(x5, x6)
        x8 = fill(I, TWO, x5)
        x9 = fill(x8, EIGHT, x6)
        O = fill(x9, FOUR, x7)
        return O

    def solve_c3e719e8(I):
        x1 = mostcolor(I)
        x2 = hconcat(I, I)
        x3 = upscale(I, THREE)
        x4 = ofcolor(x3, x1)
        x5 = asindices(x3)
        x6 = difference(x5, x4)
        x7 = hconcat(x2, I)
        x8 = vconcat(x7, x7)
        x9 = vconcat(x8, x7)
        O = fill(x9, ZERO, x6)
        return O

    def solve_de1cd16c(I):
        x1 = leastcolor(I)
        x2 = objects(I, T, F, F)
        x3 = sizefilter(x2, ONE)
        x4 = difference(x2, x3)
        x5 = rbind(subgrid, I)
        x6 = apply(x5, x4)
        x7 = rbind(colorcount, x1)
        x8 = argmax(x6, x7)
        x9 = mostcolor(x8)
        O = canvas(x9, UNITY)
        return O

    def solve_d8c310e9(I):
        x1 = objects(I, F, F, T)
        x2 = first(x1)
        x3 = hperiod(x2)
        x4 = multiply(x3, THREE)
        x5 = tojvec(x3)
        x6 = tojvec(x4)
        x7 = shift(x2, x5)
        x8 = shift(x2, x6)
        x9 = paint(I, x7)
        O = paint(x9, x8)
        return O

    def solve_a3325580(I):
        x1 = objects(I, T, F, T)
        x2 = valmax(x1, size)
        x3 = sizefilter(x1, x2)
        x4 = order(x3, leftmost)
        x5 = apply(color, x4)
        x6 = astuple(ONE, x2)
        x7 = rbind(canvas, x6)
        x8 = apply(x7, x5)
        x9 = merge(x8)
        O = dmirror(x9)
        return O

    def solve_8eb1be9a(I):
        x1 = objects(I, T, T, T)
        x2 = first(x1)
        x3 = interval(NEG_TWO, FOUR, ONE)
        x4 = lbind(shift, x2)
        x5 = height(x2)
        x6 = rbind(multiply, x5)
        x7 = apply(x6, x3)
        x8 = apply(toivec, x7)
        x9 = mapply(x4, x8)
        O = paint(I, x9)
        return O

    def solve_321b1fc6(I):
        x1 = objects(I, F, F, T)
        x2 = colorfilter(x1, EIGHT)
        x3 = difference(x1, x2)
        x4 = first(x3)
        x5 = cover(I, x4)
        x6 = normalize(x4)
        x7 = lbind(shift, x6)
        x8 = apply(ulcorner, x2)
        x9 = mapply(x7, x8)
        O = paint(x5, x9)
        return O

    def solve_1caeab9d(I):
        x1 = objects(I, T, T, T)
        x2 = ofcolor(I, ONE)
        x3 = lowermost(x2)
        x4 = lbind(subtract, x3)
        x5 = chain(toivec, x4, lowermost)
        x6 = fork(shift, identity, x5)
        x7 = merge(x1)
        x8 = cover(I, x7)
        x9 = mapply(x6, x1)
        O = paint(x8, x9)
        return O

    def solve_77fdfe62(I):
        x1 = ofcolor(I, EIGHT)
        x2 = subgrid(x1, I)
        x3 = replace(I, EIGHT, ZERO)
        x4 = replace(x3, ONE, ZERO)
        x5 = compress(x4)
        x6 = width(x2)
        x7 = halve(x6)
        x8 = upscale(x5, x7)
        x9 = ofcolor(x2, ZERO)
        O = fill(x8, ZERO, x9)
        return O

    def solve_c0f76784(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = sfilter(x2, square)
        x4 = sizefilter(x3, ONE)
        x5 = merge(x4)
        x6 = argmax(x3, size)
        x7 = merge(x3)
        x8 = fill(I, SEVEN, x7)
        x9 = fill(x8, EIGHT, x6)
        O = fill(x9, SIX, x5)
        return O

    def solve_1b60fb0c(I):
        x1 = rot90(I)
        x2 = ofcolor(I, ONE)
        x3 = ofcolor(x1, ONE)
        x4 = neighbors(ORIGIN)
        x5 = mapply(neighbors, x4)
        x6 = lbind(shift, x3)
        x7 = apply(x6, x5)
        x8 = lbind(intersection, x2)
        x9 = compose(size, x8)
        x10 = argmax(x7, x9)
        O = underfill(I, TWO, x10)
        return O

    def solve_ddf7fa4f(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = colorfilter(x1, FIVE)
        x4 = product(x2, x3)
        x5 = fork(vmatching, first, last)
        x6 = sfilter(x4, x5)
        x7 = compose(color, first)
        x8 = fork(recolor, x7, last)
        x9 = mapply(x8, x6)
        O = paint(I, x9)
        return O

    def solve_47c1f68c(I):
        x1 = leastcolor(I)
        x2 = vmirror(I)
        x3 = objects(I, T, T, T)
        x4 = merge(x3)
        x5 = mostcolor(x4)
        x6 = cellwise(I, x2, x1)
        x7 = hmirror(x6)
        x8 = cellwise(x6, x7, x1)
        x9 = compress(x8)
        O = replace(x9, x1, x5)
        return O

    def solve_6c434453(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, EIGHT)
        x3 = dneighbors(UNITY)
        x4 = insert(UNITY, x3)
        x5 = merge(x2)
        x6 = cover(I, x5)
        x7 = apply(ulcorner, x2)
        x8 = lbind(shift, x4)
        x9 = mapply(x8, x7)
        O = fill(x6, TWO, x9)
        return O

    def solve_23581191(I):
        x1 = objects(I, T, T, T)
        x2 = fork(combine, vfrontier, hfrontier)
        x3 = compose(x2, center)
        x4 = fork(recolor, color, x3)
        x5 = mapply(x4, x1)
        x6 = paint(I, x5)
        x7 = fork(intersection, first, last)
        x8 = apply(x3, x1)
        x9 = x7(x8)
        O = fill(x6, TWO, x9)
        return O

    def solve_c8cbb738(I):
        x1 = mostcolor(I)
        x2 = fgpartition(I)
        x3 = valmax(x2, shape)
        x4 = canvas(x1, x3)
        x5 = apply(normalize, x2)
        x6 = lbind(subtract, x3)
        x7 = chain(halve, x6, shape)
        x8 = fork(shift, identity, x7)
        x9 = mapply(x8, x5)
        O = paint(x4, x9)
        return O

    def solve_3eda0437(I):
        x1 = interval(TWO, TEN, ONE)
        x2 = prapply(astuple, x1, x1)
        x3 = lbind(canvas, ZERO)
        x4 = lbind(occurrences, I)
        x5 = lbind(lbind, shift)
        x6 = fork(apply, x5, x4)
        x7 = chain(x6, asobject, x3)
        x8 = mapply(x7, x2)
        x9 = argmax(x8, size)
        O = fill(I, SIX, x9)
        return O

    def solve_dc0a314f(I):
        x1 = ofcolor(I, THREE)
        x2 = replace(I, THREE, ZERO)
        x3 = dmirror(x2)
        x4 = papply(pair, x2, x3)
        x5 = lbind(apply, maximum)
        x6 = apply(x5, x4)
        x7 = cmirror(x6)
        x8 = papply(pair, x6, x7)
        x9 = apply(x5, x8)
        O = subgrid(x1, x9)
        return O

    def solve_d4469b4b(I):
        x1 = palette(I)
        x2 = other(x1, ZERO)
        x3 = equality(x2, ONE)
        x4 = equality(x2, TWO)
        x5 = branch(x3, UNITY, TWO_BY_TWO)
        x6 = branch(x4, RIGHT, x5)
        x7 = fork(combine, vfrontier, hfrontier)
        x8 = x7(x6)
        x9 = canvas(ZERO, THREE_BY_THREE)
        O = fill(x9, FIVE, x8)
        return O

    def solve_6ecd11f4(I):
        x1 = objects(I, F, T, T)
        x2 = argmax(x1, size)
        x3 = argmin(x1, size)
        x4 = subgrid(x2, I)
        x5 = subgrid(x3, I)
        x6 = width(x4)
        x7 = width(x5)
        x8 = divide(x6, x7)
        x9 = downscale(x4, x8)
        x10 = ofcolor(x9, ZERO)
        O = fill(x5, ZERO, x10)
        return O

    def solve_760b3cac(I):
        x1 = ofcolor(I, FOUR)
        x2 = ofcolor(I, EIGHT)
        x3 = ulcorner(x1)
        x4 = index(I, x3)
        x5 = equality(x4, FOUR)
        x6 = branch(x5, NEG_ONE, ONE)
        x7 = multiply(x6, THREE)
        x8 = tojvec(x7)
        x9 = vmirror(x2)
        x10 = shift(x9, x8)
        O = fill(I, EIGHT, x10)
        return O

    def solve_c444b776(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = argmin(x2, size)
        x4 = backdrop(x3)
        x5 = toobject(x4, I)
        x6 = normalize(x5)
        x7 = lbind(shift, x6)
        x8 = compose(x7, ulcorner)
        x9 = mapply(x8, x2)
        O = paint(I, x9)
        return O

    def solve_d4a91cb9(I):
        x1 = ofcolor(I, EIGHT)
        x2 = ofcolor(I, TWO)
        x3 = first(x1)
        x4 = first(x2)
        x5 = last(x3)
        x6 = first(x4)
        x7 = astuple(x6, x5)
        x8 = connect(x7, x3)
        x9 = connect(x7, x4)
        x10 = combine(x8, x9)
        O = underfill(I, FOUR, x10)
        return O

    def solve_eb281b96(I):
        x1 = height(I)
        x2 = width(I)
        x3 = decrement(x1)
        x4 = astuple(x3, x2)
        x5 = crop(I, ORIGIN, x4)
        x6 = hmirror(x5)
        x7 = vconcat(I, x6)
        x8 = double(x3)
        x9 = astuple(x8, x2)
        x10 = crop(x7, DOWN, x9)
        O = vconcat(x7, x10)
        return O

    def solve_ff28f65a(I):
        x1 = objects(I, T, F, T)
        x2 = size(x1)
        x3 = double(x2)
        x4 = interval(ZERO, x3, TWO)
        x5 = apply(tojvec, x4)
        x6 = astuple(ONE, NINE)
        x7 = canvas(ZERO, x6)
        x8 = fill(x7, ONE, x5)
        x9 = hsplit(x8, THREE)
        O = merge(x9)
        return O

    def solve_7e0986d6(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        x3 = replace(I, x1, ZERO)
        x4 = leastcolor(x3)
        x5 = rbind(colorcount, x4)
        x6 = chain(positive, decrement, x5)
        x7 = rbind(toobject, x3)
        x8 = chain(x6, x7, dneighbors)
        x9 = sfilter(x2, x8)
        O = fill(x3, x4, x9)
        return O

    def solve_09629e4f(I):
        x1 = objects(I, F, T, T)
        x2 = argmin(x1, numcolors)
        x3 = normalize(x2)
        x4 = upscale(x3, FOUR)
        x5 = paint(I, x4)
        x6 = ofcolor(I, FIVE)
        O = fill(x5, FIVE, x6)
        return O

    def solve_a85d4709(I):
        x1 = ofcolor(I, FIVE)
        x2 = lbind(matcher, last)
        x3 = lbind(sfilter, x1)
        x4 = lbind(mapply, hfrontier)
        x5 = chain(x4, x3, x2)
        x6 = x5(ZERO)
        x7 = x5(TWO)
        x8 = x5(ONE)
        x9 = fill(I, TWO, x6)
        x10 = fill(x9, THREE, x7)
        O = fill(x10, FOUR, x8)
        return O

    def solve_feca6190(I):
        x1 = objects(I, T, F, T)
        x2 = size(x1)
        x3 = multiply(x2, FIVE)
        x4 = astuple(x3, x3)
        x5 = canvas(ZERO, x4)
        x6 = rbind(shoot, UNITY)
        x7 = compose(x6, center)
        x8 = fork(recolor, color, x7)
        x9 = mapply(x8, x1)
        x10 = paint(x5, x9)
        O = hmirror(x10)
        return O

    def solve_a68b268e(I):
        x1 = tophalf(I)
        x2 = bottomhalf(I)
        x3 = lefthalf(x1)
        x4 = righthalf(x1)
        x5 = lefthalf(x2)
        x6 = righthalf(x2)
        x7 = ofcolor(x4, FOUR)
        x8 = ofcolor(x3, SEVEN)
        x9 = ofcolor(x5, EIGHT)
        x10 = fill(x6, EIGHT, x9)
        x11 = fill(x10, FOUR, x7)
        O = fill(x11, SEVEN, x8)
        return O

    def solve_beb8660c(I):
        x1 = shape(I)
        x2 = objects(I, T, F, T)
        x3 = compose(invert, size)
        x4 = order(x2, x3)
        x5 = apply(normalize, x4)
        x6 = size(x5)
        x7 = interval(ZERO, x6, ONE)
        x8 = apply(toivec, x7)
        x9 = mpapply(shift, x5, x8)
        x10 = canvas(ZERO, x1)
        x11 = paint(x10, x9)
        O = rot180(x11)
        return O

    def solve_913fb3ed(I):
        x1 = ofcolor(I, THREE)
        x2 = ofcolor(I, EIGHT)
        x3 = ofcolor(I, TWO)
        x4 = mapply(neighbors, x1)
        x5 = mapply(neighbors, x2)
        x6 = mapply(neighbors, x3)
        x7 = fill(I, SIX, x4)
        x8 = fill(x7, FOUR, x5)
        O = fill(x8, ONE, x6)
        return O

    def solve_0962bcdd(I):
        x1 = leastcolor(I)
        x2 = replace(I, ZERO, x1)
        x3 = leastcolor(x2)
        x4 = ofcolor(I, x3)
        x5 = mapply(dneighbors, x4)
        x6 = fill(I, x3, x5)
        x7 = objects(x6, F, T, T)
        x8 = fork(connect, ulcorner, lrcorner)
        x9 = fork(connect, llcorner, urcorner)
        x10 = fork(combine, x8, x9)
        x11 = mapply(x10, x7)
        O = fill(x6, x1, x11)
        return O

    def solve_3631a71a(I):
        x1 = shape(I)
        x2 = replace(I, NINE, ZERO)
        x3 = lbind(apply, maximum)
        x4 = dmirror(x2)
        x5 = papply(pair, x2, x4)
        x6 = apply(x3, x5)
        x7 = subtract(x1, TWO_BY_TWO)
        x8 = crop(x6, TWO_BY_TWO, x7)
        x9 = vmirror(x8)
        x10 = objects(x9, T, F, T)
        x11 = merge(x10)
        x12 = shift(x11, TWO_BY_TWO)
        O = paint(x6, x12)
        return O

    def solve_05269061(I):
        x1 = objects(I, T, T, T)
        x2 = neighbors(ORIGIN)
        x3 = mapply(neighbors, x2)
        x4 = rbind(multiply, THREE)
        x5 = apply(x4, x3)
        x6 = merge(x1)
        x7 = lbind(shift, x6)
        x8 = mapply(x7, x5)
        x9 = shift(x8, UP_RIGHT)
        x10 = shift(x8, DOWN_LEFT)
        x11 = paint(I, x8)
        x12 = paint(x11, x9)
        O = paint(x12, x10)
        return O

    def solve_95990924(I):
        x1 = objects(I, T, F, T)
        x2 = apply(outbox, x1)
        x3 = apply(ulcorner, x2)
        x4 = apply(urcorner, x2)
        x5 = apply(llcorner, x2)
        x6 = apply(lrcorner, x2)
        x7 = fill(I, ONE, x3)
        x8 = fill(x7, TWO, x4)
        x9 = fill(x8, THREE, x5)
        O = fill(x9, FOUR, x6)
        return O

    def solve_e509e548(I):
        x1 = objects(I, T, F, T)
        x2 = rbind(subgrid, I)
        x3 = chain(palette, trim, x2)
        x4 = lbind(contained, THREE)
        x5 = compose(x4, x3)
        x6 = fork(add, height, width)
        x7 = compose(decrement, x6)
        x8 = fork(equality, size, x7)
        x9 = mfilter(x1, x5)
        x10 = mfilter(x1, x8)
        x11 = replace(I, THREE, SIX)
        x12 = fill(x11, TWO, x9)
        O = fill(x12, ONE, x10)
        return O

    def solve_d43fd935(I):
        x1 = objects(I, T, F, T)
        x2 = ofcolor(I, THREE)
        x3 = sizefilter(x1, ONE)
        x4 = rbind(vmatching, x2)
        x5 = rbind(hmatching, x2)
        x6 = fork(either, x4, x5)
        x7 = sfilter(x3, x6)
        x8 = rbind(gravitate, x2)
        x9 = fork(add, center, x8)
        x10 = fork(connect, center, x9)
        x11 = fork(recolor, color, x10)
        x12 = mapply(x11, x7)
        O = paint(I, x12)
        return O

    def solve_db3e9e38(I):
        x1 = ofcolor(I, SEVEN)
        x2 = lrcorner(x1)
        x3 = shoot(x2, UP_RIGHT)
        x4 = shoot(x2, NEG_UNITY)
        x5 = combine(x3, x4)
        x6 = rbind(shoot, UP)
        x7 = mapply(x6, x5)
        x8 = last(x2)
        x9 = rbind(subtract, x8)
        x10 = chain(even, x9, last)
        x11 = fill(I, EIGHT, x7)
        x12 = sfilter(x7, x10)
        O = fill(x11, SEVEN, x12)
        return O

    def solve_e73095fd(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = fork(equality, toindices, backdrop)
        x4 = sfilter(x2, x3)
        x5 = lbind(mapply, dneighbors)
        x6 = chain(x5, corners, outbox)
        x7 = fork(difference, x6, outbox)
        x8 = ofcolor(I, FIVE)
        x9 = rbind(intersection, x8)
        x10 = matcher(size, ZERO)
        x11 = chain(x10, x9, x7)
        x12 = mfilter(x4, x11)
        O = fill(I, FOUR, x12)
        return O

    def solve_1bfc4729(I):
        x1 = asindices(I)
        x2 = tophalf(I)
        x3 = bottomhalf(I)
        x4 = leastcolor(x2)
        x5 = leastcolor(x3)
        x6 = hfrontier(TWO_BY_ZERO)
        x7 = box(x1)
        x8 = combine(x6, x7)
        x9 = fill(x2, x4, x8)
        x10 = hmirror(x9)
        x11 = replace(x10, x4, x5)
        O = vconcat(x9, x11)
        return O

    def solve_93b581b8(I):
        x1 = fgpartition(I)
        x2 = chain(cmirror, dmirror, merge)
        x3 = x2(x1)
        x4 = upscale(x3, THREE)
        x5 = astuple(NEG_TWO, NEG_TWO)
        x6 = shift(x4, x5)
        x7 = underpaint(I, x6)
        x8 = toindices(x3)
        x9 = fork(combine, hfrontier, vfrontier)
        x10 = mapply(x9, x8)
        x11 = difference(x10, x8)
        O = fill(x7, ZERO, x11)
        return O

    def solve_9edfc990(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = ofcolor(I, ONE)
        x4 = rbind(adjacent, x3)
        x5 = mfilter(x2, x4)
        x6 = recolor(ONE, x5)
        O = paint(I, x6)
        return O

    def solve_a65b410d(I):
        x1 = ofcolor(I, TWO)
        x2 = urcorner(x1)
        x3 = shoot(x2, UP_RIGHT)
        x4 = shoot(x2, DOWN_LEFT)
        x5 = underfill(I, THREE, x3)
        x6 = underfill(x5, ONE, x4)
        x7 = rbind(shoot, LEFT)
        x8 = mapply(x7, x3)
        x9 = mapply(x7, x4)
        x10 = underfill(x6, ONE, x9)
        O = underfill(x10, THREE, x8)
        return O

    def solve_7447852a(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = compose(last, center)
        x4 = order(x2, x3)
        x5 = size(x4)
        x6 = interval(ZERO, x5, THREE)
        x7 = rbind(contained, x6)
        x8 = compose(x7, last)
        x9 = interval(ZERO, x5, ONE)
        x10 = pair(x4, x9)
        x11 = sfilter(x10, x8)
        x12 = mapply(first, x11)
        O = fill(I, FOUR, x12)
        return O

    def solve_97999447(I):
        x1 = objects(I, T, F, T)
        x2 = apply(toindices, x1)
        x3 = rbind(shoot, RIGHT)
        x4 = compose(x3, center)
        x5 = fork(recolor, color, x4)
        x6 = mapply(x5, x1)
        x7 = paint(I, x6)
        x8 = interval(ZERO, FIVE, ONE)
        x9 = apply(double, x8)
        x10 = apply(increment, x9)
        x11 = apply(tojvec, x10)
        x12 = prapply(shift, x2, x11)
        x13 = merge(x12)
        O = fill(x7, FIVE, x13)
        return O

    def solve_91714a58(I):
        x1 = shape(I)
        x2 = asindices(I)
        x3 = objects(I, T, F, T)
        x4 = argmax(x3, size)
        x5 = mostcolor(x4)
        x6 = canvas(ZERO, x1)
        x7 = paint(x6, x4)
        x8 = rbind(toobject, x7)
        x9 = rbind(colorcount, x5)
        x10 = chain(x9, x8, neighbors)
        x11 = lbind(greater, THREE)
        x12 = compose(x11, x10)
        x13 = sfilter(x2, x12)
        O = fill(x7, ZERO, x13)
        return O

    def solve_a61ba2ce(I):
        x1 = objects(I, T, F, T)
        x2 = lbind(index, I)
        x3 = matcher(x2, ZERO)
        x4 = lbind(extract, x1)
        x5 = rbind(subgrid, I)
        x6 = lbind(compose, x3)
        x7 = chain(x5, x4, x6)
        x8 = x7(ulcorner)
        x9 = x7(urcorner)
        x10 = x7(llcorner)
        x11 = x7(lrcorner)
        x12 = hconcat(x11, x10)
        x13 = hconcat(x9, x8)
        O = vconcat(x12, x13)
        return O

    def solve_8e1813be(I):
        x1 = replace(I, FIVE, ZERO)
        x2 = objects(x1, T, T, T)
        x3 = first(x2)
        x4 = vline(x3)
        x5 = branch(x4, dmirror, identity)
        x6 = x5(x1)
        x7 = objects(x6, T, T, T)
        x8 = order(x7, uppermost)
        x9 = apply(color, x8)
        x10 = dedupe(x9)
        x11 = size(x10)
        x12 = rbind(repeat, x11)
        x13 = apply(x12, x10)
        O = x5(x13)
        return O

    def solve_bc1d5164(I):
        x1 = leastcolor(I)
        x2 = crop(I, ORIGIN, THREE_BY_THREE)
        x3 = crop(I, TWO_BY_ZERO, THREE_BY_THREE)
        x4 = tojvec(FOUR)
        x5 = crop(I, x4, THREE_BY_THREE)
        x6 = astuple(TWO, FOUR)
        x7 = crop(I, x6, THREE_BY_THREE)
        x8 = canvas(ZERO, THREE_BY_THREE)
        x9 = rbind(ofcolor, x1)
        x10 = astuple(x2, x3)
        x11 = astuple(x5, x7)
        x12 = combine(x10, x11)
        x13 = mapply(x9, x12)
        O = fill(x8, x1, x13)
        return O

    def solve_ce602527(I):
        x1 = vmirror(I)
        x2 = fgpartition(x1)
        x3 = order(x2, size)
        x4 = last(x3)
        x5 = remove(x4, x3)
        x6 = compose(toindices, normalize)
        x7 = rbind(upscale, TWO)
        x8 = chain(toindices, x7, normalize)
        x9 = x6(x4)
        x10 = rbind(intersection, x9)
        x11 = chain(size, x10, x8)
        x12 = argmax(x5, x11)
        x13 = subgrid(x12, x1)
        O = vmirror(x13)
        return O

    def solve_5c2c9af4(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        x3 = center(x2)
        x4 = ulcorner(x2)
        x5 = subtract(x3, x4)
        x6 = multiply(NEG_ONE, NINE)
        x7 = interval(ZERO, NINE, ONE)
        x8 = interval(ZERO, x6, NEG_ONE)
        x9 = lbind(multiply, x5)
        x10 = apply(x9, x7)
        x11 = apply(x9, x8)
        x12 = pair(x10, x11)
        x13 = mapply(box, x12)
        x14 = shift(x13, x3)
        O = fill(I, x1, x14)
        return O

    def solve_75b8110e(I):
        x1 = lefthalf(I)
        x2 = righthalf(I)
        x3 = tophalf(x1)
        x4 = bottomhalf(x1)
        x5 = tophalf(x2)
        x6 = bottomhalf(x2)
        x7 = rbind(ofcolor, ZERO)
        x8 = fork(difference, asindices, x7)
        x9 = fork(toobject, x8, identity)
        x10 = x9(x5)
        x11 = x9(x4)
        x12 = x9(x6)
        x13 = paint(x3, x12)
        x14 = paint(x13, x11)
        O = paint(x14, x10)
        return O

    def solve_941d9a10(I):
        x1 = shape(I)
        x2 = objects(I, T, F, F)
        x3 = colorfilter(x2, ZERO)
        x4 = apply(toindices, x3)
        x5 = lbind(lbind, contained)
        x6 = lbind(extract, x4)
        x7 = compose(x6, x5)
        x8 = decrement(x1)
        x9 = astuple(FIVE, FIVE)
        x10 = x7(ORIGIN)
        x11 = x7(x8)
        x12 = x7(x9)
        x13 = fill(I, ONE, x10)
        x14 = fill(x13, THREE, x11)
        O = fill(x14, TWO, x12)
        return O

    def solve_c3f564a4(I):
        x1 = asindices(I)
        x2 = dmirror(I)
        x3 = invert(NINE)
        x4 = papply(pair, I, x2)
        x5 = lbind(apply, maximum)
        x6 = apply(x5, x4)
        x7 = ofcolor(x6, ZERO)
        x8 = difference(x1, x7)
        x9 = toobject(x8, x6)
        x10 = interval(x3, NINE, ONE)
        x11 = interval(NINE, x3, NEG_ONE)
        x12 = pair(x10, x11)
        x13 = lbind(shift, x9)
        x14 = mapply(x13, x12)
        O = paint(x6, x14)
        return O

    def solve_1a07d186(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = difference(x1, x2)
        x4 = apply(color, x3)
        x5 = rbind(contained, x4)
        x6 = compose(x5, color)
        x7 = sfilter(x2, x6)
        x8 = lbind(colorfilter, x3)
        x9 = chain(first, x8, color)
        x10 = fork(gravitate, identity, x9)
        x11 = fork(shift, identity, x10)
        x12 = mapply(x11, x7)
        x13 = merge(x2)
        x14 = cover(I, x13)
        O = paint(x14, x12)
        return O

    def solve_d687bc17(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = difference(x1, x2)
        x4 = apply(color, x3)
        x5 = rbind(contained, x4)
        x6 = compose(x5, color)
        x7 = sfilter(x2, x6)
        x8 = lbind(colorfilter, x3)
        x9 = chain(first, x8, color)
        x10 = fork(gravitate, identity, x9)
        x11 = fork(shift, identity, x10)
        x12 = merge(x2)
        x13 = mapply(x11, x7)
        x14 = cover(I, x12)
        O = paint(x14, x13)
        return O

    def solve_9af7a82c(I):
        x1 = objects(I, T, F, F)
        x2 = order(x1, size)
        x3 = valmax(x1, size)
        x4 = rbind(astuple, ONE)
        x5 = lbind(subtract, x3)
        x6 = compose(x4, size)
        x7 = chain(x4, x5, size)
        x8 = fork(canvas, color, x6)
        x9 = lbind(canvas, ZERO)
        x10 = compose(x9, x7)
        x11 = fork(vconcat, x8, x10)
        x12 = compose(cmirror, x11)
        x13 = apply(x12, x2)
        x14 = merge(x13)
        O = cmirror(x14)
        return O

    def solve_6e19193c(I):
        x1 = leastcolor(I)
        x2 = objects(I, T, F, T)
        x3 = rbind(toobject, I)
        x4 = compose(first, delta)
        x5 = rbind(colorcount, x1)
        x6 = matcher(x5, TWO)
        x7 = chain(x6, x3, dneighbors)
        x8 = rbind(sfilter, x7)
        x9 = chain(first, x8, toindices)
        x10 = fork(subtract, x4, x9)
        x11 = fork(shoot, x4, x10)
        x12 = mapply(x11, x2)
        x13 = fill(I, x1, x12)
        x14 = mapply(delta, x2)
        O = fill(x13, ZERO, x14)
        return O

    def solve_ef135b50(I):
        x1 = ofcolor(I, TWO)
        x2 = ofcolor(I, ZERO)
        x3 = product(x1, x1)
        x4 = power(first, TWO)
        x5 = compose(first, last)
        x6 = fork(equality, x4, x5)
        x7 = sfilter(x3, x6)
        x8 = fork(connect, first, last)
        x9 = mapply(x8, x7)
        x10 = intersection(x9, x2)
        x11 = fill(I, NINE, x10)
        x12 = trim(x11)
        x13 = asobject(x12)
        x14 = shift(x13, UNITY)
        O = paint(I, x14)
        return O

    def solve_cbded52d(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = product(x2, x2)
        x4 = fork(vmatching, first, last)
        x5 = fork(hmatching, first, last)
        x6 = fork(either, x4, x5)
        x7 = sfilter(x3, x6)
        x8 = compose(center, first)
        x9 = compose(center, last)
        x10 = fork(connect, x8, x9)
        x11 = chain(initset, center, x10)
        x12 = compose(color, first)
        x13 = fork(recolor, x12, x11)
        x14 = mapply(x13, x7)
        O = paint(I, x14)
        return O

    def solve_8a004b2b(I):
        x1 = objects(I, F, T, T)
        x2 = ofcolor(I, FOUR)
        x3 = subgrid(x2, I)
        x4 = argmax(x1, lowermost)
        x5 = normalize(x4)
        x6 = replace(x3, FOUR, ZERO)
        x7 = objects(x6, T, F, T)
        x8 = merge(x7)
        x9 = width(x8)
        x10 = ulcorner(x8)
        x11 = width(x4)
        x12 = divide(x9, x11)
        x13 = upscale(x5, x12)
        x14 = shift(x13, x10)
        O = paint(x3, x14)
        return O

    def solve_e26a3af2(I):
        x1 = rot90(I)
        x2 = apply(mostcommon, I)
        x3 = apply(mostcommon, x1)
        x4 = repeat(x2, ONE)
        x5 = repeat(x3, ONE)
        x6 = compose(size, dedupe)
        x7 = x6(x2)
        x8 = x6(x3)
        x9 = greater(x8, x7)
        x10 = branch(x9, height, width)
        x11 = x10(I)
        x12 = rot90(x4)
        x13 = branch(x9, x5, x12)
        x14 = branch(x9, vupscale, hupscale)
        O = x14(x13, x11)
        return O

    def solve_6cf79266(I):
        x1 = ofcolor(I, ZERO)
        x2 = astuple(ZERO, ORIGIN)
        x3 = initset(x2)
        x4 = upscale(x3, THREE)
        x5 = toindices(x4)
        x6 = lbind(shift, x5)
        x7 = rbind(difference, x1)
        x8 = chain(size, x7, x6)
        x9 = matcher(x8, ZERO)
        x10 = lbind(add, NEG_UNITY)
        x11 = chain(flip, x9, x10)
        x12 = fork(both, x9, x11)
        x13 = sfilter(x1, x12)
        x14 = mapply(x6, x13)
        O = fill(I, ONE, x14)
        return O

    def solve_a87f7484(I):
        x1 = numcolors(I)
        x2 = dmirror(I)
        x3 = portrait(I)
        x4 = branch(x3, dmirror, identity)
        x5 = x4(I)
        x6 = decrement(x1)
        x7 = hsplit(x5, x6)
        x8 = rbind(ofcolor, ZERO)
        x9 = apply(x8, x7)
        x10 = leastcommon(x9)
        x11 = matcher(x8, x10)
        x12 = extract(x7, x11)
        O = x4(x12)
        return O

    def solve_4093f84a(I):
        x1 = leastcolor(I)
        x2 = replace(I, x1, FIVE)
        x3 = ofcolor(I, FIVE)
        x4 = portrait(x3)
        x5 = branch(x4, identity, dmirror)
        x6 = x5(x2)
        x7 = lefthalf(x6)
        x8 = righthalf(x6)
        x9 = rbind(order, identity)
        x10 = rbind(order, invert)
        x11 = apply(x9, x7)
        x12 = apply(x10, x8)
        x13 = hconcat(x11, x12)
        O = x5(x13)
        return O

    def solve_ba26e723(I):
        x1 = rbind(divide, THREE)
        x2 = rbind(multiply, THREE)
        x3 = compose(x2, x1)
        x4 = fork(equality, identity, x3)
        x5 = compose(x4, last)
        x6 = ofcolor(I, FOUR)
        x7 = sfilter(x6, x5)
        O = fill(I, SIX, x7)
        return O

    def solve_4612dd53(I):
        x1 = ofcolor(I, ONE)
        x2 = box(x1)
        x3 = fill(I, TWO, x2)
        x4 = subgrid(x1, x3)
        x5 = ofcolor(x4, ONE)
        x6 = mapply(vfrontier, x5)
        x7 = mapply(hfrontier, x5)
        x8 = size(x6)
        x9 = size(x7)
        x10 = greater(x8, x9)
        x11 = branch(x10, x7, x6)
        x12 = fill(x4, TWO, x11)
        x13 = ofcolor(x12, TWO)
        x14 = ulcorner(x1)
        x15 = shift(x13, x14)
        O = underfill(I, TWO, x15)
        return O

    def solve_29c11459(I):
        x1 = lefthalf(I)
        x2 = righthalf(I)
        x3 = objects(x2, T, F, T)
        x4 = objects(x1, T, F, T)
        x5 = compose(hfrontier, center)
        x6 = fork(recolor, color, x5)
        x7 = mapply(x6, x4)
        x8 = paint(x1, x7)
        x9 = mapply(x6, x3)
        x10 = paint(I, x9)
        x11 = objects(x8, T, F, T)
        x12 = apply(urcorner, x11)
        x13 = shift(x12, RIGHT)
        x14 = merge(x11)
        x15 = paint(x10, x14)
        O = fill(x15, FIVE, x13)
        return O

    def solve_963e52fc(I):
        x1 = width(I)
        x2 = asobject(I)
        x3 = hperiod(x2)
        x4 = height(x2)
        x5 = astuple(x4, x3)
        x6 = ulcorner(x2)
        x7 = crop(I, x6, x5)
        x8 = rot90(x7)
        x9 = double(x1)
        x10 = divide(x9, x3)
        x11 = increment(x10)
        x12 = repeat(x8, x11)
        x13 = merge(x12)
        x14 = rot270(x13)
        x15 = astuple(x4, x9)
        O = crop(x14, ORIGIN, x15)
        return O

    def solve_ae3edfdc(I):
        x1 = objects(I, T, F, T)
        x2 = replace(I, THREE, ZERO)
        x3 = replace(x2, SEVEN, ZERO)
        x4 = lbind(colorfilter, x1)
        x5 = lbind(rbind, gravitate)
        x6 = chain(x5, first, x4)
        x7 = x6(TWO)
        x8 = x6(ONE)
        x9 = x4(THREE)
        x10 = x4(SEVEN)
        x11 = fork(shift, identity, x7)
        x12 = fork(shift, identity, x8)
        x13 = mapply(x11, x9)
        x14 = mapply(x12, x10)
        x15 = paint(x3, x13)
        O = paint(x15, x14)
        return O

    def solve_1f0c79e5(I):
        x1 = ofcolor(I, TWO)
        x2 = replace(I, TWO, ZERO)
        x3 = leastcolor(x2)
        x4 = ofcolor(x2, x3)
        x5 = combine(x1, x4)
        x6 = recolor(x3, x5)
        x7 = compose(decrement, double)
        x8 = ulcorner(x5)
        x9 = invert(x8)
        x10 = shift(x1, x9)
        x11 = apply(x7, x10)
        x12 = interval(ZERO, NINE, ONE)
        x13 = prapply(multiply, x11, x12)
        x14 = lbind(shift, x6)
        x15 = mapply(x14, x13)
        O = paint(I, x15)
        return O

    def solve_56dc2b01(I):
        x1 = objects(I, T, F, T)
        x2 = colorfilter(x1, THREE)
        x3 = first(x2)
        x4 = ofcolor(I, TWO)
        x5 = gravitate(x3, x4)
        x6 = first(x5)
        x7 = equality(x6, ZERO)
        x8 = branch(x7, width, height)
        x9 = x8(x3)
        x10 = gravitate(x4, x3)
        x11 = sign(x10)
        x12 = multiply(x11, x9)
        x13 = crement(x12)
        x14 = recolor(EIGHT, x4)
        x15 = shift(x14, x13)
        x16 = paint(I, x15)
        O = move(x16, x3, x5)
        return O

    def solve_e48d4e1a(I):
        x1 = shape(I)
        x2 = ofcolor(I, FIVE)
        x3 = fill(I, ZERO, x2)
        x4 = leastcolor(x3)
        x5 = size(x2)
        x6 = ofcolor(I, x4)
        x7 = rbind(toobject, I)
        x8 = rbind(colorcount, x4)
        x9 = chain(x8, x7, dneighbors)
        x10 = matcher(x9, FOUR)
        x11 = extract(x6, x10)
        x12 = multiply(DOWN_LEFT, x5)
        x13 = add(x12, x11)
        x14 = canvas(ZERO, x1)
        x15 = fork(combine, vfrontier, hfrontier)
        x16 = x15(x13)
        O = fill(x14, x4, x16)
        return O

    def solve_6773b310(I):
        x1 = compress(I)
        x2 = neighbors(ORIGIN)
        x3 = insert(ORIGIN, x2)
        x4 = rbind(multiply, THREE)
        x5 = apply(x4, x3)
        x6 = astuple(FOUR, FOUR)
        x7 = shift(x5, x6)
        x8 = fork(insert, identity, neighbors)
        x9 = apply(x8, x7)
        x10 = rbind(toobject, x1)
        x11 = apply(x10, x9)
        x12 = rbind(colorcount, SIX)
        x13 = matcher(x12, TWO)
        x14 = mfilter(x11, x13)
        x15 = fill(x1, ONE, x14)
        x16 = replace(x15, SIX, ZERO)
        O = downscale(x16, THREE)
        return O

    def solve_780d0b14(I):
        x1 = asindices(I)
        x2 = objects(I, T, T, T)
        x3 = rbind(greater, TWO)
        x4 = compose(x3, size)
        x5 = sfilter(x2, x4)
        x6 = totuple(x5)
        x7 = apply(color, x6)
        x8 = apply(center, x6)
        x9 = pair(x7, x8)
        x10 = fill(I, ZERO, x1)
        x11 = paint(x10, x9)
        x12 = rbind(greater, ONE)
        x13 = compose(dedupe, totuple)
        x14 = chain(x12, size, x13)
        x15 = sfilter(x11, x14)
        x16 = rot90(x15)
        x17 = sfilter(x16, x14)
        O = rot270(x17)
        return O

    def solve_2204b7a8(I):
        x1 = objects(I, T, F, T)
        x2 = lbind(sfilter, x1)
        x3 = compose(size, x2)
        x4 = x3(vline)
        x5 = x3(hline)
        x6 = greater(x4, x5)
        x7 = branch(x6, lefthalf, tophalf)
        x8 = branch(x6, righthalf, bottomhalf)
        x9 = branch(x6, hconcat, vconcat)
        x10 = x7(I)
        x11 = x8(I)
        x12 = index(x10, ORIGIN)
        x13 = shape(x11)
        x14 = decrement(x13)
        x15 = index(x11, x14)
        x16 = replace(x10, THREE, x12)
        x17 = replace(x11, THREE, x15)
        O = x9(x16, x17)
        return O

    def solve_d9f24cd1(I):
        x1 = ofcolor(I, TWO)
        x2 = ofcolor(I, FIVE)
        x3 = prapply(connect, x1, x2)
        x4 = mfilter(x3, vline)
        x5 = underfill(I, TWO, x4)
        x6 = matcher(numcolors, TWO)
        x7 = objects(x5, F, F, T)
        x8 = sfilter(x7, x6)
        x9 = difference(x7, x8)
        x10 = colorfilter(x9, TWO)
        x11 = mapply(toindices, x10)
        x12 = apply(urcorner, x8)
        x13 = shift(x12, UNITY)
        x14 = rbind(shoot, UP)
        x15 = mapply(x14, x13)
        x16 = fill(x5, TWO, x15)
        x17 = mapply(vfrontier, x11)
        O = fill(x16, TWO, x17)
        return O

    def solve_b782dc8a(I):
        x1 = leastcolor(I)
        x2 = objects(I, T, F, F)
        x3 = ofcolor(I, x1)
        x4 = first(x3)
        x5 = dneighbors(x4)
        x6 = toobject(x5, I)
        x7 = mostcolor(x6)
        x8 = ofcolor(I, x7)
        x9 = colorfilter(x2, ZERO)
        x10 = rbind(adjacent, x8)
        x11 = mfilter(x9, x10)
        x12 = toindices(x11)
        x13 = rbind(manhattan, x3)
        x14 = chain(even, x13, initset)
        x15 = sfilter(x12, x14)
        x16 = difference(x12, x15)
        x17 = fill(I, x1, x15)
        O = fill(x17, x7, x16)
        return O

    def solve_673ef223(I):
        x1 = objects(I, T, F, T)
        x2 = ofcolor(I, EIGHT)
        x3 = replace(I, EIGHT, FOUR)
        x4 = colorfilter(x1, TWO)
        x5 = argmin(x1, uppermost)
        x6 = apply(uppermost, x4)
        x7 = fork(subtract, maximum, minimum)
        x8 = x7(x6)
        x9 = toivec(x8)
        x10 = leftmost(x5)
        x11 = equality(x10, ZERO)
        x12 = branch(x11, LEFT, RIGHT)
        x13 = rbind(shoot, x12)
        x14 = mapply(x13, x2)
        x15 = underfill(x3, EIGHT, x14)
        x16 = shift(x2, x9)
        x17 = mapply(hfrontier, x16)
        O = underfill(x15, EIGHT, x17)
        return O

    def solve_f5b8619d(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        x3 = mapply(vfrontier, x2)
        x4 = underfill(I, EIGHT, x3)
        x5 = hconcat(x4, x4)
        O = vconcat(x5, x5)
        return O

    def solve_f8c80d96(I):
        x1 = leastcolor(I)
        x2 = objects(I, T, F, F)
        x3 = colorfilter(x2, x1)
        x4 = argmax(x3, size)
        x5 = argmin(x2, width)
        x6 = size(x5)
        x7 = equality(x6, ONE)
        x8 = branch(x7, identity, outbox)
        x9 = chain(outbox, outbox, x8)
        x10 = power(x9, TWO)
        x11 = power(x9, THREE)
        x12 = x9(x4)
        x13 = x10(x4)
        x14 = x11(x4)
        x15 = fill(I, x1, x12)
        x16 = fill(x15, x1, x13)
        x17 = fill(x16, x1, x14)
        O = replace(x17, ZERO, FIVE)
        return O

    def solve_ecdecbb3(I):
        x1 = objects(I, T, F, T)
        x2 = colorfilter(x1, TWO)
        x3 = colorfilter(x1, EIGHT)
        x4 = product(x2, x3)
        x5 = fork(gravitate, first, last)
        x6 = compose(crement, x5)
        x7 = compose(center, first)
        x8 = fork(add, x7, x6)
        x9 = fork(connect, x7, x8)
        x10 = apply(x9, x4)
        x11 = lbind(greater, EIGHT)
        x12 = compose(x11, size)
        x13 = mfilter(x10, x12)
        x14 = fill(I, TWO, x13)
        x15 = apply(x8, x4)
        x16 = intersection(x13, x15)
        x17 = mapply(neighbors, x16)
        O = fill(x14, EIGHT, x17)
        return O

    def solve_e5062a87(I):
        x1 = ofcolor(I, TWO)
        x2 = recolor(ZERO, x1)
        x3 = normalize(x2)
        x4 = occurrences(I, x2)
        x5 = lbind(shift, x3)
        x6 = apply(x5, x4)
        x7 = astuple(ONE, THREE)
        x8 = astuple(FIVE, ONE)
        x9 = astuple(TWO, SIX)
        x10 = initset(x7)
        x11 = insert(x8, x10)
        x12 = insert(x9, x11)
        x13 = rbind(contained, x12)
        x14 = chain(flip, x13, ulcorner)
        x15 = sfilter(x6, x14)
        x16 = merge(x15)
        x17 = recolor(TWO, x16)
        O = paint(I, x17)
        return O

    def solve_a8d7556c(I):
        x1 = initset(ORIGIN)
        x2 = recolor(ZERO, x1)
        x3 = upscale(x2, TWO)
        x4 = occurrences(I, x3)
        x5 = lbind(shift, x3)
        x6 = mapply(x5, x4)
        x7 = fill(I, TWO, x6)
        x8 = add(SIX, SIX)
        x9 = astuple(EIGHT, x8)
        x10 = index(x7, x9)
        x11 = equality(x10, TWO)
        x12 = initset(x9)
        x13 = add(x9, DOWN)
        x14 = insert(x13, x12)
        x15 = toobject(x14, x7)
        x16 = toobject(x14, I)
        x17 = branch(x11, x16, x15)
        O = paint(x7, x17)
        return O

    def solve_4938f0c2(I):
        x1 = objects(I, T, T, T)
        x2 = ofcolor(I, TWO)
        x3 = vmirror(x2)
        x4 = height(x2)
        x5 = width(x2)
        x6 = toivec(x4)
        x7 = tojvec(x5)
        x8 = add(x7, ZERO_BY_TWO)
        x9 = add(x6, TWO_BY_ZERO)
        x10 = shift(x3, x8)
        x11 = fill(I, TWO, x10)
        x12 = ofcolor(x11, TWO)
        x13 = hmirror(x12)
        x14 = shift(x13, x9)
        x15 = fill(x11, TWO, x14)
        x16 = size(x1)
        x17 = greater(x16, FOUR)
        O = branch(x17, I, x15)
        return O

    def solve_834ec97d(I):
        x1 = asindices(I)
        x2 = objects(I, T, F, T)
        x3 = first(x2)
        x4 = shift(x3, DOWN)
        x5 = fill(I, ZERO, x3)
        x6 = paint(x5, x4)
        x7 = uppermost(x4)
        x8 = leftmost(x4)
        x9 = subtract(x8, TEN)
        x10 = add(x8, TEN)
        x11 = interval(x9, x10, TWO)
        x12 = lbind(greater, x7)
        x13 = compose(x12, first)
        x14 = rbind(contained, x11)
        x15 = compose(x14, last)
        x16 = sfilter(x1, x13)
        x17 = sfilter(x16, x15)
        O = fill(x6, FOUR, x17)
        return O

    def solve_846bdb03(I):
        x1 = objects(I, F, F, T)
        x2 = rbind(colorcount, FOUR)
        x3 = matcher(x2, ZERO)
        x4 = extract(x1, x3)
        x5 = remove(x4, x1)
        x6 = merge(x5)
        x7 = subgrid(x6, I)
        x8 = index(x7, DOWN)
        x9 = subgrid(x4, I)
        x10 = lefthalf(x9)
        x11 = palette(x10)
        x12 = other(x11, ZERO)
        x13 = equality(x8, x12)
        x14 = branch(x13, identity, vmirror)
        x15 = x14(x4)
        x16 = normalize(x15)
        x17 = shift(x16, UNITY)
        O = paint(x7, x17)
        return O

    def solve_90f3ed37(I):
        x1 = objects(I, T, T, T)
        x2 = order(x1, uppermost)
        x3 = first(x2)
        x4 = remove(x3, x2)
        x5 = normalize(x3)
        x6 = lbind(shift, x5)
        x7 = compose(x6, ulcorner)
        x8 = interval(TWO, NEG_ONE, NEG_ONE)
        x9 = apply(tojvec, x8)
        x10 = rbind(apply, x9)
        x11 = lbind(compose, size)
        x12 = lbind(lbind, intersection)
        x13 = compose(x11, x12)
        x14 = lbind(lbind, shift)
        x15 = chain(x10, x14, x7)
        x16 = fork(argmax, x15, x13)
        x17 = mapply(x16, x4)
        O = underfill(I, ONE, x17)
        return O

    def solve_8403a5d5(I):
        x1 = asindices(I)
        x2 = objects(I, T, F, T)
        x3 = first(x2)
        x4 = color(x3)
        x5 = leftmost(x3)
        x6 = interval(x5, TEN, TWO)
        x7 = rbind(contained, x6)
        x8 = compose(x7, last)
        x9 = sfilter(x1, x8)
        x10 = increment(x5)
        x11 = add(x5, THREE)
        x12 = interval(x10, TEN, FOUR)
        x13 = interval(x11, TEN, FOUR)
        x14 = lbind(astuple, NINE)
        x15 = apply(tojvec, x12)
        x16 = apply(x14, x13)
        x17 = fill(I, x4, x9)
        x18 = fill(x17, FIVE, x15)
        O = fill(x18, FIVE, x16)
        return O

    def solve_91413438(I):
        x1 = colorcount(I, ZERO)
        x2 = subtract(NINE, x1)
        x3 = multiply(x1, THREE)
        x4 = multiply(x3, x1)
        x5 = subtract(x4, THREE)
        x6 = astuple(THREE, x5)
        x7 = canvas(ZERO, x6)
        x8 = hconcat(I, x7)
        x9 = objects(x8, T, T, T)
        x10 = first(x9)
        x11 = lbind(shift, x10)
        x12 = compose(x11, tojvec)
        x13 = interval(ZERO, x2, ONE)
        x14 = rbind(multiply, THREE)
        x15 = apply(x14, x13)
        x16 = mapply(x12, x15)
        x17 = paint(x8, x16)
        x18 = hsplit(x17, x1)
        O = merge(x18)
        return O

    def solve_539a4f51(I):
        x1 = shape(I)
        x2 = index(I, ORIGIN)
        x3 = colorcount(I, ZERO)
        x4 = decrement(x1)
        x5 = positive(x3)
        x6 = branch(x5, x4, x1)
        x7 = crop(I, ORIGIN, x6)
        x8 = width(x7)
        x9 = astuple(ONE, x8)
        x10 = crop(x7, ORIGIN, x9)
        x11 = vupscale(x10, x8)
        x12 = dmirror(x11)
        x13 = hconcat(x7, x11)
        x14 = hconcat(x12, x7)
        x15 = vconcat(x13, x14)
        x16 = asobject(x15)
        x17 = multiply(UNITY, TEN)
        x18 = canvas(x2, x17)
        O = paint(x18, x16)
        return O

    def solve_5daaa586(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = rbind(bordering, I)
        x4 = compose(flip, x3)
        x5 = extract(x2, x4)
        x6 = outbox(x5)
        x7 = subgrid(x6, I)
        x8 = fgpartition(x7)
        x9 = argmax(x8, size)
        x10 = color(x9)
        x11 = toindices(x9)
        x12 = prapply(connect, x11, x11)
        x13 = mfilter(x12, vline)
        x14 = mfilter(x12, hline)
        x15 = size(x13)
        x16 = size(x14)
        x17 = greater(x15, x16)
        x18 = branch(x17, x13, x14)
        O = fill(x7, x10, x18)
        return O

    def solve_3bdb4ada(I):
        x1 = objects(I, T, F, T)
        x2 = totuple(x1)
        x3 = compose(increment, ulcorner)
        x4 = compose(decrement, lrcorner)
        x5 = apply(x3, x2)
        x6 = apply(x4, x2)
        x7 = papply(connect, x5, x6)
        x8 = apply(last, x5)
        x9 = compose(last, first)
        x10 = power(last, TWO)
        x11 = fork(subtract, x9, x10)
        x12 = compose(even, x11)
        x13 = lbind(rbind, astuple)
        x14 = lbind(compose, x12)
        x15 = compose(x14, x13)
        x16 = fork(sfilter, first, x15)
        x17 = pair(x7, x8)
        x18 = mapply(x16, x17)
        O = fill(I, ZERO, x18)
        return O

    def solve_ec883f72(I):
        x1 = palette(I)
        x2 = objects(I, T, T, T)
        x3 = fork(multiply, height, width)
        x4 = argmax(x2, x3)
        x5 = color(x4)
        x6 = remove(ZERO, x1)
        x7 = other(x6, x5)
        x8 = lrcorner(x4)
        x9 = llcorner(x4)
        x10 = urcorner(x4)
        x11 = ulcorner(x4)
        x12 = shoot(x8, UNITY)
        x13 = shoot(x9, DOWN_LEFT)
        x14 = shoot(x10, UP_RIGHT)
        x15 = shoot(x11, NEG_UNITY)
        x16 = combine(x12, x13)
        x17 = combine(x14, x15)
        x18 = combine(x16, x17)
        O = underfill(I, x7, x18)
        return O

    def solve_2bee17df(I):
        x1 = height(I)
        x2 = rot90(I)
        x3 = subtract(x1, TWO)
        x4 = interval(ZERO, x1, ONE)
        x5 = rbind(colorcount, ZERO)
        x6 = matcher(x5, x3)
        x7 = rbind(vsplit, x1)
        x8 = lbind(apply, x6)
        x9 = compose(x8, x7)
        x10 = x9(I)
        x11 = pair(x4, x10)
        x12 = sfilter(x11, last)
        x13 = mapply(hfrontier, x12)
        x14 = x9(x2)
        x15 = pair(x14, x4)
        x16 = sfilter(x15, first)
        x17 = mapply(vfrontier, x16)
        x18 = astuple(x13, x17)
        x19 = merge(x18)
        O = underfill(I, THREE, x19)
        return O

    def solve_e8dc4411(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, ZERO)
        x3 = ofcolor(I, x1)
        x4 = position(x2, x3)
        x5 = fork(connect, ulcorner, lrcorner)
        x6 = x5(x2)
        x7 = intersection(x2, x6)
        x8 = equality(x6, x7)
        x9 = fork(subtract, identity, crement)
        x10 = fork(add, identity, x9)
        x11 = branch(x8, identity, x10)
        x12 = shape(x2)
        x13 = multiply(x12, x4)
        x14 = apply(x11, x13)
        x15 = interval(ONE, FIVE, ONE)
        x16 = lbind(multiply, x14)
        x17 = apply(x16, x15)
        x18 = lbind(shift, x2)
        x19 = mapply(x18, x17)
        O = fill(I, x1, x19)
        return O

    def solve_e40b9e2f(I):
        x1 = objects(I, F, T, T)
        x2 = neighbors(ORIGIN)
        x3 = mapply(neighbors, x2)
        x4 = first(x1)
        x5 = lbind(intersection, x4)
        x6 = compose(size, x5)
        x7 = compose(hmirror, vmirror)
        x8 = x7(x4)
        x9 = lbind(shift, x8)
        x10 = apply(x9, x3)
        x11 = argmax(x10, x6)
        x12 = paint(I, x11)
        x13 = objects(x12, F, T, T)
        x14 = first(x13)
        x15 = compose(vmirror, dmirror)
        x16 = x15(x14)
        x17 = lbind(shift, x16)
        x18 = apply(x17, x3)
        x19 = argmax(x18, x6)
        O = paint(x12, x19)
        return O

    def solve_29623171(I):
        x1 = leastcolor(I)
        x2 = interval(ZERO, NINE, FOUR)
        x3 = product(x2, x2)
        x4 = rbind(add, THREE)
        x5 = rbind(interval, ONE)
        x6 = fork(x5, identity, x4)
        x7 = compose(x6, first)
        x8 = compose(x6, last)
        x9 = fork(product, x7, x8)
        x10 = rbind(colorcount, x1)
        x11 = rbind(toobject, I)
        x12 = compose(x10, x11)
        x13 = apply(x9, x3)
        x14 = valmax(x13, x12)
        x15 = matcher(x12, x14)
        x16 = compose(flip, x15)
        x17 = mfilter(x13, x15)
        x18 = mfilter(x13, x16)
        x19 = fill(I, x1, x17)
        O = fill(x19, ZERO, x18)
        return O

    def solve_a2fd1cf0(I):
        x1 = ofcolor(I, TWO)
        x2 = ofcolor(I, THREE)
        x3 = uppermost(x1)
        x4 = leftmost(x1)
        x5 = uppermost(x2)
        x6 = leftmost(x2)
        x7 = astuple(x3, x5)
        x8 = minimum(x7)
        x9 = maximum(x7)
        x10 = astuple(x8, x6)
        x11 = astuple(x9, x6)
        x12 = connect(x10, x11)
        x13 = astuple(x4, x6)
        x14 = minimum(x13)
        x15 = maximum(x13)
        x16 = astuple(x3, x14)
        x17 = astuple(x3, x15)
        x18 = connect(x16, x17)
        x19 = combine(x12, x18)
        O = underfill(I, EIGHT, x19)
        return O

    def solve_b0c4d837(I):
        x1 = ofcolor(I, FIVE)
        x2 = ofcolor(I, EIGHT)
        x3 = height(x1)
        x4 = decrement(x3)
        x5 = height(x2)
        x6 = subtract(x4, x5)
        x7 = astuple(ONE, x6)
        x8 = canvas(EIGHT, x7)
        x9 = subtract(SIX, x6)
        x10 = astuple(ONE, x9)
        x11 = canvas(ZERO, x10)
        x12 = hconcat(x8, x11)
        x13 = hsplit(x12, TWO)
        x14 = first(x13)
        x15 = last(x13)
        x16 = vmirror(x15)
        x17 = vconcat(x14, x16)
        x18 = astuple(ONE, THREE)
        x19 = canvas(ZERO, x18)
        O = vconcat(x17, x19)
        return O

    def solve_8731374e(I):
        x1 = objects(I, T, F, F)
        x2 = argmax(x1, size)
        x3 = subgrid(x2, I)
        x4 = height(x3)
        x5 = width(x3)
        x6 = vsplit(x3, x4)
        x7 = lbind(greater, FOUR)
        x8 = compose(x7, numcolors)
        x9 = sfilter(x6, x8)
        x10 = merge(x9)
        x11 = rot90(x10)
        x12 = vsplit(x11, x5)
        x13 = sfilter(x12, x8)
        x14 = merge(x13)
        x15 = rot270(x14)
        x16 = leastcolor(x15)
        x17 = ofcolor(x15, x16)
        x18 = fork(combine, vfrontier, hfrontier)
        x19 = mapply(x18, x17)
        O = fill(x15, x16, x19)
        return O

    def solve_272f95fa(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = apply(toindices, x2)
        x4 = rbind(bordering, I)
        x5 = compose(flip, x4)
        x6 = extract(x3, x5)
        x7 = remove(x6, x3)
        x8 = lbind(vmatching, x6)
        x9 = lbind(hmatching, x6)
        x10 = sfilter(x7, x8)
        x11 = sfilter(x7, x9)
        x12 = argmin(x10, uppermost)
        x13 = argmax(x10, uppermost)
        x14 = argmin(x11, leftmost)
        x15 = argmax(x11, leftmost)
        x16 = fill(I, SIX, x6)
        x17 = fill(x16, TWO, x12)
        x18 = fill(x17, ONE, x13)
        x19 = fill(x18, FOUR, x14)
        O = fill(x19, THREE, x15)
        return O

    def solve_db93a21d(I):
        x1 = objects(I, T, T, T)
        x2 = ofcolor(I, NINE)
        x3 = colorfilter(x1, NINE)
        x4 = rbind(shoot, DOWN)
        x5 = mapply(x4, x2)
        x6 = underfill(I, ONE, x5)
        x7 = compose(halve, width)
        x8 = rbind(greater, ONE)
        x9 = compose(x8, x7)
        x10 = matcher(x7, THREE)
        x11 = power(outbox, TWO)
        x12 = power(outbox, THREE)
        x13 = mapply(outbox, x3)
        x14 = sfilter(x3, x9)
        x15 = sfilter(x3, x10)
        x16 = mapply(x11, x14)
        x17 = mapply(x12, x15)
        x18 = fill(x6, THREE, x13)
        x19 = fill(x18, THREE, x16)
        O = fill(x19, THREE, x17)
        return O

    def solve_53b68214(I):
        x1 = width(I)
        x2 = objects(I, T, T, T)
        x3 = first(x2)
        x4 = vperiod(x3)
        x5 = toivec(x4)
        x6 = interval(ZERO, NINE, ONE)
        x7 = lbind(multiply, x5)
        x8 = apply(x7, x6)
        x9 = lbind(shift, x3)
        x10 = mapply(x9, x8)
        x11 = astuple(x1, x1)
        x12 = portrait(x3)
        x13 = shape(x3)
        x14 = add(DOWN, x13)
        x15 = decrement(x14)
        x16 = shift(x3, x15)
        x17 = branch(x12, x10, x16)
        x18 = canvas(ZERO, x11)
        x19 = paint(x18, x3)
        O = paint(x19, x17)
        return O

    def solve_d6ad076f(I):
        x1 = objects(I, T, F, T)
        x2 = argmin(x1, size)
        x3 = argmax(x1, size)
        x4 = vmatching(x2, x3)
        x5 = branch(x4, DOWN, RIGHT)
        x6 = branch(x4, uppermost, leftmost)
        x7 = valmax(x1, x6)
        x8 = x6(x2)
        x9 = equality(x7, x8)
        x10 = branch(x9, NEG_ONE, ONE)
        x11 = multiply(x5, x10)
        x12 = inbox(x2)
        x13 = rbind(shoot, x11)
        x14 = mapply(x13, x12)
        x15 = underfill(I, EIGHT, x14)
        x16 = objects(x15, T, F, T)
        x17 = colorfilter(x16, EIGHT)
        x18 = rbind(bordering, I)
        x19 = mfilter(x17, x18)
        O = cover(x15, x19)
        return O

    def solve_6cdd2623(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        x3 = prapply(connect, x2, x2)
        x4 = fgpartition(I)
        x5 = merge(x4)
        x6 = cover(I, x5)
        x7 = fork(either, hline, vline)
        x8 = box(x5)
        x9 = rbind(difference, x8)
        x10 = chain(positive, size, x9)
        x11 = fork(both, x7, x10)
        x12 = mfilter(x3, x11)
        O = fill(x6, x1, x12)
        return O

    def solve_a3df8b1e(I):
        x1 = shape(I)
        x2 = ofcolor(I, ONE)
        x3 = first(x2)
        x4 = shoot(x3, UP_RIGHT)
        x5 = fill(I, ONE, x4)
        x6 = ofcolor(x5, ONE)
        x7 = urcorner(x6)
        x8 = shoot(x7, NEG_UNITY)
        x9 = fill(x5, ONE, x8)
        x10 = objects(x9, T, T, T)
        x11 = first(x10)
        x12 = subgrid(x11, x9)
        x13 = shape(x12)
        x14 = subtract(x13, DOWN)
        x15 = crop(x12, DOWN, x14)
        x16 = vconcat(x15, x15)
        x17 = vconcat(x16, x16)
        x18 = vconcat(x17, x17)
        x19 = hmirror(x18)
        x20 = crop(x19, ORIGIN, x1)
        O = hmirror(x20)
        return O

    def solve_8d510a79(I):
        x1 = ofcolor(I, ONE)
        x2 = ofcolor(I, TWO)
        x3 = ofcolor(I, FIVE)
        x4 = uppermost(x3)
        x5 = chain(toivec, decrement, double)
        x6 = lbind(greater, x4)
        x7 = compose(x6, first)
        x8 = chain(invert, x5, x7)
        x9 = fork(shoot, identity, x8)
        x10 = compose(x5, x7)
        x11 = fork(shoot, identity, x10)
        x12 = lbind(matcher, x7)
        x13 = compose(x12, x7)
        x14 = fork(sfilter, x11, x13)
        x15 = mapply(x9, x1)
        x16 = mapply(x14, x2)
        x17 = underfill(I, TWO, x16)
        O = fill(x17, ONE, x15)
        return O

    def solve_cdecee7f(I):
        x1 = objects(I, T, F, T)
        x2 = astuple(ONE, THREE)
        x3 = size(x1)
        x4 = order(x1, leftmost)
        x5 = apply(color, x4)
        x6 = rbind(canvas, UNITY)
        x7 = apply(x6, x5)
        x8 = merge(x7)
        x9 = dmirror(x8)
        x10 = subtract(NINE, x3)
        x11 = astuple(ONE, x10)
        x12 = canvas(ZERO, x11)
        x13 = hconcat(x9, x12)
        x14 = hsplit(x13, THREE)
        x15 = merge(x14)
        x16 = crop(x15, ORIGIN, x2)
        x17 = crop(x15, DOWN, x2)
        x18 = crop(x15, TWO_BY_ZERO, x2)
        x19 = vmirror(x17)
        x20 = vconcat(x16, x19)
        O = vconcat(x20, x18)
        return O

    def solve_3345333e(I):
        x1 = leastcolor(I)
        x2 = ofcolor(I, x1)
        x3 = cover(I, x2)
        x4 = leastcolor(x3)
        x5 = ofcolor(x3, x4)
        x6 = neighbors(ORIGIN)
        x7 = mapply(neighbors, x6)
        x8 = vmirror(x5)
        x9 = lbind(shift, x8)
        x10 = apply(x9, x7)
        x11 = rbind(intersection, x5)
        x12 = compose(size, x11)
        x13 = argmax(x10, x12)
        O = fill(x3, x4, x13)
        return O

    def solve_b190f7f5(I):
        x1 = portrait(I)
        x2 = branch(x1, vsplit, hsplit)
        x3 = x2(I, TWO)
        x4 = argmin(x3, numcolors)
        x5 = argmax(x3, numcolors)
        x6 = width(x5)
        x7 = rbind(repeat, x6)
        x8 = chain(dmirror, merge, x7)
        x9 = upscale(x5, x6)
        x10 = x8(x4)
        x11 = x8(x10)
        x12 = ofcolor(x11, ZERO)
        O = fill(x9, ZERO, x12)
        return O

    def solve_caa06a1f(I):
        x1 = asobject(I)
        x2 = shape(I)
        x3 = decrement(x2)
        x4 = index(I, x3)
        x5 = double(x2)
        x6 = canvas(x4, x5)
        x7 = paint(x6, x1)
        x8 = objects(x7, F, F, T)
        x9 = first(x8)
        x10 = shift(x9, LEFT)
        x11 = vperiod(x10)
        x12 = hperiod(x10)
        x13 = neighbors(ORIGIN)
        x14 = lbind(mapply, neighbors)
        x15 = power(x14, TWO)
        x16 = x15(x13)
        x17 = astuple(x11, x12)
        x18 = lbind(multiply, x17)
        x19 = apply(x18, x16)
        x20 = lbind(shift, x10)
        x21 = mapply(x20, x19)
        O = paint(I, x21)
        return O

    def solve_e21d9049(I):
        x1 = asindices(I)
        x2 = leastcolor(I)
        x3 = objects(I, T, F, T)
        x4 = ofcolor(I, x2)
        x5 = merge(x3)
        x6 = shape(x5)
        x7 = neighbors(ORIGIN)
        x8 = lbind(mapply, neighbors)
        x9 = power(x8, TWO)
        x10 = x9(x7)
        x11 = lbind(multiply, x6)
        x12 = lbind(shift, x5)
        x13 = apply(x11, x10)
        x14 = mapply(x12, x13)
        x15 = lbind(hmatching, x4)
        x16 = lbind(vmatching, x4)
        x17 = fork(either, x15, x16)
        x18 = compose(x17, initset)
        x19 = paint(I, x14)
        x20 = sfilter(x1, x18)
        x21 = difference(x1, x20)
        O = cover(x19, x21)
        return O

    def solve_d89b689b(I):
        x1 = objects(I, T, F, T)
        x2 = ofcolor(I, EIGHT)
        x3 = sizefilter(x1, ONE)
        x4 = apply(initset, x2)
        x5 = lbind(argmin, x4)
        x6 = lbind(rbind, manhattan)
        x7 = compose(x5, x6)
        x8 = fork(recolor, color, x7)
        x9 = mapply(x8, x3)
        x10 = merge(x3)
        x11 = cover(I, x10)
        O = paint(x11, x9)
        return O

    def solve_746b3537(I):
        x1 = chain(size, dedupe, first)
        x2 = x1(I)
        x3 = equality(x2, ONE)
        x4 = branch(x3, dmirror, identity)
        x5 = x4(I)
        x6 = objects(x5, T, F, F)
        x7 = order(x6, leftmost)
        x8 = apply(color, x7)
        x9 = repeat(x8, ONE)
        O = x4(x9)
        return O

    def solve_63613498(I):
        x1 = crop(I, ORIGIN, THREE_BY_THREE)
        x2 = ofcolor(x1, ZERO)
        x3 = asindices(x1)
        x4 = difference(x3, x2)
        x5 = normalize(x4)
        x6 = objects(I, T, F, T)
        x7 = compose(toindices, normalize)
        x8 = matcher(x7, x5)
        x9 = mfilter(x6, x8)
        x10 = fill(I, FIVE, x9)
        x11 = asobject(x1)
        O = paint(x10, x11)
        return O

    def solve_06df4c85(I):
        x1 = partition(I)
        x2 = mostcolor(I)
        x3 = ofcolor(I, x2)
        x4 = colorfilter(x1, ZERO)
        x5 = argmax(x1, size)
        x6 = difference(x1, x4)
        x7 = remove(x5, x6)
        x8 = merge(x7)
        x9 = product(x8, x8)
        x10 = power(first, TWO)
        x11 = compose(first, last)
        x12 = fork(equality, x10, x11)
        x13 = sfilter(x9, x12)
        x14 = compose(last, first)
        x15 = power(last, TWO)
        x16 = fork(connect, x14, x15)
        x17 = fork(recolor, color, x16)
        x18 = apply(x17, x13)
        x19 = fork(either, vline, hline)
        x20 = mfilter(x18, x19)
        x21 = paint(I, x20)
        O = fill(x21, x2, x3)
        return O

    def solve_f9012d9b(I):
        x1 = objects(I, T, F, F)
        x2 = ofcolor(I, ZERO)
        x3 = lbind(contained, ZERO)
        x4 = chain(flip, x3, palette)
        x5 = mfilter(x1, x4)
        x6 = vsplit(I, TWO)
        x7 = hsplit(I, TWO)
        x8 = extract(x6, x4)
        x9 = extract(x7, x4)
        x10 = asobject(x8)
        x11 = asobject(x9)
        x12 = vperiod(x10)
        x13 = hperiod(x11)
        x14 = neighbors(ORIGIN)
        x15 = mapply(neighbors, x14)
        x16 = astuple(x12, x13)
        x17 = rbind(multiply, x16)
        x18 = apply(x17, x15)
        x19 = lbind(shift, x5)
        x20 = mapply(x19, x18)
        x21 = paint(I, x20)
        O = subgrid(x2, x21)
        return O

    def solve_4522001f(I):
        x1 = objects(I, F, F, T)
        x2 = first(x1)
        x3 = toindices(x2)
        x4 = contained(ZERO_BY_TWO, x3)
        x5 = contained(TWO_BY_TWO, x3)
        x6 = contained(TWO_BY_ZERO, x3)
        x7 = astuple(NINE, NINE)
        x8 = canvas(ZERO, x7)
        x9 = astuple(THREE, ORIGIN)
        x10 = initset(x9)
        x11 = upscale(x10, TWO)
        x12 = upscale(x11, TWO)
        x13 = shape(x12)
        x14 = shift(x12, x13)
        x15 = combine(x12, x14)
        x16 = paint(x8, x15)
        x17 = rot90(x16)
        x18 = rot180(x16)
        x19 = rot270(x16)
        x20 = branch(x4, x17, x16)
        x21 = branch(x5, x18, x20)
        O = branch(x6, x19, x21)
        return O

    def solve_a48eeaf7(I):
        x1 = ofcolor(I, TWO)
        x2 = outbox(x1)
        x3 = apply(initset, x2)
        x4 = ofcolor(I, FIVE)
        x5 = lbind(argmin, x3)
        x6 = lbind(lbind, manhattan)
        x7 = compose(x6, initset)
        x8 = compose(x5, x7)
        x9 = mapply(x8, x4)
        x10 = cover(I, x4)
        O = fill(x10, FIVE, x9)
        return O

    def solve_eb5a1d5d(I):
        x1 = compose(dmirror, dedupe)
        x2 = x1(I)
        x3 = x1(x2)
        x4 = fork(remove, last, identity)
        x5 = compose(hmirror, x4)
        x6 = fork(vconcat, identity, x5)
        x7 = x6(x3)
        x8 = dmirror(x7)
        O = x6(x8)
        return O

    def solve_e179c5f4(I):
        x1 = height(I)
        x2 = ofcolor(I, ONE)
        x3 = first(x2)
        x4 = shoot(x3, UP_RIGHT)
        x5 = fill(I, ONE, x4)
        x6 = ofcolor(x5, ONE)
        x7 = urcorner(x6)
        x8 = shoot(x7, NEG_UNITY)
        x9 = fill(x5, ONE, x8)
        x10 = ofcolor(x9, ONE)
        x11 = subgrid(x10, x9)
        x12 = height(x11)
        x13 = width(x11)
        x14 = decrement(x12)
        x15 = astuple(x14, x13)
        x16 = ulcorner(x10)
        x17 = crop(x9, x16, x15)
        x18 = repeat(x17, NINE)
        x19 = merge(x18)
        x20 = astuple(x1, x13)
        x21 = crop(x19, ORIGIN, x20)
        x22 = hmirror(x21)
        O = replace(x22, ZERO, EIGHT)
        return O

    def solve_228f6490(I):
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, ZERO)
        x3 = rbind(bordering, I)
        x4 = compose(flip, x3)
        x5 = sfilter(x2, x4)
        x6 = first(x5)
        x7 = last(x5)
        x8 = difference(x1, x2)
        x9 = compose(normalize, toindices)
        x10 = x9(x6)
        x11 = x9(x7)
        x12 = matcher(x9, x10)
        x13 = matcher(x9, x11)
        x14 = extract(x8, x12)
        x15 = extract(x8, x13)
        x16 = ulcorner(x6)
        x17 = ulcorner(x7)
        x18 = ulcorner(x14)
        x19 = ulcorner(x15)
        x20 = subtract(x16, x18)
        x21 = subtract(x17, x19)
        x22 = move(I, x14, x20)
        O = move(x22, x15, x21)
        return O

    def solve_995c5fa3(I):
        x1 = hsplit(I, THREE)
        x2 = astuple(TWO, ONE)
        x3 = rbind(ofcolor, ZERO)
        x4 = compose(ulcorner, x3)
        x5 = compose(size, x3)
        x6 = matcher(x5, ZERO)
        x7 = matcher(x4, UNITY)
        x8 = matcher(x4, DOWN)
        x9 = matcher(x4, x2)
        x10 = rbind(multiply, THREE)
        x11 = power(double, TWO)
        x12 = compose(double, x6)
        x13 = chain(x11, double, x7)
        x14 = compose(x10, x8)
        x15 = compose(x11, x9)
        x16 = fork(add, x12, x13)
        x17 = fork(add, x14, x15)
        x18 = fork(add, x16, x17)
        x19 = rbind(canvas, UNITY)
        x20 = compose(x19, x18)
        x21 = apply(x20, x1)
        x22 = merge(x21)
        O = hupscale(x22, THREE)
        return O

    def solve_d06dbe63(I):
        x1 = ofcolor(I, EIGHT)
        x2 = center(x1)
        x3 = connect(ORIGIN, DOWN)
        x4 = connect(ORIGIN, ZERO_BY_TWO)
        x5 = combine(x3, x4)
        x6 = subtract(x2, TWO_BY_ZERO)
        x7 = shift(x5, x6)
        x8 = astuple(NEG_TWO, TWO)
        x9 = interval(ZERO, FIVE, ONE)
        x10 = lbind(multiply, x8)
        x11 = apply(x10, x9)
        x12 = lbind(shift, x7)
        x13 = mapply(x12, x11)
        x14 = fill(I, FIVE, x13)
        x15 = rot180(x14)
        x16 = ofcolor(x15, EIGHT)
        x17 = center(x16)
        x18 = subtract(x17, x6)
        x19 = shift(x13, x18)
        x20 = toivec(NEG_TWO)
        x21 = shift(x19, x20)
        x22 = fill(x15, FIVE, x21)
        O = rot180(x22)
        return O

    def solve_36fdfd69(I):
        x1 = upscale(I, TWO)
        x2 = objects(x1, T, T, T)
        x3 = colorfilter(x2, TWO)
        x4 = fork(manhattan, first, last)
        x5 = lbind(greater, FIVE)
        x6 = compose(x5, x4)
        x7 = product(x3, x3)
        x8 = sfilter(x7, x6)
        x9 = apply(merge, x8)
        x10 = mapply(delta, x9)
        x11 = fill(x1, FOUR, x10)
        x12 = merge(x3)
        x13 = paint(x11, x12)
        O = downscale(x13, TWO)
        return O

    def solve_0a938d79(I):
        x1 = portrait(I)
        x2 = branch(x1, dmirror, identity)
        x3 = x2(I)
        x4 = fgpartition(x3)
        x5 = merge(x4)
        x6 = chain(double, decrement, width)
        x7 = x6(x5)
        x8 = compose(vfrontier, tojvec)
        x9 = lbind(mapply, x8)
        x10 = rbind(interval, x7)
        x11 = width(x3)
        x12 = rbind(x10, x11)
        x13 = chain(x9, x12, leftmost)
        x14 = fork(recolor, color, x13)
        x15 = mapply(x14, x4)
        x16 = paint(x3, x15)
        O = x2(x16)
        return O

    def solve_045e512c(I):
        x1 = objects(I, T, T, T)
        x2 = argmax(x1, size)
        x3 = remove(x2, x1)
        x4 = lbind(shift, x2)
        x5 = lbind(mapply, x4)
        x6 = double(TEN)
        x7 = interval(FOUR, x6, FOUR)
        x8 = rbind(apply, x7)
        x9 = lbind(position, x2)
        x10 = lbind(rbind, multiply)
        x11 = chain(x8, x10, x9)
        x12 = compose(x5, x11)
        x13 = fork(recolor, color, x12)
        x14 = mapply(x13, x3)
        O = paint(I, x14)
        return O

    def solve_82819916(I):
        x1 = objects(I, F, T, T)
        x2 = argmax(x1, size)
        x3 = remove(x2, x1)
        x4 = normalize(x2)
        x5 = compose(last, last)
        x6 = rbind(argmin, x5)
        x7 = compose(first, x6)
        x8 = fork(other, palette, x7)
        x9 = x7(x4)
        x10 = matcher(first, x9)
        x11 = sfilter(x4, x10)
        x12 = difference(x4, x11)
        x13 = compose(toivec, uppermost)
        x14 = lbind(shift, x11)
        x15 = lbind(shift, x12)
        x16 = compose(x14, x13)
        x17 = compose(x15, x13)
        x18 = fork(recolor, x7, x16)
        x19 = fork(recolor, x8, x17)
        x20 = fork(combine, x18, x19)
        x21 = mapply(x20, x3)
        O = paint(I, x21)
        return O

    def solve_99fa7670(I):
        x1 = shape(I)
        x2 = objects(I, T, F, T)
        x3 = rbind(shoot, RIGHT)
        x4 = compose(x3, center)
        x5 = fork(recolor, color, x4)
        x6 = mapply(x5, x2)
        x7 = paint(I, x6)
        x8 = add(x1, DOWN_LEFT)
        x9 = initset(x8)
        x10 = recolor(ZERO, x9)
        x11 = objects(x7, T, F, T)
        x12 = insert(x10, x11)
        x13 = order(x12, uppermost)
        x14 = first(x13)
        x15 = remove(x10, x13)
        x16 = remove(x14, x13)
        x17 = compose(lrcorner, first)
        x18 = compose(lrcorner, last)
        x19 = fork(connect, x17, x18)
        x20 = compose(color, first)
        x21 = fork(recolor, x20, x19)
        x22 = pair(x15, x16)
        x23 = mapply(x21, x22)
        O = underpaint(x7, x23)
        return O

    def solve_72322fa7(I):
        x1 = objects(I, F, T, T)
        x2 = matcher(numcolors, ONE)
        x3 = sfilter(x1, x2)
        x4 = difference(x1, x3)
        x5 = lbind(matcher, first)
        x6 = compose(x5, mostcolor)
        x7 = fork(sfilter, identity, x6)
        x8 = fork(difference, identity, x7)
        x9 = lbind(occurrences, I)
        x10 = compose(x9, x7)
        x11 = compose(x9, x8)
        x12 = compose(ulcorner, x8)
        x13 = fork(subtract, ulcorner, x12)
        x14 = lbind(rbind, add)
        x15 = compose(x14, x13)
        x16 = fork(apply, x15, x11)
        x17 = lbind(lbind, shift)
        x18 = compose(x17, normalize)
        x19 = fork(mapply, x18, x10)
        x20 = fork(mapply, x18, x16)
        x21 = mapply(x19, x4)
        x22 = mapply(x20, x4)
        x23 = paint(I, x21)
        O = paint(x23, x22)
        return O

    def solve_855e0971(I):
        x1 = rot90(I)
        x2 = frontiers(I)
        x3 = sfilter(x2, hline)
        x4 = size(x3)
        x6 = positive(x4)
        x7 = branch(x6, identity, dmirror)
        x8 = x7(I)
        x9 = rbind(subgrid, x8)
        x10 = matcher(color, ZERO)
        x11 = compose(flip, x10)
        x12 = partition(x8)
        x13 = sfilter(x12, x11)
        x14 = rbind(ofcolor, ZERO)
        x15 = lbind(mapply, vfrontier)
        x16 = chain(x15, x14, x9)
        x17 = fork(shift, x16, ulcorner)
        x18 = fork(intersection, toindices, x17)
        x19 = mapply(x18, x13)
        x20 = fill(x8, ZERO, x19)
        O = x7(x20)
        return O

    def solve_a78176bb(I):
        x1 = palette(I)
        x2 = objects(I, T, F, T)
        x3 = remove(ZERO, x1)
        x4 = other(x3, FIVE)
        x5 = colorfilter(x2, FIVE)
        x6 = lbind(index, I)
        x7 = compose(x6, urcorner)
        x8 = matcher(x7, FIVE)
        x9 = sfilter(x5, x8)
        x10 = difference(x5, x9)
        x11 = apply(urcorner, x9)
        x12 = apply(llcorner, x10)
        x13 = rbind(add, UP_RIGHT)
        x14 = rbind(add, DOWN_LEFT)
        x15 = apply(x13, x11)
        x16 = apply(x14, x12)
        x17 = rbind(shoot, UNITY)
        x18 = rbind(shoot, NEG_UNITY)
        x19 = fork(combine, x17, x18)
        x20 = mapply(x19, x15)
        x21 = mapply(x19, x16)
        x22 = combine(x20, x21)
        x23 = fill(I, x4, x22)
        O = replace(x23, FIVE, ZERO)
        return O

    def solve_952a094c(I):
        x1 = objects(I, T, F, T)
        x2 = sizefilter(x1, ONE)
        x3 = argmax(x1, size)
        x4 = outbox(x3)
        x5 = corners(x4)
        x6 = lbind(rbind, manhattan)
        x7 = lbind(argmax, x2)
        x8 = chain(x7, x6, initset)
        x9 = compose(color, x8)
        x10 = fork(astuple, x9, identity)
        x11 = apply(x10, x5)
        x12 = merge(x2)
        x13 = cover(I, x12)
        O = paint(x13, x11)
        return O

    def solve_6d58a25d(I):
        x1 = objects(I, T, T, T)
        x2 = argmax(x1, size)
        x3 = remove(x2, x1)
        x4 = merge(x3)
        x5 = color(x4)
        x6 = uppermost(x2)
        x7 = rbind(greater, x6)
        x8 = compose(x7, uppermost)
        x9 = rbind(vmatching, x2)
        x10 = fork(both, x9, x8)
        x11 = sfilter(x3, x10)
        x12 = increment(x6)
        x13 = rbind(greater, x12)
        x14 = compose(x13, first)
        x15 = rbind(sfilter, x14)
        x16 = chain(x15, vfrontier, center)
        x17 = mapply(x16, x11)
        O = underfill(I, x5, x17)
        return O

    def solve_6aa20dc0(I):
        x1 = objects(I, F, T, T)
        x2 = argmax(x1, numcolors)
        x3 = normalize(x2)
        x4 = lbind(matcher, first)
        x5 = compose(x4, mostcolor)
        x6 = fork(sfilter, identity, x5)
        x7 = fork(difference, identity, x6)
        x8 = lbind(rbind, upscale)
        x9 = interval(ONE, FOUR, ONE)
        x10 = apply(x8, x9)
        x11 = initset(identity)
        x12 = insert(vmirror, x11)
        x13 = insert(hmirror, x12)
        x14 = insert(cmirror, x13)
        x15 = insert(dmirror, x14)
        x16 = fork(compose, first, last)
        x17 = lbind(occurrences, I)
        x18 = lbind(lbind, shift)
        x19 = compose(x17, x7)
        x20 = product(x15, x10)
        x21 = apply(x16, x20)
        x22 = rapply(x21, x3)
        x23 = fork(mapply, x18, x19)
        x24 = mapply(x23, x22)
        O = paint(I, x24)
        return O

    def solve_e6721834(I):
        x1 = portrait(I)
        x2 = branch(x1, vsplit, hsplit)
        x3 = x2(I, TWO)
        x4 = order(x3, numcolors)
        x5 = first(x4)
        x6 = last(x4)
        x7 = objects(x6, F, F, T)
        x8 = merge(x7)
        x9 = mostcolor(x8)
        x10 = matcher(first, x9)
        x11 = compose(flip, x10)
        x12 = rbind(sfilter, x11)
        x13 = lbind(occurrences, x5)
        x14 = compose(x13, x12)
        x15 = chain(positive, size, x14)
        x16 = sfilter(x7, x15)
        x17 = chain(first, x13, x12)
        x18 = compose(ulcorner, x12)
        x19 = fork(subtract, x17, x18)
        x20 = fork(shift, identity, x19)
        x21 = apply(x20, x16)
        x22 = compose(decrement, width)
        x23 = chain(positive, decrement, x22)
        x24 = mfilter(x21, x23)
        O = paint(x5, x24)
        return O

    def solve_447fd412(I):
        x1 = objects(I, F, T, T)
        x2 = argmax(x1, numcolors)
        x3 = normalize(x2)
        x4 = lbind(matcher, first)
        x5 = compose(x4, mostcolor)
        x6 = fork(sfilter, identity, x5)
        x7 = fork(difference, identity, x6)
        x8 = lbind(rbind, upscale)
        x9 = interval(ONE, FOUR, ONE)
        x10 = apply(x8, x9)
        x11 = lbind(recolor, ZERO)
        x12 = compose(x11, outbox)
        x13 = fork(combine, identity, x12)
        x14 = lbind(occurrences, I)
        x15 = lbind(rbind, subtract)
        x16 = lbind(apply, increment)
        x17 = lbind(lbind, shift)
        x18 = chain(x15, ulcorner, x7)
        x19 = chain(x14, x13, x7)
        x20 = fork(apply, x18, x19)
        x21 = compose(x16, x20)
        x22 = fork(mapply, x17, x21)
        x23 = rapply(x10, x3)
        x24 = mapply(x22, x23)
        O = paint(I, x24)
        return O

    def solve_2bcee788(I):
        x1 = mostcolor(I)
        x2 = objects(I, T, F, T)
        x3 = replace(I, x1, THREE)
        x4 = argmax(x2, size)
        x5 = argmin(x2, size)
        x6 = position(x4, x5)
        x7 = first(x6)
        x8 = last(x6)
        x9 = subgrid(x4, x3)
        x10 = hline(x5)
        x11 = hmirror(x9)
        x12 = vmirror(x9)
        x13 = branch(x10, x11, x12)
        x14 = branch(x10, x7, ZERO)
        x15 = branch(x10, ZERO, x8)
        x16 = asobject(x13)
        x17 = matcher(first, THREE)
        x18 = compose(flip, x17)
        x19 = sfilter(x16, x18)
        x20 = ulcorner(x4)
        x21 = shape(x4)
        x22 = astuple(x14, x15)
        x23 = multiply(x21, x22)
        x24 = add(x20, x23)
        x25 = shift(x19, x24)
        O = paint(x3, x25)
        return O

    def solve_776ffc46(I):
        x1 = objects(I, T, F, T)
        x2 = colorfilter(x1, FIVE)
        x3 = fork(equality, toindices, box)
        x4 = extract(x2, x3)
        x5 = inbox(x4)
        x6 = subgrid(x5, I)
        x7 = asobject(x6)
        x8 = matcher(first, ZERO)
        x9 = compose(flip, x8)
        x10 = sfilter(x7, x9)
        x11 = normalize(x10)
        x12 = toindices(x11)
        x13 = compose(toindices, normalize)
        x14 = matcher(x13, x12)
        x15 = mfilter(x1, x14)
        x16 = color(x11)
        O = fill(I, x16, x15)
        return O

    def solve_f35d900a(I):
        x1 = objects(I, T, F, T)
        x2 = palette(I)
        x3 = remove(ZERO, x2)
        x4 = lbind(other, x3)
        x5 = compose(x4, color)
        x6 = fork(recolor, x5, outbox)
        x7 = mapply(x6, x1)
        x8 = mapply(toindices, x1)
        x9 = box(x8)
        x10 = difference(x9, x8)
        x11 = lbind(argmin, x8)
        x12 = rbind(compose, initset)
        x13 = lbind(rbind, manhattan)
        x14 = chain(x12, x13, initset)
        x15 = chain(initset, x11, x14)
        x16 = fork(manhattan, initset, x15)
        x17 = compose(even, x16)
        x18 = sfilter(x10, x17)
        x19 = paint(I, x7)
        O = fill(x19, FIVE, x18)
        return O

    def solve_0dfd9992(I):
        x1 = height(I)
        x2 = width(I)
        x3 = partition(I)
        x4 = colorfilter(x3, ZERO)
        x5 = difference(x3, x4)
        x6 = merge(x5)
        x7 = astuple(x1, ONE)
        x8 = astuple(ONE, x2)
        x9 = decrement(x1)
        x10 = decrement(x2)
        x11 = toivec(x10)
        x12 = tojvec(x9)
        x13 = crop(I, x11, x8)
        x14 = crop(I, x12, x7)
        x15 = asobject(x14)
        x16 = asobject(x13)
        x17 = vperiod(x15)
        x18 = hperiod(x16)
        x19 = astuple(x17, x18)
        x20 = lbind(multiply, x19)
        x21 = neighbors(ORIGIN)
        x22 = mapply(neighbors, x21)
        x23 = apply(x20, x22)
        x24 = lbind(shift, x6)
        x25 = mapply(x24, x23)
        O = paint(I, x25)
        return O

    def solve_29ec7d0e(I):
        x1 = height(I)
        x2 = width(I)
        x3 = partition(I)
        x4 = colorfilter(x3, ZERO)
        x5 = difference(x3, x4)
        x6 = merge(x5)
        x7 = astuple(x1, ONE)
        x8 = astuple(ONE, x2)
        x9 = decrement(x1)
        x10 = decrement(x2)
        x11 = toivec(x10)
        x12 = tojvec(x9)
        x13 = crop(I, x11, x8)
        x14 = crop(I, x12, x7)
        x15 = asobject(x14)
        x16 = asobject(x13)
        x17 = vperiod(x15)
        x18 = hperiod(x16)
        x19 = astuple(x17, x18)
        x20 = lbind(multiply, x19)
        x21 = neighbors(ORIGIN)
        x22 = mapply(neighbors, x21)
        x23 = apply(x20, x22)
        x24 = lbind(shift, x6)
        x25 = mapply(x24, x23)
        O = paint(I, x25)
        return O

    def solve_36d67576(I):
        x1 = objects(I, F, F, T)
        x2 = argmax(x1, numcolors)
        x3 = astuple(TWO, FOUR)
        x4 = rbind(contained, x3)
        x5 = compose(x4, first)
        x6 = rbind(sfilter, x5)
        x7 = lbind(rbind, subtract)
        x8 = lbind(occurrences, I)
        x9 = lbind(lbind, shift)
        x10 = compose(x7, ulcorner)
        x11 = chain(x10, x6, normalize)
        x12 = chain(x8, x6, normalize)
        x13 = fork(apply, x11, x12)
        x14 = compose(x9, normalize)
        x15 = fork(mapply, x14, x13)
        x16 = astuple(cmirror, dmirror)
        x17 = astuple(hmirror, vmirror)
        x18 = combine(x16, x17)
        x19 = product(x18, x18)
        x20 = fork(compose, first, last)
        x21 = apply(x20, x19)
        x22 = totuple(x21)
        x23 = combine(x18, x22)
        x24 = rapply(x23, x2)
        x25 = mapply(x15, x24)
        O = paint(I, x25)
        return O

    def solve_98cf29f8(I):
        x1 = fgpartition(I)
        x2 = fork(multiply, height, width)
        x3 = fork(equality, size, x2)
        x4 = extract(x1, x3)
        x5 = other(x1, x4)
        x6 = color(x5)
        x7 = rbind(greater, THREE)
        x8 = rbind(toobject, I)
        x9 = rbind(colorcount, x6)
        x10 = chain(x8, ineighbors, last)
        x11 = chain(x7, x9, x10)
        x12 = sfilter(x5, x11)
        x13 = outbox(x12)
        x14 = backdrop(x13)
        x15 = cover(I, x5)
        x16 = gravitate(x14, x4)
        x17 = shift(x14, x16)
        O = fill(x15, x6, x17)
        return O

    def solve_469497ad(I):
        x1 = numcolors(I)
        x2 = decrement(x1)
        x3 = upscale(I, x2)
        x4 = objects(x3, F, F, T)
        x5 = argmin(x4, size)
        x6 = ulcorner(x5)
        x7 = llcorner(x5)
        x8 = shoot(x6, NEG_UNITY)
        x9 = shoot(x6, UNITY)
        x10 = shoot(x7, DOWN_LEFT)
        x11 = shoot(x7, UP_RIGHT)
        x12 = combine(x8, x9)
        x13 = combine(x10, x11)
        x14 = combine(x12, x13)
        x15 = underfill(x3, TWO, x14)
        x16 = objects(x15, T, F, T)
        x17 = argmax(x16, lrcorner)
        O = paint(x15, x17)
        return O

    def solve_39e1d7f9(I):
        x1 = fgpartition(I)
        x2 = objects(I, T, F, T)
        x3 = order(x1, height)
        x4 = last(x3)
        x5 = remove(x4, x3)
        x6 = last(x5)
        x7 = color(x6)
        x8 = colorfilter(x2, x7)
        x9 = power(outbox, TWO)
        x10 = rbind(toobject, I)
        x11 = mostcolor(I)
        x12 = lbind(remove, x11)
        x13 = chain(size, x12, palette)
        x14 = chain(x13, x10, x9)
        x15 = argmax(x8, x14)
        x16 = ulcorner(x15)
        x17 = shape(x15)
        x18 = subtract(x16, x17)
        x19 = decrement(x18)
        x20 = multiply(x17, THREE)
        x21 = add(x20, TWO_BY_TWO)
        x22 = crop(I, x19, x21)
        x23 = asobject(x22)
        x24 = apply(ulcorner, x8)
        x25 = increment(x17)
        x26 = rbind(subtract, x25)
        x27 = apply(x26, x24)
        x28 = lbind(shift, x23)
        x29 = mapply(x28, x27)
        O = paint(I, x29)
        return O

    def solve_484b58aa(I):
        x1 = height(I)
        x2 = width(I)
        x3 = partition(I)
        x4 = colorfilter(x3, ZERO)
        x5 = difference(x3, x4)
        x6 = merge(x5)
        x7 = astuple(x1, TWO)
        x8 = astuple(TWO, x2)
        x9 = power(decrement, TWO)
        x10 = x9(x1)
        x11 = x9(x2)
        x12 = toivec(x11)
        x13 = tojvec(x10)
        x14 = crop(I, x12, x8)
        x15 = crop(I, x13, x7)
        x16 = asobject(x15)
        x17 = asobject(x14)
        x18 = vperiod(x16)
        x19 = hperiod(x17)
        x20 = astuple(x18, x19)
        x21 = lbind(multiply, x20)
        x22 = neighbors(ORIGIN)
        x23 = mapply(neighbors, x22)
        x24 = apply(x21, x23)
        x25 = lbind(shift, x6)
        x26 = mapply(x25, x24)
        O = paint(I, x26)
        return O

    def solve_3befdf3e(I):
        x1 = objects(I, F, F, T)
        x2 = leastcolor(I)
        x3 = palette(I)
        x4 = remove(ZERO, x3)
        x5 = other(x4, x2)
        x6 = switch(I, x2, x5)
        x7 = compose(width, inbox)
        x8 = lbind(power, outbox)
        x9 = compose(x8, x7)
        x10 = initset(x9)
        x11 = lbind(rapply, x10)
        x12 = chain(initset, first, x11)
        x13 = fork(rapply, x12, identity)
        x14 = compose(first, x13)
        x15 = compose(backdrop, x14)
        x16 = lbind(chain, backdrop)
        x17 = lbind(x16, inbox)
        x18 = compose(x17, x9)
        x19 = lbind(apply, initset)
        x20 = chain(x19, corners, x15)
        x21 = fork(mapply, x18, x20)
        x22 = fork(intersection, x15, x21)
        x23 = mapply(x15, x1)
        x24 = mapply(x22, x1)
        x25 = underfill(x6, x5, x23)
        O = fill(x25, ZERO, x24)
        return O

    def solve_9aec4887(I):
        x1 = objects(I, F, T, T)
        x2 = argmin(x1, numcolors)
        x3 = other(x1, x2)
        x4 = subgrid(x3, I)
        x5 = normalize(x2)
        x6 = shift(x5, UNITY)
        x7 = toindices(x6)
        x8 = normalize(x3)
        x9 = lbind(argmin, x8)
        x11 = lbind(rbind, manhattan)
        x12 = rbind(compose, initset)
        x13 = chain(x12, x11, initset)
        x14 = chain(first, x9, x13)
        x15 = fork(astuple, x14, identity)
        x16 = apply(x15, x7)
        x17 = paint(x4, x16)
        x18 = fork(connect, ulcorner, lrcorner)
        x19 = x18(x7)
        x20 = fork(combine, identity, vmirror)
        x21 = x20(x19)
        x22 = intersection(x7, x21)
        O = fill(x17, EIGHT, x22)
        return O

    def solve_49d1d64f(I):
        x1 = shape(I)
        x2 = add(x1, TWO)
        x3 = canvas(ZERO, x2)
        x4 = asobject(I)
        x5 = shift(x4, UNITY)
        x6 = paint(x3, x5)
        x7 = asindices(x3)
        x8 = fork(difference, box, corners)
        x9 = x8(x7)
        x10 = lbind(lbind, manhattan)
        x11 = rbind(compose, initset)
        x12 = chain(x11, x10, initset)
        x13 = lbind(argmin, x5)
        x14 = chain(first, x13, x12)
        x15 = fork(astuple, x14, identity)
        x16 = apply(x15, x9)
        O = paint(x6, x16)
        return O

    def solve_57aa92db(I):
        x1 = objects(I, F, T, T)
        x2 = objects(I, T, F, T)
        x3 = lbind(lbind, colorcount)
        x4 = fork(apply, x3, palette)
        x5 = compose(maximum, x4)
        x6 = compose(minimum, x4)
        x7 = fork(subtract, x5, x6)
        x8 = argmax(x1, x7)
        x9 = leastcolor(x8)
        x10 = normalize(x8)
        x11 = matcher(first, x9)
        x12 = sfilter(x10, x11)
        x13 = ulcorner(x12)
        x14 = colorfilter(x2, x9)
        x15 = rbind(toobject, I)
        x16 = lbind(remove, ZERO)
        x17 = chain(first, x16, palette)
        x18 = chain(x17, x15, outbox)
        x19 = lbind(multiply, x13)
        x20 = compose(x19, width)
        x21 = fork(subtract, ulcorner, x20)
        x22 = lbind(shift, x10)
        x23 = compose(x22, x21)
        x24 = fork(upscale, x23, width)
        x25 = fork(recolor, x18, x24)
        x26 = mapply(x25, x14)
        x27 = paint(I, x26)
        x28 = merge(x2)
        O = paint(x27, x28)
        return O

    def solve_aba27056(I):
        x1 = objects(I, T, F, T)
        x2 = mapply(toindices, x1)
        x3 = box(x2)
        x4 = difference(x3, x2)
        x5 = delta(x2)
        x6 = position(x5, x4)
        x7 = interval(ZERO, NINE, ONE)
        x8 = lbind(multiply, x6)
        x9 = apply(x8, x7)
        x10 = lbind(shift, x4)
        x11 = mapply(x10, x9)
        x12 = fill(I, FOUR, x5)
        x13 = fill(x12, FOUR, x11)
        x14 = corners(x4)
        x15 = ofcolor(x13, ZERO)
        x16 = rbind(toobject, x13)
        x17 = rbind(colorcount, ZERO)
        x18 = chain(x17, x16, dneighbors)
        x19 = matcher(x18, TWO)
        x20 = rbind(adjacent, x2)
        x21 = rbind(adjacent, x11)
        x22 = fork(both, x20, x21)
        x23 = compose(x22, initset)
        x24 = sfilter(x15, x19)
        x25 = sfilter(x24, x23)
        x26 = product(x14, x25)
        x27 = fork(subtract, last, first)
        x28 = fork(shoot, first, x27)
        x29 = mapply(x28, x26)
        O = fill(x13, FOUR, x29)
        return O

    def solve_f1cefba8(I):
        x1 = palette(I)
        x2 = objects(I, F, F, T)
        x3 = ofcolor(I, ZERO)
        x4 = first(x2)
        x5 = ulcorner(x4)
        x6 = subgrid(x4, I)
        x7 = power(trim, TWO)
        x8 = x7(x6)
        x9 = asindices(x8)
        x10 = shift(x9, TWO_BY_TWO)
        x11 = fill(x6, ZERO, x10)
        x12 = leastcolor(x11)
        x13 = remove(ZERO, x1)
        x14 = other(x13, x12)
        x15 = ofcolor(x11, x12)
        x16 = shift(x15, x5)
        x17 = ofcolor(I, x12)
        x18 = uppermost(x17)
        x19 = lowermost(x17)
        x20 = matcher(first, x18)
        x21 = matcher(first, x19)
        x22 = fork(either, x20, x21)
        x23 = sfilter(x16, x22)
        x24 = difference(x16, x23)
        x25 = mapply(vfrontier, x23)
        x26 = mapply(hfrontier, x24)
        x27 = combine(x25, x26)
        x28 = intersection(x3, x27)
        x29 = fill(I, x14, x27)
        O = fill(x29, x12, x28)
        return O

    def solve_1e32b0e9(I):
        x1 = height(I)
        x2 = mostcolor(I)
        x3 = asobject(I)
        x4 = subtract(x1, TWO)
        x5 = divide(x4, THREE)
        x6 = astuple(x5, x5)
        x7 = crop(I, ORIGIN, x6)
        x8 = partition(x7)
        x9 = matcher(color, ZERO)
        x10 = compose(flip, x9)
        x11 = extract(x8, x10)
        x12 = initset(x2)
        x13 = palette(x3)
        x14 = palette(x11)
        x15 = difference(x13, x14)
        x16 = difference(x15, x12)
        x17 = first(x16)
        x18 = interval(ZERO, THREE, ONE)
        x19 = product(x18, x18)
        x20 = totuple(x19)
        x21 = apply(first, x20)
        x22 = apply(last, x20)
        x23 = lbind(multiply, x5)
        x24 = apply(x23, x21)
        x25 = apply(x23, x22)
        x26 = papply(add, x24, x21)
        x27 = papply(add, x25, x22)
        x28 = papply(astuple, x26, x27)
        x29 = lbind(shift, x11)
        x30 = mapply(x29, x28)
        O = underfill(I, x17, x30)
        return O

    def solve_28e73c20(I):
        x1 = width(I)
        x2 = astuple(ONE, TWO)
        x3 = astuple(TWO, TWO)
        x4 = astuple(TWO, ONE)
        x5 = astuple(THREE, ONE)
        x6 = canvas(THREE, UNITY)
        x7 = upscale(x6, FOUR)
        x8 = initset(DOWN)
        x9 = insert(UNITY, x8)
        x10 = insert(x2, x9)
        x11 = insert(x3, x10)
        x12 = fill(x7, ZERO, x11)
        x13 = vupscale(x6, FIVE)
        x14 = hupscale(x13, THREE)
        x15 = insert(x4, x9)
        x16 = insert(x5, x15)
        x17 = fill(x14, ZERO, x16)
        x18 = even(x1)
        x19 = branch(x18, x12, x17)
        x20 = canvas(ZERO, UNITY)
        x21 = lbind(hupscale, x20)
        x22 = chain(x21, decrement, height)
        x23 = rbind(hconcat, x6)
        x24 = compose(x23, x22)
        x25 = lbind(hupscale, x6)
        x26 = compose(x25, height)
        x27 = fork(vconcat, x24, rot90)
        x28 = fork(vconcat, x26, x27)
        x29 = subtract(x1, FOUR)
        x30 = power(x28, x29)
        O = x30(x19)
        return O

    def solve_4c5c2cf0(I):
        x1 = objects(I, T, T, T)
        x2 = objects(I, F, T, T)
        x3 = first(x2)
        x4 = rbind(subgrid, I)
        x5 = fork(equality, identity, rot90)
        x6 = compose(x5, x4)
        x7 = extract(x1, x6)
        x8 = center(x7)
        x9 = subgrid(x3, I)
        x10 = hmirror(x9)
        x11 = objects(x10, F, T, T)
        x12 = first(x11)
        x13 = objects(x10, T, T, T)
        x14 = rbind(subgrid, x10)
        x15 = compose(x5, x14)
        x16 = extract(x13, x15)
        x17 = center(x16)
        x18 = subtract(x8, x17)
        x19 = shift(x12, x18)
        x20 = paint(I, x19)
        x21 = objects(x20, F, T, T)
        x22 = first(x21)
        x23 = subgrid(x22, x20)
        x24 = vmirror(x23)
        x25 = objects(x24, F, T, T)
        x26 = first(x25)
        x27 = objects(x24, T, T, T)
        x28 = color(x7)
        x29 = matcher(color, x28)
        x30 = extract(x27, x29)
        x31 = center(x30)
        x32 = subtract(x8, x31)
        x33 = shift(x26, x32)
        O = paint(x20, x33)
        return O

    def solve_508bd3b6(I):
        x1 = width(I)
        x2 = objects(I, T, T, T)
        x3 = argmin(x2, size)
        x4 = argmax(x2, size)
        x5 = ulcorner(x3)
        x6 = urcorner(x3)
        x7 = index(I, x5)
        x8 = equality(x7, EIGHT)
        x9 = branch(x8, x5, x6)
        x10 = branch(x8, UNITY, DOWN_LEFT)
        x11 = multiply(x10, x1)
        x12 = double(x11)
        x13 = add(x9, x12)
        x14 = subtract(x9, x12)
        x15 = connect(x13, x14)
        x16 = fill(I, THREE, x15)
        x17 = paint(x16, x4)
        x18 = objects(x17, T, F, T)
        x19 = rbind(adjacent, x4)
        x20 = extract(x18, x19)
        x21 = first(x20)
        x22 = last(x21)
        x23 = flip(x8)
        x24 = branch(x23, UNITY, DOWN_LEFT)
        x25 = multiply(x24, x1)
        x26 = double(x25)
        x27 = add(x22, x26)
        x28 = subtract(x22, x26)
        x29 = connect(x27, x28)
        x30 = fill(x17, THREE, x29)
        x31 = paint(x30, x3)
        O = paint(x31, x4)
        return O

    def solve_6d0160f0(I):
        x1 = ofcolor(I, FOUR)
        x2 = first(x1)
        x3 = first(x2)
        x4 = last(x2)
        x5 = greater(x3, THREE)
        x6 = greater(x3, SEVEN)
        x7 = greater(x4, THREE)
        x8 = greater(x4, SEVEN)
        x9 = branch(x5, FOUR, ZERO)
        x10 = branch(x6, EIGHT, x9)
        x11 = branch(x7, FOUR, ZERO)
        x12 = branch(x8, EIGHT, x11)
        x13 = astuple(x10, x12)
        x14 = initset(ZERO)
        x15 = insert(FOUR, x14)
        x16 = insert(EIGHT, x15)
        x17 = product(x16, x16)
        x18 = crop(I, ORIGIN, THREE_BY_THREE)
        x19 = asindices(x18)
        x20 = recolor(ZERO, x19)
        x21 = lbind(shift, x20)
        x22 = mapply(x21, x17)
        x23 = paint(I, x22)
        x24 = crop(I, x13, THREE_BY_THREE)
        x25 = replace(x24, FIVE, ZERO)
        x26 = ofcolor(x25, FOUR)
        x27 = first(x26)
        x28 = asindices(x25)
        x29 = toobject(x28, x25)
        x30 = multiply(x27, FOUR)
        x31 = shift(x29, x30)
        O = paint(x23, x31)
        return O

    def solve_f8a8fe49(I):
        x1 = objects(I, T, F, T)
        x2 = replace(I, FIVE, ZERO)
        x3 = colorfilter(x1, TWO)
        x4 = first(x3)
        x5 = portrait(x4)
        x6 = branch(x5, hsplit, vsplit)
        x7 = branch(x5, vmirror, hmirror)
        x8 = ofcolor(I, TWO)
        x9 = subgrid(x8, I)
        x10 = trim(x9)
        x11 = x7(x10)
        x12 = x6(x11, TWO)
        x13 = compose(normalize, asobject)
        x14 = apply(x13, x12)
        x15 = last(x14)
        x16 = first(x14)
        x17 = ulcorner(x8)
        x18 = increment(x17)
        x19 = shift(x15, x18)
        x20 = shift(x16, x18)
        x21 = branch(x5, width, height)
        x22 = branch(x5, tojvec, toivec)
        x23 = x21(x15)
        x24 = double(x23)
        x25 = compose(x22, increment)
        x26 = x25(x23)
        x27 = invert(x26)
        x28 = x25(x24)
        x29 = shift(x19, x27)
        x30 = shift(x20, x28)
        x31 = paint(x2, x29)
        O = paint(x31, x30)
        return O

    def solve_d07ae81c(I):
        x1 = objects(I, T, F, F)
        x2 = sizefilter(x1, ONE)
        x3 = apply(color, x2)
        x4 = difference(x1, x2)
        x5 = apply(color, x4)
        x6 = first(x5)
        x7 = last(x5)
        x8 = ofcolor(I, x6)
        x9 = ofcolor(I, x7)
        x10 = rbind(shoot, UNITY)
        x11 = rbind(shoot, NEG_UNITY)
        x12 = rbind(shoot, DOWN_LEFT)
        x13 = rbind(shoot, UP_RIGHT)
        x14 = fork(combine, x10, x11)
        x15 = fork(combine, x12, x13)
        x16 = fork(combine, x14, x15)
        x17 = compose(x16, center)
        x18 = mapply(x17, x2)
        x19 = intersection(x8, x18)
        x20 = intersection(x9, x18)
        x21 = first(x2)
        x22 = color(x21)
        x23 = center(x21)
        x24 = neighbors(x23)
        x25 = toobject(x24, I)
        x26 = mostcolor(x25)
        x27 = other(x3, x22)
        x28 = equality(x26, x6)
        x29 = branch(x28, x22, x27)
        x30 = branch(x28, x27, x22)
        x31 = fill(I, x29, x19)
        O = fill(x31, x30, x20)
        return O

    def solve_6a1e5592(I):
        x1 = width(I)
        x2 = objects(I, T, F, T)
        x3 = astuple(FIVE, x1)
        x4 = crop(I, ORIGIN, x3)
        x5 = colorfilter(x2, FIVE)
        x6 = merge(x5)
        x7 = cover(I, x6)
        x8 = compose(toindices, normalize)
        x9 = apply(x8, x5)
        x10 = asindices(x4)
        x11 = ofcolor(x4, ZERO)
        x12 = ofcolor(x4, TWO)
        x13 = rbind(multiply, TEN)
        x14 = rbind(multiply, FIVE)
        x15 = rbind(intersection, x12)
        x16 = rbind(intersection, x11)
        x17 = rbind(intersection, x10)
        x18 = chain(x13, size, x15)
        x19 = chain(size, x16, delta)
        x20 = compose(x14, uppermost)
        x21 = chain(size, x16, outbox)
        x22 = chain(x13, size, x17)
        x23 = compose(invert, x18)
        x24 = fork(add, x22, x23)
        x25 = fork(subtract, x24, x21)
        x26 = fork(subtract, x25, x20)
        x27 = fork(subtract, x26, x19)
        x28 = rbind(apply, x10)
        x29 = lbind(lbind, shift)
        x30 = rbind(argmax, x27)
        x31 = chain(x30, x28, x29)
        x32 = mapply(x31, x9)
        O = fill(x7, ONE, x32)
        return O

    def solve_0e206a2e(I):
        x1 = palette(I)
        x2 = objects(I, F, F, T)
        x3 = rbind(greater, ONE)
        x4 = compose(x3, numcolors)
        x5 = sfilter(x2, x4)
        x6 = remove(ZERO, x1)
        x7 = lbind(colorcount, I)
        x8 = argmax(x6, x7)
        x9 = remove(x8, x6)
        x10 = rbind(contained, x9)
        x11 = compose(x10, first)
        x12 = rbind(sfilter, x11)
        x13 = lbind(rbind, subtract)
        x14 = lbind(occurrences, I)
        x15 = lbind(lbind, shift)
        x16 = compose(x13, ulcorner)
        x17 = chain(x16, x12, normalize)
        x18 = chain(x14, x12, normalize)
        x19 = fork(apply, x17, x18)
        x20 = compose(x15, normalize)
        x21 = fork(mapply, x20, x19)
        x22 = astuple(cmirror, dmirror)
        x23 = astuple(hmirror, vmirror)
        x24 = combine(x22, x23)
        x25 = product(x24, x24)
        x26 = fork(compose, first, last)
        x27 = apply(x26, x25)
        x28 = totuple(x27)
        x29 = combine(x24, x28)
        x30 = lbind(rapply, x29)
        x31 = mapply(x30, x5)
        x32 = mapply(x21, x31)
        x33 = paint(I, x32)
        x34 = merge(x5)
        O = cover(x33, x34)
        return O

    def solve_d22278a0(I):
        x1 = asindices(I)
        x2 = objects(I, T, F, T)
        x3 = fork(multiply, sign, identity)
        x4 = lbind(apply, x3)
        x5 = chain(even, maximum, x4)
        x6 = lbind(sfilter, x1)
        x7 = fork(add, first, last)
        x8 = rbind(remove, x2)
        x9 = compose(center, last)
        x10 = fork(subtract, first, x9)
        x11 = compose(x5, x10)
        x12 = lbind(rbind, equality)
        x13 = lbind(argmin, x2)
        x14 = chain(x7, x4, x10)
        x15 = lbind(lbind, astuple)
        x16 = lbind(rbind, astuple)
        x17 = lbind(compose, x11)
        x18 = lbind(compose, x14)
        x19 = compose(x18, x15)
        x20 = compose(x18, x16)
        x21 = compose(x13, x19)
        x22 = rbind(compose, x21)
        x23 = lbind(lbind, valmin)
        x24 = rbind(compose, x19)
        x25 = chain(x24, x23, x8)
        x26 = lbind(fork, greater)
        x27 = fork(x26, x25, x20)
        x28 = chain(x6, x17, x16)
        x29 = chain(x6, x22, x12)
        x30 = fork(intersection, x28, x29)
        x31 = compose(x6, x27)
        x32 = fork(intersection, x30, x31)
        x33 = fork(recolor, color, x32)
        x34 = mapply(x33, x2)
        O = paint(I, x34)
        return O

    def solve_4290ef0e(I):
        x1 = mostcolor(I)
        x2 = fgpartition(I)
        x3 = objects(I, T, F, T)
        x4 = rbind(valmax, width)
        x5 = lbind(colorfilter, x3)
        x6 = compose(x5, color)
        x7 = compose(double, x4)
        x8 = lbind(prapply, manhattan)
        x9 = fork(x8, identity, identity)
        x10 = lbind(remove, ZERO)
        x11 = compose(x10, x9)
        x12 = rbind(branch, NEG_TWO)
        x13 = fork(x12, positive, decrement)
        x14 = chain(x13, minimum, x11)
        x15 = fork(add, x14, x7)
        x16 = compose(x15, x6)
        x17 = compose(invert, x16)
        x18 = order(x2, x17)
        x19 = rbind(argmin, centerofmass)
        x20 = compose(initset, vmirror)
        x21 = fork(insert, dmirror, x20)
        x22 = fork(insert, cmirror, x21)
        x23 = fork(insert, hmirror, x22)
        x24 = compose(x19, x23)
        x25 = apply(x24, x18)
        x26 = size(x2)
        x27 = apply(size, x2)
        x28 = contained(ONE, x27)
        x29 = increment(x26)
        x30 = branch(x28, x26, x29)
        x31 = double(x30)
        x32 = decrement(x31)
        x33 = apply(normalize, x25)
        x34 = interval(ZERO, x30, ONE)
        x35 = pair(x34, x34)
        x36 = mpapply(shift, x33, x35)
        x37 = astuple(x32, x32)
        x38 = canvas(x1, x37)
        x39 = paint(x38, x36)
        x40 = rot90(x39)
        x41 = paint(x40, x36)
        x42 = rot90(x41)
        x43 = paint(x42, x36)
        x44 = rot90(x43)
        O = paint(x44, x36)
        return O

    def solve_50846271(I):
        x1 = ofcolor(I, TWO)
        x2 = prapply(connect, x1, x1)
        x3 = lbind(greater, SIX)
        x4 = compose(x3, size)
        x5 = fork(either, vline, hline)
        x6 = fork(both, x4, x5)
        x7 = mfilter(x2, x6)
        x8 = fill(I, TWO, x7)
        x9 = objects(x8, T, F, F)
        x10 = colorfilter(x9, TWO)
        x11 = valmax(x10, width)
        x12 = halve(x11)
        x13 = toivec(x12)
        x14 = tojvec(x12)
        x15 = rbind(add, ZERO_BY_TWO)
        x16 = rbind(add, TWO_BY_ZERO)
        x17 = rbind(subtract, ZERO_BY_TWO)
        x18 = rbind(subtract, TWO_BY_ZERO)
        x19 = rbind(colorcount, TWO)
        x20 = rbind(toobject, x8)
        x21 = compose(initset, x15)
        x22 = fork(insert, x16, x21)
        x23 = fork(insert, x17, x22)
        x24 = fork(insert, x18, x23)
        x25 = fork(combine, dneighbors, x24)
        x26 = chain(x19, x20, x25)
        x27 = rbind(argmax, x26)
        x28 = compose(x27, toindices)
        x29 = apply(x28, x10)
        x30 = rbind(add, x13)
        x31 = rbind(subtract, x13)
        x32 = rbind(add, x14)
        x33 = rbind(subtract, x14)
        x34 = fork(connect, x30, x31)
        x35 = fork(connect, x32, x33)
        x36 = fork(combine, x34, x35)
        x37 = mapply(x36, x29)
        x38 = fill(x8, EIGHT, x37)
        O = fill(x38, TWO, x1)
        return O

    def solve_b527c5c6(I):
        x1 = objects(I, F, F, T)
        x2 = matcher(first, TWO)
        x3 = rbind(sfilter, x2)
        x4 = compose(lowermost, x3)
        x5 = compose(rightmost, x3)
        x6 = compose(uppermost, x3)
        x7 = compose(leftmost, x3)
        x8 = fork(equality, x4, lowermost)
        x9 = fork(equality, x5, rightmost)
        x10 = fork(equality, x6, uppermost)
        x11 = fork(equality, x7, leftmost)
        x12 = compose(invert, x10)
        x13 = compose(invert, x11)
        x14 = fork(add, x12, x8)
        x15 = fork(add, x13, x9)
        x16 = fork(astuple, x14, x15)
        x17 = compose(center, x3)
        x18 = fork(shoot, x17, x16)
        x19 = mapply(x18, x1)
        x20 = fill(I, TWO, x19)
        x21 = compose(vline, x18)
        x22 = sfilter(x1, x21)
        x23 = difference(x1, x22)
        x24 = chain(decrement, minimum, shape)
        x25 = compose(increment, x24)
        x26 = compose(invert, x24)
        x27 = rbind(interval, ONE)
        x28 = fork(x27, x26, x25)
        x29 = lbind(apply, toivec)
        x30 = lbind(apply, tojvec)
        x31 = lbind(lbind, shift)
        x32 = compose(x31, x18)
        x33 = compose(x29, x28)
        x34 = compose(x30, x28)
        x35 = fork(mapply, x32, x33)
        x36 = fork(mapply, x32, x34)
        x37 = mapply(x35, x23)
        x38 = mapply(x36, x22)
        x39 = combine(x37, x38)
        O = underfill(x20, THREE, x39)
        return O

    def solve_150deff5(I):
        x1 = canvas(FIVE, TWO_BY_TWO)
        x2 = asobject(x1)
        x3 = occurrences(I, x2)
        x4 = lbind(shift, x2)
        x5 = mapply(x4, x3)
        x6 = fill(I, EIGHT, x5)
        x7 = canvas(FIVE, UNITY)
        x8 = astuple(TWO, ONE)
        x9 = canvas(EIGHT, x8)
        x10 = vconcat(x9, x7)
        x11 = asobject(x10)
        x12 = occurrences(x6, x11)
        x13 = lbind(shift, x11)
        x14 = mapply(x13, x12)
        x15 = fill(x6, TWO, x14)
        x16 = astuple(ONE, THREE)
        x17 = canvas(FIVE, x16)
        x18 = asobject(x17)
        x19 = occurrences(x15, x18)
        x20 = lbind(shift, x18)
        x21 = mapply(x20, x19)
        x22 = fill(x15, TWO, x21)
        x23 = hmirror(x10)
        x24 = asobject(x23)
        x25 = occurrences(x22, x24)
        x26 = lbind(shift, x24)
        x27 = mapply(x26, x25)
        x28 = fill(x22, TWO, x27)
        x29 = dmirror(x10)
        x30 = asobject(x29)
        x31 = occurrences(x28, x30)
        x32 = lbind(shift, x30)
        x33 = mapply(x32, x31)
        x34 = fill(x28, TWO, x33)
        x35 = vmirror(x29)
        x36 = asobject(x35)
        x37 = occurrences(x34, x36)
        x38 = lbind(shift, x36)
        x39 = mapply(x38, x37)
        O = fill(x34, TWO, x39)
        return O

    def solve_b7249182(I):
        x1 = objects(I, T, F, T)
        x2 = merge(x1)
        x3 = portrait(x2)
        x4 = branch(x3, identity, dmirror)
        x5 = x4(I)
        x6 = objects(x5, T, F, T)
        x7 = order(x6, uppermost)
        x8 = first(x7)
        x9 = last(x7)
        x10 = color(x8)
        x11 = color(x9)
        x12 = compose(first, toindices)
        x13 = x12(x8)
        x14 = x12(x9)
        x15 = connect(x13, x14)
        x16 = centerofmass(x15)
        x17 = connect(x13, x16)
        x18 = fill(x5, x11, x15)
        x19 = fill(x18, x10, x17)
        x20 = add(x16, DOWN)
        x21 = initset(x16)
        x22 = insert(x20, x21)
        x23 = toobject(x22, x19)
        x24 = astuple(ZERO, NEG_TWO)
        x25 = shift(x23, ZERO_BY_TWO)
        x26 = shift(x23, x24)
        x27 = combine(x25, x26)
        x28 = ulcorner(x27)
        x29 = urcorner(x27)
        x30 = connect(x28, x29)
        x31 = shift(x30, UP)
        x32 = llcorner(x27)
        x33 = lrcorner(x27)
        x34 = connect(x32, x33)
        x35 = shift(x34, DOWN)
        x36 = paint(x19, x27)
        x37 = fill(x36, x10, x31)
        x38 = fill(x37, x11, x35)
        x39 = cover(x38, x22)
        O = x4(x39)
        return O

    def solve_9d9215db(I):
        x1 = rot90(I)
        x2 = rot180(I)
        x3 = rot270(I)
        x4 = initset(I)
        x5 = chain(numcolors, lefthalf, tophalf)
        x6 = insert(x1, x4)
        x7 = insert(x2, x6)
        x8 = insert(x3, x7)
        x9 = argmax(x8, x5)
        x10 = vmirror(x9)
        x11 = papply(pair, x9, x10)
        x12 = lbind(apply, maximum)
        x13 = apply(x12, x11)
        x14 = partition(x13)
        x15 = sizefilter(x14, FOUR)
        x16 = apply(llcorner, x15)
        x17 = apply(lrcorner, x15)
        x18 = combine(x16, x17)
        x19 = cover(x13, x18)
        x20 = tojvec(NEG_TWO)
        x21 = rbind(add, ZERO_BY_TWO)
        x22 = rbind(add, x20)
        x23 = compose(x21, ulcorner)
        x24 = compose(x22, urcorner)
        x25 = fork(connect, x23, x24)
        x26 = compose(even, last)
        x27 = rbind(sfilter, x26)
        x28 = chain(normalize, x27, x25)
        x29 = fork(shift, x28, x23)
        x30 = fork(recolor, color, x29)
        x31 = mapply(x30, x15)
        x32 = paint(x19, x31)
        x33 = rot90(x32)
        x34 = rot180(x32)
        x35 = rot270(x32)
        x36 = papply(pair, x32, x33)
        x37 = apply(x12, x36)
        x38 = papply(pair, x37, x34)
        x39 = apply(x12, x38)
        x40 = papply(pair, x39, x35)
        O = apply(x12, x40)
        return O

    def solve_6855a6e4(I):
        x1 = fgpartition(I)
        x2 = rot90(I)
        x3 = colorfilter(x1, TWO)
        x4 = first(x3)
        x5 = portrait(x4)
        x6 = branch(x5, I, x2)
        x7 = objects(x6, T, F, T)
        x8 = colorfilter(x7, FIVE)
        x9 = apply(center, x8)
        x10 = valmin(x9, first)
        x11 = compose(first, center)
        x12 = matcher(x11, x10)
        x13 = compose(flip, x12)
        x14 = extract(x8, x12)
        x15 = extract(x8, x13)
        x16 = ulcorner(x14)
        x17 = ulcorner(x15)
        x18 = subgrid(x14, x6)
        x19 = subgrid(x15, x6)
        x20 = hmirror(x18)
        x21 = hmirror(x19)
        x22 = ofcolor(x20, FIVE)
        x23 = recolor(FIVE, x22)
        x24 = ofcolor(x21, FIVE)
        x25 = recolor(FIVE, x24)
        x26 = height(x23)
        x27 = height(x25)
        x28 = add(THREE, x26)
        x29 = add(THREE, x27)
        x30 = toivec(x28)
        x31 = toivec(x29)
        x32 = add(x16, x30)
        x33 = subtract(x17, x31)
        x34 = shift(x23, x32)
        x35 = shift(x25, x33)
        x36 = merge(x8)
        x37 = cover(x6, x36)
        x38 = paint(x37, x34)
        x39 = paint(x38, x35)
        x40 = rot270(x39)
        O = branch(x5, x39, x40)
        return O

    def solve_264363fd(I):
        x1 = objects(I, F, F, T)
        x2 = argmin(x1, size)
        x3 = normalize(x2)
        x4 = height(x2)
        x5 = width(x2)
        x6 = equality(x4, FIVE)
        x7 = equality(x5, FIVE)
        x8 = astuple(x6, x7)
        x9 = add(UNITY, x8)
        x10 = invert(x9)
        x11 = center(x2)
        x12 = index(I, x11)
        x13 = branch(x6, UP, RIGHT)
        x14 = add(x13, x11)
        x15 = index(I, x14)
        x16 = astuple(x12, ORIGIN)
        x17 = initset(x16)
        x18 = cover(I, x2)
        x19 = mostcolor(x18)
        x20 = ofcolor(x18, x19)
        x21 = occurrences(x18, x17)
        x22 = objects(x18, F, F, T)
        x23 = rbind(occurrences, x17)
        x24 = rbind(subgrid, x18)
        x25 = compose(x23, x24)
        x26 = lbind(mapply, vfrontier)
        x27 = lbind(mapply, hfrontier)
        x28 = compose(x26, x25)
        x29 = compose(x27, x25)
        x30 = branch(x6, x28, x29)
        x31 = branch(x7, x29, x28)
        x32 = fork(combine, x30, x31)
        x33 = lbind(recolor, x15)
        x34 = compose(x33, x32)
        x35 = fork(paint, x24, x34)
        x36 = compose(asobject, x35)
        x37 = fork(shift, x36, ulcorner)
        x38 = mapply(x37, x22)
        x39 = paint(x18, x38)
        x40 = shift(x3, x10)
        x41 = lbind(shift, x40)
        x42 = mapply(x41, x21)
        x43 = paint(x39, x42)
        O = fill(x43, x19, x20)
        return O

    def solve_7df24a62(I):
        x1 = height(I)
        x2 = width(I)
        x3 = ofcolor(I, ONE)
        x4 = ofcolor(I, FOUR)
        x5 = ulcorner(x3)
        x6 = subgrid(x3, I)
        x7 = rot90(x6)
        x8 = rot180(x6)
        x9 = rot270(x6)
        x10 = matcher(size, ZERO)
        x11 = rbind(ofcolor, ONE)
        x12 = compose(normalize, x11)
        x13 = rbind(ofcolor, FOUR)
        x14 = rbind(shift, x5)
        x15 = compose(x14, x13)
        x16 = lbind(subtract, x1)
        x17 = chain(increment, x16, height)
        x18 = lbind(subtract, x2)
        x19 = chain(increment, x18, width)
        x20 = rbind(interval, ONE)
        x21 = lbind(x20, ZERO)
        x22 = compose(x21, x17)
        x23 = compose(x21, x19)
        x24 = fork(product, x22, x23)
        x25 = rbind(shift, NEG_UNITY)
        x26 = lbind(lbind, shift)
        x27 = chain(x26, x25, x12)
        x28 = astuple(x6, x7)
        x29 = astuple(x8, x9)
        x30 = combine(x28, x29)
        x31 = apply(x15, x30)
        x32 = lbind(difference, x4)
        x33 = apply(x32, x31)
        x34 = apply(normalize, x31)
        x35 = apply(x24, x34)
        x36 = lbind(rbind, difference)
        x37 = apply(x26, x34)
        x38 = apply(x36, x33)
        x39 = papply(compose, x38, x37)
        x40 = lbind(compose, x10)
        x41 = apply(x40, x39)
        x42 = papply(sfilter, x35, x41)
        x43 = apply(x27, x30)
        x44 = mpapply(mapply, x43, x42)
        O = fill(I, ONE, x44)
        return O

    def solve_f15e1fac(I):
        x1 = ofcolor(I, TWO)
        x2 = portrait(x1)
        x3 = branch(x2, identity, dmirror)
        x4 = x3(I)
        x5 = leftmost(x1)
        x6 = equality(x5, ZERO)
        x7 = branch(x6, identity, vmirror)
        x8 = x7(x4)
        x9 = ofcolor(x8, EIGHT)
        x10 = uppermost(x9)
        x11 = equality(x10, ZERO)
        x12 = branch(x11, identity, hmirror)
        x13 = x12(x8)
        x14 = ofcolor(x13, EIGHT)
        x15 = ofcolor(x13, TWO)
        x16 = rbind(shoot, DOWN)
        x17 = mapply(x16, x14)
        x18 = height(x13)
        x19 = apply(first, x15)
        x20 = insert(ZERO, x19)
        x21 = insert(x18, x19)
        x22 = apply(decrement, x21)
        x23 = order(x20, identity)
        x24 = order(x22, identity)
        x25 = size(x15)
        x26 = increment(x25)
        x27 = interval(ZERO, x26, ONE)
        x28 = apply(tojvec, x27)
        x29 = pair(x23, x24)
        x30 = lbind(sfilter, x17)
        x31 = compose(first, last)
        x32 = chain(decrement, first, first)
        x33 = fork(greater, x31, x32)
        x34 = chain(increment, last, first)
        x35 = fork(greater, x34, x31)
        x36 = fork(both, x33, x35)
        x37 = lbind(lbind, astuple)
        x38 = lbind(compose, x36)
        x39 = chain(x30, x38, x37)
        x40 = apply(x39, x29)
        x41 = papply(shift, x40, x28)
        x42 = merge(x41)
        x43 = fill(x13, EIGHT, x42)
        x44 = chain(x3, x7, x12)
        O = x44(x43)
        return O

    def solve_234bbc79(I):
        x1 = objects(I, F, F, T)
        x2 = rbind(other, FIVE)
        x3 = compose(x2, palette)
        x4 = fork(recolor, x3, identity)
        x5 = apply(x4, x1)
        x6 = order(x5, leftmost)
        x7 = compose(last, last)
        x8 = lbind(matcher, x7)
        x9 = compose(x8, leftmost)
        x10 = compose(x8, rightmost)
        x11 = fork(sfilter, identity, x9)
        x12 = fork(sfilter, identity, x10)
        x13 = compose(dneighbors, last)
        x14 = rbind(chain, x13)
        x15 = lbind(x14, size)
        x16 = lbind(rbind, intersection)
        x17 = chain(x15, x16, toindices)
        x18 = fork(argmin, x11, x17)
        x19 = fork(argmin, x12, x17)
        x20 = compose(last, x18)
        x21 = compose(last, x19)
        x22 = astuple(ZERO, DOWN_LEFT)
        x23 = initset(x22)
        x24 = lbind(add, RIGHT)
        x25 = chain(x20, first, last)
        x26 = compose(x21, first)
        x27 = fork(subtract, x26, x25)
        x28 = compose(first, last)
        x29 = compose(x24, x27)
        x30 = fork(shift, x28, x29)
        x31 = fork(combine, first, x30)
        x32 = fork(remove, x28, last)
        x33 = fork(astuple, x31, x32)
        x34 = size(x1)
        x35 = power(x33, x34)
        x36 = astuple(x23, x6)
        x37 = x35(x36)
        x38 = first(x37)
        x39 = width(x38)
        x40 = decrement(x39)
        x41 = astuple(THREE, x40)
        x42 = canvas(ZERO, x41)
        O = paint(x42, x38)
        return O

    def solve_22233c11(I):
        x1 = objects(I, T, T, T)
        x2 = rbind(upscale, TWO)
        x3 = chain(invert, halve, shape)
        x4 = fork(combine, hfrontier, vfrontier)
        x5 = compose(x2, vmirror)
        x6 = fork(shift, x5, x3)
        x7 = compose(toindices, x6)
        x8 = lbind(mapply, x4)
        x9 = compose(x8, toindices)
        x10 = fork(difference, x7, x9)
        x11 = mapply(x10, x1)
        O = fill(I, EIGHT, x11)
        return O

    def solve_2dd70a9a(I):
        x1 = ofcolor(I, TWO)
        x2 = ofcolor(I, THREE)
        x3 = vline(x1)
        x4 = vline(x2)
        x5 = center(x1)
        x6 = branch(x4, uppermost, rightmost)
        x7 = x6(x1)
        x8 = x6(x2)
        x9 = greater(x7, x8)
        x10 = both(x4, x9)
        x11 = branch(x10, lowermost, uppermost)
        x12 = x11(x2)
        x13 = branch(x4, leftmost, rightmost)
        x14 = x13(x2)
        x15 = astuple(x12, x14)
        x16 = other(x2, x15)
        x17 = subtract(x15, x16)
        x18 = shoot(x15, x17)
        x19 = underfill(I, ONE, x18)
        x20 = objects(x19, T, F, F)
        x21 = colorfilter(x20, ONE)
        x22 = rbind(adjacent, x2)
        x23 = sfilter(x21, x22)
        x24 = difference(x21, x23)
        x25 = merge(x24)
        x26 = cover(x19, x25)
        x27 = shoot(x5, DOWN)
        x28 = shoot(x5, UP)
        x29 = shoot(x5, LEFT)
        x30 = shoot(x5, RIGHT)
        x31 = combine(x27, x28)
        x32 = combine(x29, x30)
        x33 = branch(x3, x31, x32)
        x34 = ofcolor(x26, ONE)
        x35 = initset(x15)
        x36 = rbind(manhattan, x35)
        x37 = compose(x36, initset)
        x38 = argmax(x34, x37)
        x39 = initset(x38)
        x40 = gravitate(x39, x33)
        x41 = crement(x40)
        x42 = add(x38, x41)
        x43 = connect(x38, x42)
        x44 = fill(x26, ONE, x43)
        x45 = connect(x42, x5)
        x46 = underfill(x44, ONE, x45)
        O = replace(x46, ONE, THREE)
        return O

    def solve_a64e4611(I):
        x1 = asindices(I)
        x2 = fork(product, identity, identity)
        x3 = lbind(canvas, ZERO)
        x4 = compose(asobject, x3)
        x5 = fork(multiply, first, last)
        x6 = compose(positive, size)
        x7 = lbind(lbind, shift)
        x8 = rbind(fork, x5)
        x9 = lbind(x8, multiply)
        x10 = lbind(chain, x6)
        x11 = rbind(x10, x4)
        x12 = lbind(lbind, occurrences)
        x13 = chain(x9, x11, x12)
        x14 = compose(x2, first)
        x15 = compose(x13, last)
        x16 = fork(argmax, x14, x15)
        x17 = chain(x7, x4, x16)
        x18 = compose(x4, x16)
        x19 = fork(occurrences, last, x18)
        x20 = fork(mapply, x17, x19)
        x21 = multiply(TWO, SIX)
        x22 = interval(THREE, x21, ONE)
        x23 = astuple(x22, I)
        x24 = x20(x23)
        x25 = fill(I, THREE, x24)
        x26 = interval(THREE, TEN, ONE)
        x27 = astuple(x26, x25)
        x28 = x20(x27)
        x29 = fill(x25, THREE, x28)
        x30 = astuple(x26, x29)
        x31 = x20(x30)
        x32 = fill(x29, THREE, x31)
        x33 = rbind(toobject, x32)
        x34 = rbind(colorcount, THREE)
        x35 = chain(x34, x33, neighbors)
        x36 = matcher(x35, EIGHT)
        x37 = sfilter(x1, x36)
        x38 = fill(I, THREE, x37)
        x39 = ofcolor(x38, ZERO)
        x40 = rbind(bordering, x38)
        x41 = compose(x40, initset)
        x42 = lbind(contained, THREE)
        x43 = rbind(toobject, x38)
        x44 = chain(x42, palette, x43)
        x45 = compose(x44, dneighbors)
        x46 = fork(both, x45, x41)
        x47 = sfilter(x39, x46)
        O = fill(x38, THREE, x47)
        return O

    def solve_7837ac64(I):
        x1 = fgpartition(I)
        x2 = argmax(x1, size)
        x3 = remove(x2, x1)
        x4 = merge(x3)
        x5 = subgrid(x4, I)
        x6 = chain(color, merge, frontiers)
        x7 = x6(I)
        x8 = objects(x5, T, F, F)
        x9 = colorfilter(x8, ZERO)
        x10 = rbind(toobject, x5)
        x11 = chain(x10, corners, outbox)
        x12 = lbind(contained, x7)
        x13 = chain(x12, palette, x11)
        x14 = compose(numcolors, x11)
        x15 = compose(flip, x13)
        x16 = matcher(x14, ONE)
        x17 = fork(both, x15, x16)
        x18 = sfilter(x9, x17)
        x19 = compose(color, x11)
        x20 = fork(recolor, x19, identity)
        x21 = mapply(x20, x18)
        x22 = paint(x5, x21)
        x23 = first(x9)
        x24 = height(x23)
        x25 = height(x5)
        x26 = increment(x24)
        x27 = interval(ZERO, x25, x26)
        x28 = interval(ZERO, x25, ONE)
        x29 = rbind(contained, x27)
        x30 = chain(flip, x29, last)
        x31 = lbind(apply, first)
        x32 = rbind(sfilter, x30)
        x33 = rbind(pair, x28)
        x34 = chain(x31, x32, x33)
        x35 = compose(dmirror, x34)
        x36 = power(x35, TWO)
        x37 = x36(x22)
        O = downscale(x37, x24)
        return O

    def solve_a8c38be5(I):
        x1 = replace(I, FIVE, ZERO)
        x2 = objects(x1, T, F, T)
        x3 = apply(normalize, x2)
        x4 = astuple(NINE, NINE)
        x5 = canvas(FIVE, x4)
        x6 = asindices(x5)
        x7 = box(x6)
        x8 = center(x6)
        x9 = lbind(contained, ZERO)
        x10 = rbind(subtract, x8)
        x11 = compose(x9, x10)
        x12 = chain(outbox, outbox, initset)
        x13 = corners(x6)
        x14 = mapply(x12, x13)
        x15 = difference(x7, x14)
        x16 = inbox(x7)
        x17 = sfilter(x16, x11)
        x18 = combine(x15, x17)
        x19 = fill(x5, ONE, x18)
        x20 = objects(x19, T, F, T)
        x21 = apply(toindices, x20)
        x22 = lbind(matcher, normalize)
        x23 = lbind(extract, x21)
        x24 = chain(ulcorner, x23, x22)
        x25 = compose(x24, toindices)
        x26 = fork(shift, identity, x25)
        x27 = mapply(x26, x3)
        O = paint(x5, x27)
        return O

    def solve_b775ac94(I):
        x1 = objects(I, F, T, T)
        x2 = lbind(rbind, equality)
        x3 = rbind(compose, first)
        x4 = chain(x3, x2, mostcolor)
        x5 = fork(sfilter, identity, x4)
        x6 = fork(difference, identity, x5)
        x7 = lbind(rbind, adjacent)
        x8 = rbind(compose, initset)
        x9 = chain(x8, x7, x6)
        x10 = fork(extract, x5, x9)
        x11 = fork(insert, x10, x6)
        x12 = lbind(recolor, ZERO)
        x13 = chain(x12, delta, x11)
        x14 = fork(combine, x11, x13)
        x15 = fork(position, x5, x6)
        x16 = chain(toivec, first, x15)
        x17 = chain(tojvec, last, x15)
        x18 = fork(multiply, shape, x16)
        x19 = fork(multiply, shape, x17)
        x20 = fork(multiply, shape, x15)
        x21 = fork(shift, hmirror, x18)
        x22 = fork(shift, vmirror, x19)
        x23 = compose(hmirror, vmirror)
        x24 = fork(shift, x23, x20)
        x25 = lbind(compose, x5)
        x26 = x25(x21)
        x27 = x25(x22)
        x28 = x25(x24)
        x29 = compose(crement, invert)
        x30 = lbind(compose, x29)
        x31 = x30(x16)
        x32 = x30(x17)
        x33 = x30(x15)
        x34 = fork(shift, x26, x31)
        x35 = fork(shift, x27, x32)
        x36 = fork(shift, x28, x33)
        x37 = lbind(index, I)
        x38 = lbind(compose, toindices)
        x39 = x38(x14)
        x40 = x38(x34)
        x41 = x38(x35)
        x42 = x38(x36)
        x43 = fork(intersection, x39, x40)
        x44 = fork(intersection, x39, x41)
        x45 = fork(intersection, x39, x42)
        x46 = chain(x37, first, x43)
        x47 = chain(x37, first, x44)
        x48 = chain(x37, first, x45)
        x49 = fork(recolor, x46, x34)
        x50 = fork(recolor, x47, x35)
        x51 = fork(recolor, x48, x36)
        x52 = mapply(x49, x1)
        x53 = mapply(x50, x1)
        x54 = mapply(x51, x1)
        x55 = paint(I, x52)
        x56 = paint(x55, x53)
        O = paint(x56, x54)
        return O

    def solve_97a05b5b(I):
        x1 = objects(I, F, T, T)
        x2 = argmax(x1, size)
        x3 = subgrid(x2, I)
        x4 = rbind(greater, ONE)
        x5 = compose(x4, numcolors)
        x6 = sfilter(x1, x5)
        x7 = lbind(rbind, subtract)
        x8 = switch(x3, TWO, ZERO)
        x9 = lbind(occurrences, x8)
        x10 = lbind(lbind, shift)
        x11 = compose(x7, ulcorner)
        x12 = matcher(first, TWO)
        x13 = compose(flip, x12)
        x14 = rbind(sfilter, x12)
        x15 = rbind(sfilter, x13)
        x16 = lbind(recolor, ZERO)
        x17 = compose(x16, x15)
        x18 = fork(combine, x17, x14)
        x19 = chain(x11, x18, normalize)
        x20 = objects(x8, T, T, T)
        x21 = apply(toindices, x20)
        x22 = chain(x9, x18, normalize)
        x23 = rbind(colorcount, TWO)
        x24 = lbind(sfilter, x21)
        x25 = chain(size, first, x24)
        x26 = compose(positive, size)
        x27 = lbind(lbind, contained)
        x28 = chain(x26, x24, x27)
        x29 = compose(x25, x27)
        x30 = rbind(sfilter, x28)
        x31 = compose(x30, x22)
        x32 = lbind(rbind, equality)
        x33 = rbind(compose, x29)
        x34 = chain(x33, x32, x23)
        x35 = fork(sfilter, x31, x34)
        x36 = fork(apply, x19, x35)
        x37 = compose(x10, normalize)
        x38 = fork(mapply, x37, x36)
        x39 = astuple(cmirror, dmirror)
        x40 = astuple(hmirror, vmirror)
        x41 = combine(x39, x40)
        x42 = product(x41, x41)
        x43 = fork(compose, first, last)
        x44 = apply(x43, x42)
        x45 = lbind(rapply, x44)
        x46 = mapply(x45, x6)
        x47 = mapply(x38, x46)
        x48 = paint(x3, x47)
        x49 = palette(x47)
        x50 = lbind(remove, TWO)
        x51 = x50(x49)
        x52 = chain(first, x50, palette)
        x53 = rbind(contained, x51)
        x54 = chain(flip, x53, x52)
        x55 = sfilter(x6, x54)
        x56 = fork(apply, x19, x22)
        x57 = fork(mapply, x37, x56)
        x58 = mapply(x45, x55)
        x59 = mapply(x57, x58)
        O = paint(x48, x59)
        return O

    def solve_3e980e27(I):
        x1 = objects(I, F, T, T)
        x2 = astuple(TEN, TEN)
        x3 = invert(x2)
        x4 = astuple(TWO, x3)
        x5 = astuple(THREE, x3)
        x6 = initset(x4)
        x7 = insert(x5, x6)
        x8 = insert(x7, x1)
        x9 = lbind(contained, TWO)
        x10 = lbind(contained, THREE)
        x11 = compose(invert, ulcorner)
        x12 = lbind(compose, x11)
        x13 = lbind(rbind, sfilter)
        x14 = compose(x12, x13)
        x15 = rbind(compose, center)
        x16 = lbind(lbind, shift)
        x17 = x14(x9)
        x18 = x14(x10)
        x19 = fork(shift, identity, x17)
        x20 = fork(shift, identity, x18)
        x21 = compose(x9, palette)
        x22 = compose(x10, palette)
        x23 = sfilter(x8, x21)
        x24 = argmax(x23, size)
        x25 = remove(x24, x23)
        x26 = vmirror(x24)
        x27 = chain(x15, x16, x19)
        x28 = x27(x26)
        x29 = mapply(x28, x25)
        x30 = sfilter(x8, x22)
        x31 = argmax(x30, size)
        x32 = remove(x31, x30)
        x33 = chain(x15, x16, x20)
        x34 = x33(x31)
        x35 = mapply(x34, x32)
        x36 = combine(x29, x35)
        O = paint(I, x36)
        return O

class Tester:
    def verify_007bbfb7(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = other(x0, ZERO)
        x2 = shape(I)
        x3 = multiply(x2, x2)
        x4 = canvas(ZERO, x3)
        x5 = ofcolor(I, x1)
        x6 = lbind(shift, x5)
        x7 = shape(I)
        x8 = rbind(multiply, x7)
        x9 = apply(x8, x5)
        x10 = mapply(x6, x9)
        x11 = fill(x4, x1, x10)
        return x11

    def verify_00d62c1b(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = mostcolor(I)
        x2 = colorfilter(x0, x1)
        x3 = rbind(bordering, I)
        x4 = compose(flip, x3)
        x5 = mfilter(x2, x4)
        x6 = fill(I, FOUR, x5)
        return x6

    def verify_017c7c7b(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = other(x0, ZERO)
        x2 = ofcolor(I, x1)
        x3 = asobject(I)
        x4 = vperiod(x3)
        x5 = height(I)
        x6 = halve(x5)
        x7 = add(x5, x6)
        x8 = width(I)
        x9 = astuple(x7, x8)
        x10 = canvas(ZERO, x9)
        x11 = increment(x7)
        x12 = interval(ZERO, x11, x4)
        x13 = lbind(shift, x2)
        x14 = apply(toivec, x12)
        x15 = mapply(x13, x14)
        x16 = fill(x10, TWO, x15)
        return x16

    def verify_025d127b(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = objects(I, T, T, T)
        x2 = rbind(objects, F)
        x3 = rbind(x2, F)
        x4 = rbind(x3, T)
        x5 = lbind(canvas, x0)
        x6 = compose(x5, shape)
        x7 = fork(paint, x6, normalize)
        x8 = compose(x4, x7)
        x9 = fork(colorfilter, x8, color)
        x10 = rbind(shift, RIGHT)
        x11 = rbind(argmax, rightmost)
        x12 = compose(x11, x9)
        x13 = fork(remove, x12, x9)
        x14 = chain(x10, merge, x13)
        x15 = rbind(argmax, rightmost)
        x16 = compose(x15, x9)
        x17 = fork(combine, x16, x14)
        x18 = fork(shift, x17, ulcorner)
        x19 = merge(x1)
        x20 = fill(I, x0, x19)
        x21 = mapply(x18, x1)
        x22 = paint(x20, x21)
        return x22

    def verify_045e512c(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = argmax(x0, size)
        x2 = height(x1)
        x3 = width(x1)
        x4 = neighbors(ORIGIN)
        x5 = toindices(x1)
        x6 = lbind(shift, x5)
        x7 = height(I)
        x8 = divide(x7, x2)
        x9 = width(I)
        x10 = divide(x9, x3)
        x11 = astuple(x8, x10)
        x12 = maximum(x11)
        x13 = increment(x12)
        x14 = interval(ONE, x13, ONE)
        x15 = astuple(x2, x3)
        x16 = lbind(multiply, x15)
        x17 = compose(crement, x16)
        x18 = lbind(mapply, x6)
        x19 = rbind(apply, x14)
        x20 = lbind(rbind, multiply)
        x21 = compose(x20, x17)
        x22 = chain(x18, x19, x21)
        x23 = rbind(toobject, I)
        x24 = compose(x6, x17)
        x25 = chain(palette, x23, x24)
        x26 = mostcolor(I)
        x27 = rbind(equality, x26)
        x28 = rbind(argmin, x27)
        x29 = compose(x28, x25)
        x30 = fork(recolor, x29, x22)
        x31 = mapply(x30, x4)
        x32 = paint(I, x31)
        return x32

    def verify_0520fde7(I: Grid) -> Grid:
        x0 = width(I)
        x1 = halve(x0)
        x2 = tojvec(x1)
        x3 = height(I)
        x4 = decrement(x3)
        x5 = astuple(x4, x1)
        x6 = connect(x2, x5)
        x7 = toobject(x6, I)
        x8 = numcolors(x7)
        x9 = equality(x8, ONE)
        x10 = branch(x9, lefthalf, tophalf)
        x11 = branch(x9, righthalf, bottomhalf)
        x12 = x10(I)
        x13 = x11(I)
        x14 = palette(x12)
        x15 = other(x14, ZERO)
        x16 = palette(x13)
        x17 = other(x16, ZERO)
        x18 = shape(x12)
        x19 = canvas(ZERO, x18)
        x20 = ofcolor(x12, x15)
        x21 = ofcolor(x13, x17)
        x22 = intersection(x20, x21)
        x23 = fill(x19, TWO, x22)
        return x23

    def verify_05269061(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = maximum(x0)
        x2 = interval(ZERO, x1, ONE)
        x3 = interval(ONE, x1, ONE)
        x4 = rbind(toobject, I)
        x5 = rbind(shoot, RIGHT)
        x6 = chain(x4, x5, toivec)
        x7 = rbind(shoot, DOWN)
        x8 = chain(x4, x7, tojvec)
        x9 = apply(x6, x2)
        x10 = apply(x8, x2)
        x11 = rbind(shoot, UP_RIGHT)
        x12 = chain(x4, x11, toivec)
        x13 = rbind(shoot, UP_RIGHT)
        x14 = decrement(x1)
        x15 = lbind(astuple, x14)
        x16 = chain(x4, x13, x15)
        x17 = apply(x12, x2)
        x18 = apply(x16, x3)
        x19 = combine(x17, x18)
        x20 = rbind(shoot, NEG_UNITY)
        x21 = decrement(x1)
        x22 = lbind(astuple, x21)
        x23 = chain(x4, x20, x22)
        x24 = rbind(shoot, NEG_UNITY)
        x25 = decrement(x1)
        x26 = rbind(astuple, x25)
        x27 = lbind(subtract, x25)
        x28 = compose(x26, x27)
        x29 = chain(x4, x24, x28)
        x30 = apply(x23, x2)
        x31 = apply(x29, x3)
        x32 = combine(x30, x31)
        x33 = rbind(valmax, numcolors)
        x34 = matcher(x33, ONE)
        x35 = x34(x9)
        x36 = x34(x10)
        x37 = x34(x19)
        x38 = branch(x37, x19, x32)
        x39 = branch(x36, x10, x38)
        x40 = branch(x35, x9, x39)
        x41 = apply(mostcolor, x40)
        x42 = matcher(identity, ZERO)
        x43 = compose(flip, x42)
        x44 = sfilter(x41, x43)
        x45 = size(x44)
        x46 = double(x1)
        x47 = divide(x46, x45)
        x48 = increment(x47)
        x49 = interval(ZERO, x48, ONE)
        x50 = matcher(first, ZERO)
        x51 = compose(flip, x50)
        x52 = fork(recolor, first, last)
        x53 = size(x40)
        x54 = interval(ZERO, x53, ONE)
        x55 = rbind(compose, first)
        x56 = lbind(rbind, greater)
        x57 = chain(x55, x56, decrement)
        x58 = lbind(apply, last)
        x59 = lbind(chain, x58)
        x60 = rbind(x59, x57)
        x61 = lbind(lbind, sfilter)
        x62 = lbind(pair, x54)
        x63 = chain(x60, x61, x62)
        x64 = x63(x40)
        x65 = x63(x41)
        x66 = rbind(multiply, x45)
        x67 = compose(x64, x66)
        x68 = rbind(multiply, x45)
        x69 = compose(x65, x68)
        x70 = lbind(mapply, x52)
        x71 = rbind(sfilter, x51)
        x72 = lbind(pair, x41)
        x73 = compose(x72, x67)
        x74 = chain(x70, x71, x73)
        x75 = lbind(mapply, x52)
        x76 = rbind(sfilter, x51)
        x77 = rbind(pair, x40)
        x78 = compose(x77, x69)
        x79 = chain(x75, x76, x78)
        x80 = fork(combine, x74, x79)
        x81 = mapply(x80, x49)
        x82 = paint(I, x81)
        return x82

    def verify_05f2a901(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = fork(multiply, height, width)
        x2 = fork(equality, size, x1)
        x3 = extract(x0, x2)
        x4 = other(x0, x3)
        x5 = gravitate(x4, x3)
        x6 = move(I, x4, x5)
        return x6

    def verify_06df4c85(I: Grid) -> Grid:
        x0 = asobject(I)
        x1 = frontiers(I)
        x2 = merge(x1)
        x3 = difference(x0, x2)
        x4 = mostcolor(x3)
        x5 = objects(I, T, F, F)
        x6 = color(x2)
        x7 = matcher(color, x6)
        x8 = matcher(color, x4)
        x9 = fork(either, x7, x8)
        x10 = compose(flip, x9)
        x11 = sfilter(x5, x10)
        x12 = merge(x11)
        x13 = palette(x12)
        x14 = lbind(mfilter, x11)
        x15 = lbind(matcher, color)
        x16 = compose(x14, x15)
        x17 = apply(x16, x13)
        x18 = fork(either, vline, hline)
        x19 = lbind(prapply, connect)
        x20 = fork(x19, identity, identity)
        x21 = compose(x20, toindices)
        x22 = rbind(sfilter, x18)
        x23 = chain(merge, x22, x21)
        x24 = fork(recolor, color, x23)
        x25 = mapply(x24, x17)
        x26 = paint(I, x25)
        x27 = paint(x26, x2)
        return x27

    def verify_08ed6ac7(I: Grid) -> Grid:
        x0 = first(I)
        x1 = mostcommon(x0)
        x2 = dmirror(I)
        x3 = matcher(identity, x1)
        x4 = rbind(sfilter, x3)
        x5 = compose(size, x4)
        x6 = apply(x5, x2)
        x7 = dedupe(x6)
        x8 = order(x7, identity)
        x9 = size(x8)
        x10 = increment(x9)
        x11 = increment(x10)
        x12 = interval(ONE, x11, ONE)
        x13 = pair(x8, x12)
        x14 = height(I)
        x15 = astuple(x14, x1)
        x16 = repeat(x15, ONE)
        x17 = combine(x16, x13)
        x18 = lbind(extract, x17)
        x19 = lbind(matcher, first)
        x20 = chain(last, x18, x19)
        x21 = compose(x20, x5)
        x22 = fork(subtract, height, x5)
        x23 = fork(repeat, x21, x22)
        x24 = lbind(repeat, x1)
        x25 = compose(x24, x5)
        x26 = fork(combine, x25, x23)
        x27 = apply(x26, x2)
        x28 = dmirror(x27)
        return x28

    def verify_09629e4f(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = sfilter(x0, hline)
        x2 = sfilter(x0, vline)
        x3 = size(x1)
        x4 = size(x2)
        x5 = merge(x0)
        x6 = color(x5)
        x7 = shape(I)
        x8 = canvas(x6, x7)
        x9 = hconcat(I, x8)
        x10 = objects(x9, F, T, T)
        x11 = argmin(x10, numcolors)
        x12 = normalize(x11)
        x13 = toindices(x12)
        x14 = increment(x3)
        x15 = increment(x14)
        x16 = increment(x4)
        x17 = increment(x16)
        x18 = astuple(x15, x17)
        x19 = lbind(shift, x13)
        x20 = rbind(multiply, x18)
        x21 = chain(x19, x20, last)
        x22 = fork(recolor, first, x21)
        x23 = normalize(x11)
        x24 = mapply(x22, x23)
        x25 = paint(x8, x24)
        return x25

    def verify_0962bcdd(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = lbind(mapply, dneighbors)
        x2 = compose(x1, toindices)
        x3 = fork(recolor, mostcolor, x2)
        x4 = compose(decrement, ulcorner)
        x5 = compose(increment, lrcorner)
        x6 = fork(connect, x4, x5)
        x7 = compose(hmirror, x6)
        x8 = fork(combine, x6, x7)
        x9 = fork(recolor, leastcolor, x8)
        x10 = mapply(x3, x0)
        x11 = paint(I, x10)
        x12 = mapply(x9, x0)
        x13 = paint(x11, x12)
        return x13

    def verify_0a938d79(I: Grid) -> Grid:
        x0 = portrait(I)
        x1 = branch(x0, dmirror, identity)
        x2 = x1(I)
        x3 = objects(x2, T, F, T)
        x4 = argmin(x3, leftmost)
        x5 = argmax(x3, leftmost)
        x6 = color(x4)
        x7 = color(x5)
        x8 = leftmost(x4)
        x9 = leftmost(x5)
        x10 = subtract(x9, x8)
        x11 = double(x10)
        x12 = multiply(THREE, TEN)
        x13 = interval(x8, x12, x11)
        x14 = interval(x9, x12, x11)
        x15 = compose(vfrontier, tojvec)
        x16 = mapply(x15, x13)
        x17 = mapply(x15, x14)
        x18 = recolor(x6, x16)
        x19 = recolor(x7, x17)
        x20 = combine(x18, x19)
        x21 = paint(x2, x20)
        x22 = x1(x21)
        return x22

    def verify_0b148d64(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = argmin(x0, x1)
        x3 = subgrid(x2, I)
        return x3

    def verify_0ca9ddb6(I: Grid) -> Grid:
        x0 = ofcolor(I, ONE)
        x1 = ofcolor(I, TWO)
        x2 = mapply(dneighbors, x0)
        x3 = mapply(ineighbors, x1)
        x4 = fill(I, SEVEN, x2)
        x5 = fill(x4, FOUR, x3)
        return x5

    def verify_0d3d703e(I: Grid) -> Grid:
        x0 = switch(I, THREE, FOUR)
        x1 = switch(x0, EIGHT, NINE)
        x2 = switch(x1, TWO, SIX)
        x3 = switch(x2, ONE, FIVE)
        return x3

    def verify_0dfd9992(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = objects(I, T, F, F)
        x2 = lbind(colorfilter, x1)
        x3 = compose(size, x2)
        x4 = valmin(x0, x3)
        x5 = matcher(x3, x4)
        x6 = sfilter(x0, x5)
        x7 = lbind(colorcount, I)
        x8 = argmin(x6, x7)
        x9 = asobject(I)
        x10 = matcher(first, x8)
        x11 = compose(flip, x10)
        x12 = sfilter(x9, x11)
        x13 = lbind(contained, x8)
        x14 = compose(flip, x13)
        x15 = sfilter(I, x14)
        x16 = asobject(x15)
        x17 = hperiod(x16)
        x18 = dmirror(I)
        x19 = sfilter(x18, x14)
        x20 = asobject(x19)
        x21 = hperiod(x20)
        x22 = astuple(x21, x17)
        x23 = lbind(multiply, x22)
        x24 = neighbors(ORIGIN)
        x25 = mapply(neighbors, x24)
        x26 = apply(x23, x25)
        x27 = lbind(shift, x12)
        x28 = mapply(x27, x26)
        x29 = paint(I, x28)
        return x29

    def verify_0e206a2e(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = matcher(numcolors, FOUR)
        x2 = sfilter(x0, x1)
        x3 = apply(normalize, x2)
        x4 = merge(x2)
        x5 = cover(I, x4)
        x6 = lbind(compose, flip)
        x7 = lbind(matcher, first)
        x8 = chain(x6, x7, mostcolor)
        x9 = fork(sfilter, identity, x8)
        x10 = chain(invert, ulcorner, x9)
        x11 = lbind(lbind, shift)
        x12 = fork(shift, identity, x10)
        x13 = compose(x11, x12)
        x14 = lbind(fork, mapply)
        x15 = lbind(x14, x13)
        x16 = rbind(compose, x9)
        x17 = lbind(lbind, occurrences)
        x18 = chain(x15, x16, x17)
        x19 = rbind(mapply, x3)
        x20 = compose(x19, x18)
        x21 = fork(paint, identity, x20)
        x22 = chain(identity, x21, identity)
        x23 = chain(dmirror, x21, dmirror)
        x24 = chain(cmirror, x21, cmirror)
        x25 = chain(hmirror, x21, hmirror)
        x26 = chain(vmirror, x21, vmirror)
        x27 = chain(rot90, x21, rot270)
        x28 = chain(rot180, x21, rot180)
        x29 = chain(rot270, x21, rot90)
        x30 = chain(x29, x28, x27)
        x31 = chain(x26, x25, x24)
        x32 = compose(x23, x22)
        x33 = chain(x30, x31, x32)
        x34 = x33(x5)
        return x34

    def verify_10fcaaa3(I: Grid) -> Grid:
        x0 = hconcat(I, I)
        x1 = vconcat(x0, x0)
        x2 = asindices(x1)
        x3 = mostcolor(I)
        x4 = ofcolor(x1, x3)
        x5 = difference(x2, x4)
        x6 = mapply(ineighbors, x5)
        x7 = underfill(x1, EIGHT, x6)
        return x7

    def verify_11852cab(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = lbind(remove, x0)
        x2 = chain(positive, size, x1)
        x3 = compose(x2, palette)
        x4 = multiply(FIVE, UNITY)
        x5 = canvas(ZERO, x4)
        x6 = asindices(x5)
        x7 = fork(add, first, last)
        x8 = chain(flip, even, x7)
        x9 = sfilter(x6, x8)
        x10 = initset(x0)
        x11 = box(x6)
        x12 = inbox(x6)
        x13 = center(x6)
        x14 = initset(x13)
        x15 = lbind(toobject, x11)
        x16 = compose(x3, x15)
        x17 = lbind(toobject, x12)
        x18 = compose(x3, x17)
        x19 = lbind(toobject, x14)
        x20 = compose(x3, x19)
        x21 = fork(both, x18, x20)
        x22 = fork(both, x16, x21)
        x23 = compose(x22, trim)
        x24 = compose(box, asindices)
        x25 = fork(toobject, x24, identity)
        x26 = compose(palette, x25)
        x27 = matcher(x26, x10)
        x28 = lbind(toobject, x9)
        x29 = chain(palette, x28, trim)
        x30 = matcher(x29, x10)
        x31 = compose(minimum, shape)
        x32 = chain(x31, merge, fgpartition)
        x33 = matcher(x32, FIVE)
        x34 = fork(both, x23, x27)
        x35 = fork(both, x30, x33)
        x36 = fork(both, x34, x35)
        x37 = height(I)
        x38 = subtract(x37, THREE)
        x39 = interval(ONE, x38, ONE)
        x40 = width(I)
        x41 = subtract(x40, THREE)
        x42 = interval(ONE, x41, ONE)
        x43 = multiply(SEVEN, UNITY)
        x44 = lbind(crop, I)
        x45 = rbind(x44, x43)
        x46 = chain(x36, x45, decrement)
        x47 = product(x39, x42)
        x48 = sfilter(x47, x46)
        x49 = matcher(first, x0)
        x50 = compose(flip, x49)
        x51 = rbind(sfilter, x50)
        x52 = compose(x51, dmirror)
        x53 = fork(combine, x51, x52)
        x54 = compose(x51, cmirror)
        x55 = compose(x51, hmirror)
        x56 = compose(x51, vmirror)
        x57 = fork(combine, x55, x56)
        x58 = fork(combine, x54, x57)
        x59 = fork(combine, x53, x58)
        x60 = multiply(FOUR, UNITY)
        x61 = rbind(add, x60)
        x62 = fork(insert, x61, initset)
        x63 = compose(backdrop, x62)
        x64 = rbind(toobject, I)
        x65 = chain(x59, x64, x63)
        x66 = mapply(x65, x48)
        x67 = paint(I, x66)
        return x67

    def verify_1190e5a7(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = corners(x0)
        x2 = toobject(x1, I)
        x3 = mostcolor(x2)
        x4 = palette(I)
        x5 = rbind(equality, x3)
        x6 = argmin(x4, x5)
        x7 = asindices(I)
        x8 = ofcolor(I, x3)
        x9 = difference(x7, x8)
        x10 = fill(I, x6, x9)
        x11 = frontiers(x10)
        x12 = sfilter(x11, vline)
        x13 = difference(x11, x12)
        x14 = astuple(x13, x12)
        x15 = apply(size, x14)
        x16 = increment(x15)
        x17 = canvas(x3, x16)
        return x17

    def verify_137eaa0f(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = palette(x1)
        x3 = objects(I, T, F, T)
        x4 = totuple(x3)
        x5 = apply(color, x4)
        x6 = lbind(sfilter, x5)
        x7 = lbind(matcher, identity)
        x8 = chain(size, x6, x7)
        x9 = valmax(x2, x8)
        x10 = matcher(x8, x9)
        x11 = sfilter(x2, x10)
        x12 = lbind(colorcount, I)
        x13 = argmin(x11, x12)
        x14 = ofcolor(I, x13)
        x15 = recolor(x13, x14)
        x16 = apply(initset, x15)
        x17 = remove(x15, x0)
        x18 = lbind(argmin, x16)
        x19 = lbind(rbind, manhattan)
        x20 = compose(x18, x19)
        x21 = fork(combine, identity, x20)
        x22 = apply(x21, x17)
        x23 = matcher(first, x13)
        x24 = rbind(sfilter, x23)
        x25 = chain(invert, ulcorner, x24)
        x26 = fork(shift, identity, x25)
        x27 = mapply(x26, x22)
        x28 = normalize(x27)
        x29 = shape(x28)
        x30 = canvas(ZERO, x29)
        x31 = paint(x30, x28)
        return x31

    def verify_150deff5(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = leastcolor(I)
        x2 = shape(I)
        x3 = add(TWO, x2)
        x4 = canvas(x0, x3)
        x5 = asobject(I)
        x6 = shift(x5, UNITY)
        x7 = paint(x4, x6)
        x8 = astuple(TWO, ONE)
        x9 = dneighbors(UNITY)
        x10 = remove(x8, x9)
        x11 = recolor(x0, x10)
        x12 = initset(UNITY)
        x13 = recolor(x1, x12)
        x14 = combine(x11, x13)
        x15 = astuple(THREE, ONE)
        x16 = connect(UNITY, x15)
        x17 = recolor(TWO, x16)
        x18 = initset(TWO_BY_TWO)
        x19 = insert(UNITY, x18)
        x20 = backdrop(x19)
        x21 = astuple(TWO, THREE)
        x22 = astuple(THREE, TWO)
        x23 = initset(x22)
        x24 = insert(x21, x23)
        x25 = insert(THREE_BY_THREE, x24)
        x26 = recolor(x1, x20)
        x27 = outbox(x20)
        x28 = difference(x27, x25)
        x29 = recolor(x0, x28)
        x30 = combine(x26, x29)
        x31 = recolor(EIGHT, x20)
        x32 = lbind(lbind, shift)
        x33 = compose(x32, last)
        x34 = lbind(fork, paint)
        x35 = lbind(x34, identity)
        x36 = lbind(lbind, mapply)
        x37 = compose(x36, x33)
        x38 = lbind(rbind, occurrences)
        x39 = compose(x38, first)
        x40 = fork(compose, x37, x39)
        x41 = compose(x35, x40)
        x42 = astuple(x14, x17)
        x43 = x41(x42)
        x44 = compose(rot90, x43)
        x45 = power(x44, FOUR)
        x46 = astuple(x30, x31)
        x47 = x41(x46)
        x48 = compose(rot90, x47)
        x49 = power(x48, FOUR)
        x50 = compose(x45, x49)
        x51 = initset(ORIGIN)
        x52 = difference(x51, x51)
        x53 = lbind(recolor, TWO)
        x54 = rbind(ofcolor, TWO)
        x55 = compose(x53, x54)
        x56 = lbind(recolor, EIGHT)
        x57 = rbind(ofcolor, EIGHT)
        x58 = compose(x56, x57)
        x59 = fork(combine, x55, x58)
        x60 = lbind(recolor, x0)
        x61 = compose(x60, x59)
        x62 = fork(paint, identity, x61)
        x63 = chain(x62, x50, first)
        x64 = chain(x59, x50, first)
        x65 = fork(combine, last, x64)
        x66 = fork(astuple, x63, x65)
        x67 = astuple(x7, x52)
        x68 = power(x66, FIVE)
        x69 = x68(x67)
        x70 = first(x69)
        x71 = last(x69)
        x72 = paint(x70, x71)
        x73 = trim(x72)
        return x73

    def verify_178fcbfb(I: Grid) -> Grid:
        x0 = ofcolor(I, TWO)
        x1 = ofcolor(I, THREE)
        x2 = ofcolor(I, ONE)
        x3 = mapply(vfrontier, x0)
        x4 = mapply(hfrontier, x1)
        x5 = mapply(hfrontier, x2)
        x6 = fill(I, TWO, x3)
        x7 = fill(x6, THREE, x4)
        x8 = fill(x7, ONE, x5)
        return x8

    def verify_1a07d186(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = mostcolor(I)
        x2 = asindices(I)
        x3 = ofcolor(I, x1)
        x4 = difference(x2, x3)
        x5 = mapply(toindices, x0)
        x6 = difference(x4, x5)
        x7 = toobject(x6, I)
        x8 = apply(initset, x7)
        x9 = fill(I, x1, x6)
        x10 = lbind(fork, shift)
        x11 = lbind(x10, identity)
        x12 = lbind(rbind, gravitate)
        x13 = compose(x11, x12)
        x14 = lbind(colorfilter, x8)
        x15 = compose(x14, color)
        x16 = fork(mapply, x13, x15)
        x17 = mapply(x16, x0)
        x18 = paint(x9, x17)
        return x18

    def verify_1b2d62fb(I: Grid) -> Grid:
        x0 = width(I)
        x1 = halve(x0)
        x2 = tojvec(x1)
        x3 = height(I)
        x4 = decrement(x3)
        x5 = astuple(x4, x1)
        x6 = connect(x2, x5)
        x7 = toobject(x6, I)
        x8 = numcolors(x7)
        x9 = equality(x8, ONE)
        x10 = branch(x9, lefthalf, tophalf)
        x11 = branch(x9, righthalf, bottomhalf)
        x12 = x10(I)
        x13 = x11(I)
        x14 = shape(x12)
        x15 = canvas(ZERO, x14)
        x16 = ofcolor(x12, ZERO)
        x17 = ofcolor(x13, ZERO)
        x18 = intersection(x16, x17)
        x19 = fill(x15, EIGHT, x18)
        return x19

    def verify_1b60fb0c(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = mapply(toindices, x0)
        x2 = rot90(I)
        x3 = fgpartition(x2)
        x4 = mapply(toindices, x3)
        x5 = normalize(x4)
        x6 = ulcorner(x1)
        x7 = shift(x5, x6)
        x8 = shape(x1)
        x9 = maximum(x8)
        x10 = minimum(x8)
        x11 = subtract(x9, x10)
        x12 = increment(x11)
        x13 = power(outbox, x12)
        x14 = center(x7)
        x15 = x13(x7)
        x16 = backdrop(x15)
        x17 = invert(x14)
        x18 = shift(x16, x17)
        x19 = lbind(combine, x1)
        x20 = lbind(shift, x7)
        x21 = compose(x19, x20)
        x22 = rbind(ofcolor, ONE)
        x23 = lbind(canvas, ZERO)
        x24 = chain(x23, shape, x21)
        x25 = lbind(recolor, ONE)
        x26 = chain(x25, normalize, x21)
        x27 = fork(paint, x24, x26)
        x28 = chain(x22, rot90, x27)
        x29 = compose(normalize, x21)
        x30 = fork(equality, x29, x28)
        x31 = sfilter(x18, x30)
        x32 = lbind(intersection, x1)
        x33 = lbind(shift, x7)
        x34 = chain(size, x32, x33)
        x35 = argmax(x31, x34)
        x36 = shift(x7, x35)
        x37 = difference(x36, x1)
        x38 = fill(I, TWO, x37)
        return x38

    def verify_1bfc4729(I: Grid) -> Grid:
        x0 = tophalf(I)
        x1 = bottomhalf(I)
        x2 = leastcolor(x0)
        x3 = leastcolor(x1)
        x4 = ofcolor(I, x2)
        x5 = center(x4)
        x6 = ofcolor(I, x3)
        x7 = center(x6)
        x8 = height(I)
        x9 = width(I)
        x10 = hfrontier(x5)
        x11 = fill(I, x2, x10)
        x12 = hfrontier(x7)
        x13 = fill(x11, x3, x12)
        x14 = decrement(x9)
        x15 = decrement(x8)
        x16 = halve(x8)
        x17 = tojvec(x14)
        x18 = connect(ORIGIN, x17)
        x19 = fill(x13, x2, x18)
        x20 = toivec(x15)
        x21 = astuple(x15, x14)
        x22 = connect(x20, x21)
        x23 = fill(x19, x3, x22)
        x24 = decrement(x16)
        x25 = toivec(x24)
        x26 = connect(ORIGIN, x25)
        x27 = fill(x23, x2, x26)
        x28 = tojvec(x14)
        x29 = decrement(x16)
        x30 = astuple(x29, x14)
        x31 = connect(x28, x30)
        x32 = fill(x27, x2, x31)
        x33 = toivec(x16)
        x34 = toivec(x15)
        x35 = connect(x33, x34)
        x36 = fill(x32, x3, x35)
        x37 = astuple(x16, x14)
        x38 = astuple(x15, x14)
        x39 = connect(x37, x38)
        x40 = fill(x36, x3, x39)
        return x40

    def verify_1c786137(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = lbind(colorfilter, x0)
        x2 = compose(size, x1)
        x3 = matcher(x2, ONE)
        x4 = palette(I)
        x5 = sfilter(x4, x3)
        x6 = fork(equality, toindices, box)
        x7 = rbind(contained, x5)
        x8 = compose(x7, color)
        x9 = sfilter(x0, x8)
        x10 = rbind(greater, SEVEN)
        x11 = compose(x10, size)
        x12 = sfilter(x9, x11)
        x13 = extract(x12, x6)
        x14 = subgrid(x13, I)
        x15 = trim(x14)
        return x15

    def verify_1caeab9d(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = ofcolor(I, ONE)
        x2 = lowermost(x1)
        x3 = lbind(subtract, x2)
        x4 = chain(toivec, x3, lowermost)
        x5 = fork(shift, identity, x4)
        x6 = merge(x0)
        x7 = cover(I, x6)
        x8 = mapply(x5, x0)
        x9 = paint(x7, x8)
        return x9

    def verify_1cf80156(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = color(x1)
        x3 = palette(I)
        x4 = other(x3, x2)
        x5 = objects(I, T, T, F)
        x6 = matcher(color, x4)
        x7 = extract(x5, x6)
        x8 = subgrid(x7, I)
        return x8

    def verify_1e0a9b12(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = rot270(I)
        x2 = matcher(identity, x0)
        x3 = rbind(sfilter, x2)
        x4 = compose(flip, x2)
        x5 = rbind(sfilter, x4)
        x6 = fork(combine, x3, x5)
        x7 = apply(x6, x1)
        x8 = rot90(x7)
        return x8

    def verify_1e32b0e9(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = totuple(x0)
        x2 = apply(color, x1)
        x3 = leastcommon(x2)
        x4 = matcher(color, x3)
        x5 = sfilter(x0, x4)
        x6 = merge(x5)
        x7 = color(x6)
        x8 = shape(I)
        x9 = canvas(x7, x8)
        x10 = hconcat(I, x9)
        x11 = objects(x10, F, T, T)
        x12 = first(x11)
        x13 = box(x12)
        x14 = rbind(contained, x13)
        x15 = compose(x14, last)
        x16 = sfilter(x12, x15)
        x17 = color(x16)
        x18 = palette(I)
        x19 = remove(x7, x18)
        x20 = other(x19, x17)
        x21 = rbind(colorcount, x17)
        x22 = argmin(x11, x21)
        x23 = apply(ulcorner, x11)
        x24 = normalize(x22)
        x25 = matcher(first, x20)
        x26 = sfilter(x24, x25)
        x27 = toindices(x26)
        x28 = lbind(shift, x27)
        x29 = mapply(x28, x23)
        x30 = ofcolor(I, x20)
        x31 = difference(x29, x30)
        x32 = fill(I, x7, x31)
        return x32

    def verify_1f0c79e5(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = rbind(other, TWO)
        x2 = compose(x1, palette)
        x3 = matcher(first, TWO)
        x4 = rbind(sfilter, x3)
        x5 = compose(x4, normalize)
        x6 = lbind(apply, double)
        x7 = chain(x6, toindices, x5)
        x8 = rbind(add, NEG_ONE)
        x9 = lbind(apply, x8)
        x10 = compose(x9, x7)
        x11 = lbind(rbind, shoot)
        x12 = rbind(compose, x11)
        x13 = lbind(rbind, mapply)
        x14 = chain(x12, x13, toindices)
        x15 = fork(mapply, x14, x10)
        x16 = fork(recolor, x2, x15)
        x17 = mapply(x16, x0)
        x18 = paint(I, x17)
        return x18

    def verify_1f642eb9(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = fork(multiply, height, width)
        x2 = fork(equality, size, x1)
        x3 = sfilter(x0, x2)
        x4 = argmax(x3, size)
        x5 = outbox(x4)
        x6 = corners(x5)
        x7 = toobject(x6, I)
        x8 = color(x7)
        x9 = asindices(I)
        x10 = ofcolor(I, x8)
        x11 = toindices(x4)
        x12 = combine(x10, x11)
        x13 = difference(x9, x12)
        x14 = toobject(x13, I)
        x15 = apply(initset, x14)
        x16 = rbind(gravitate, x4)
        x17 = compose(crement, x16)
        x18 = fork(shift, identity, x17)
        x19 = mapply(x18, x15)
        x20 = paint(I, x19)
        return x20

    def verify_1f85a75f(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = totuple(x0)
        x2 = apply(color, x1)
        x3 = lbind(sfilter, x2)
        x4 = lbind(matcher, identity)
        x5 = chain(size, x3, x4)
        x6 = matcher(x5, ONE)
        x7 = sfilter(x2, x6)
        x8 = lbind(colorcount, I)
        x9 = argmax(x7, x8)
        x10 = matcher(color, x9)
        x11 = extract(x0, x10)
        x12 = subgrid(x11, I)
        return x12

    def verify_1f876c06(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = compose(last, first)
        x2 = power(last, TWO)
        x3 = fork(connect, x1, x2)
        x4 = fork(recolor, color, x3)
        x5 = mapply(x4, x0)
        x6 = paint(I, x5)
        return x6

    def verify_1fad071e(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = colorfilter(x0, ONE)
        x2 = sizefilter(x1, FOUR)
        x3 = fork(equality, height, width)
        x4 = sfilter(x2, x3)
        x5 = size(x4)
        x6 = subtract(FIVE, x5)
        x7 = astuple(ONE, x5)
        x8 = canvas(ONE, x7)
        x9 = astuple(ONE, x6)
        x10 = mostcolor(I)
        x11 = canvas(x10, x9)
        x12 = hconcat(x8, x11)
        return x12

    def verify_2013d3e2(I: Grid) -> Grid:
        x0 = lbind(apply, last)
        x1 = compose(positive, first)
        x2 = lbind(interval, ZERO)
        x3 = rbind(x2, ONE)
        x4 = rbind(sfilter, x1)
        x5 = compose(x3, size)
        x6 = fork(pair, x5, identity)
        x7 = chain(x0, x4, x6)
        x8 = rbind(branch, identity)
        x9 = rbind(x8, x7)
        x10 = chain(size, dedupe, first)
        x11 = lbind(equality, ONE)
        x12 = chain(x9, x11, x10)
        x13 = compose(initset, x12)
        x14 = fork(rapply, x13, identity)
        x15 = compose(first, x14)
        x16 = rbind(branch, identity)
        x17 = rbind(x16, x15)
        x18 = chain(x17, positive, size)
        x19 = compose(initset, x18)
        x20 = fork(rapply, x19, identity)
        x21 = compose(first, x20)
        x22 = multiply(TEN, THREE)
        x23 = power(x21, x22)
        x24 = compose(rot90, x23)
        x25 = power(x24, FOUR)
        x26 = x25(I)
        x27 = lefthalf(x26)
        x28 = tophalf(x27)
        return x28

    def verify_2204b7a8(I: Grid) -> Grid:
        x0 = first(I)
        x1 = dedupe(x0)
        x2 = size(x1)
        x3 = equality(x2, ONE)
        x4 = flip(x3)
        x5 = branch(x4, lefthalf, tophalf)
        x6 = branch(x4, righthalf, bottomhalf)
        x7 = branch(x4, hconcat, vconcat)
        x8 = x5(I)
        x9 = x6(I)
        x10 = index(x8, ORIGIN)
        x11 = shape(x9)
        x12 = decrement(x11)
        x13 = index(x9, x12)
        x14 = mostcolor(I)
        x15 = mostcolor(I)
        x16 = palette(I)
        x17 = remove(x10, x16)
        x18 = remove(x13, x17)
        x19 = remove(x15, x18)
        x20 = first(x19)
        x21 = replace(x8, x20, x10)
        x22 = branch(x4, dmirror, identity)
        x23 = branch(x4, height, width)
        x24 = x23(I)
        x25 = astuple(ONE, x24)
        x26 = canvas(x14, x25)
        x27 = x22(x26)
        x28 = replace(x9, x20, x13)
        x29 = x7(x21, x27)
        x30 = branch(x4, width, height)
        x31 = x30(I)
        x32 = even(x31)
        x33 = branch(x32, x21, x29)
        x34 = x7(x33, x28)
        return x34

    def verify_22168020(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = mostcolor(I)
        x2 = remove(x1, x0)
        x3 = lbind(ofcolor, I)
        x4 = lbind(prapply, connect)
        x5 = fork(x4, x3, x3)
        x6 = compose(merge, x5)
        x7 = fork(recolor, identity, x6)
        x8 = mapply(x7, x2)
        x9 = paint(I, x8)
        return x9

    def verify_22233c11(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = rbind(upscale, TWO)
        x2 = chain(invert, halve, shape)
        x3 = fork(combine, hfrontier, vfrontier)
        x4 = compose(x1, vmirror)
        x5 = fork(shift, x4, x2)
        x6 = compose(toindices, x5)
        x7 = lbind(mapply, x3)
        x8 = compose(x7, toindices)
        x9 = fork(difference, x6, x8)
        x10 = mapply(x9, x0)
        x11 = fill(I, EIGHT, x10)
        return x11

    def verify_2281f1f4(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = apply(first, x1)
        x3 = apply(last, x1)
        x4 = product(x2, x3)
        x5 = difference(x4, x1)
        x6 = fill(I, TWO, x5)
        x7 = lbind(fork, either)
        x8 = lbind(matcher, first)
        x9 = compose(x8, first)
        x10 = lbind(matcher, last)
        x11 = compose(x10, last)
        x12 = fork(x7, x9, x11)
        x13 = lbind(sfilter, x1)
        x14 = chain(size, x13, x12)
        x15 = asindices(I)
        x16 = corners(x15)
        x17 = argmax(x16, x14)
        x18 = mostcolor(I)
        x19 = initset(x17)
        x20 = fill(x6, x18, x19)
        return x20

    def verify_228f6490(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = objects(I, T, T, F)
        x2 = colorfilter(x1, x0)
        x3 = compose(normalize, toindices)
        x4 = difference(x1, x2)
        x5 = rbind(bordering, I)
        x6 = compose(flip, x5)
        x7 = sfilter(x2, x6)
        x8 = rbind(toobject, I)
        x9 = lbind(mapply, neighbors)
        x10 = compose(x9, toindices)
        x11 = fork(difference, x10, identity)
        x12 = chain(mostcolor, x8, x11)
        x13 = totuple(x7)
        x14 = apply(x12, x13)
        x15 = mostcommon(x14)
        x16 = matcher(x12, x15)
        x17 = sfilter(x7, x16)
        x18 = lbind(argmax, x4)
        x19 = lbind(matcher, x3)
        x20 = chain(x18, x19, x3)
        x21 = compose(color, x20)
        x22 = fork(recolor, x21, identity)
        x23 = mapply(x20, x17)
        x24 = cover(I, x23)
        x25 = mapply(x22, x17)
        x26 = paint(x24, x25)
        return x26

    def verify_22eb0ac0(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = asobject(I)
        x2 = matcher(first, x0)
        x3 = compose(flip, x2)
        x4 = sfilter(x1, x3)
        x5 = apply(initset, x4)
        x6 = product(x5, x5)
        x7 = compose(color, first)
        x8 = compose(color, last)
        x9 = fork(equality, x7, x8)
        x10 = sfilter(x6, x9)
        x11 = compose(leftmost, first)
        x12 = compose(leftmost, last)
        x13 = fork(equality, x11, x12)
        x14 = compose(uppermost, first)
        x15 = compose(uppermost, last)
        x16 = fork(equality, x14, x15)
        x17 = fork(either, x13, x16)
        x18 = sfilter(x10, x17)
        x19 = compose(color, first)
        x20 = compose(center, first)
        x21 = compose(center, last)
        x22 = fork(connect, x20, x21)
        x23 = fork(recolor, x19, x22)
        x24 = height(I)
        x25 = width(I)
        x26 = matcher(last, ZERO)
        x27 = decrement(x25)
        x28 = matcher(last, x27)
        x29 = fork(either, x26, x28)
        x30 = matcher(first, ZERO)
        x31 = decrement(x24)
        x32 = matcher(first, x31)
        x33 = fork(either, x30, x32)
        x34 = toindices(x4)
        x35 = sfilter(x34, x29)
        x36 = equality(x34, x35)
        x37 = mapply(x23, x18)
        x38 = paint(I, x37)
        x39 = branch(x36, x29, x33)
        x40 = asindices(I)
        x41 = sfilter(x40, x39)
        x42 = toobject(x41, I)
        x43 = paint(x38, x42)
        return x43

    def verify_234bbc79(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = order(x0, leftmost)
        x2 = astuple(ONE, TWO)
        x3 = rbind(contained, x2)
        x4 = lbind(compose, x3)
        x5 = lbind(rbind, colorcount)
        x6 = compose(x4, x5)
        x7 = lbind(sfilter, x0)
        x8 = chain(size, x7, x6)
        x9 = size(x0)
        x10 = matcher(x8, x9)
        x11 = palette(I)
        x12 = sfilter(x11, x10)
        x13 = lbind(colorcount, I)
        x14 = argmin(x12, x13)
        x15 = matcher(first, x14)
        x16 = rbind(extract, x15)
        x17 = compose(x16, first)
        x18 = fork(remove, x17, first)
        x19 = rbind(compose, initset)
        x20 = lbind(rbind, manhattan)
        x21 = compose(initset, x17)
        x22 = chain(x19, x20, x21)
        x23 = fork(argmin, x18, x22)
        x24 = compose(last, x17)
        x25 = compose(first, x23)
        x26 = fork(astuple, x25, x24)
        x27 = fork(insert, x26, x18)
        x28 = compose(last, last)
        x29 = rbind(argmin, x28)
        x30 = rbind(sfilter, x15)
        x31 = compose(first, last)
        x32 = chain(x29, x30, x31)
        x33 = compose(flip, x15)
        x34 = rbind(sfilter, x33)
        x35 = compose(first, last)
        x36 = fork(remove, x32, x35)
        x37 = compose(x34, x36)
        x38 = rbind(compose, initset)
        x39 = lbind(rbind, manhattan)
        x40 = compose(initset, x32)
        x41 = chain(x38, x39, x40)
        x42 = fork(argmin, x37, x41)
        x43 = compose(first, x42)
        x44 = compose(last, x32)
        x45 = fork(astuple, x43, x44)
        x46 = compose(first, last)
        x47 = fork(remove, x32, x46)
        x48 = fork(insert, x45, x47)
        x49 = rbind(shift, RIGHT)
        x50 = compose(last, x32)
        x51 = fork(subtract, x24, x50)
        x52 = fork(shift, x48, x51)
        x53 = compose(x49, x52)
        x54 = fork(combine, x27, x53)
        x55 = compose(first, last)
        x56 = fork(remove, x55, last)
        x57 = fork(astuple, x54, x56)
        x58 = size(x0)
        x59 = decrement(x58)
        x60 = power(x57, x59)
        x61 = first(x1)
        x62 = remove(x61, x1)
        x63 = astuple(x61, x62)
        x64 = x60(x63)
        x65 = first(x64)
        x66 = merge(x0)
        x67 = cover(I, x66)
        x68 = paint(x67, x65)
        x69 = height(I)
        x70 = width(x65)
        x71 = astuple(x69, x70)
        x72 = crop(x68, ORIGIN, x71)
        x73 = ofcolor(x72, x14)
        x74 = mostcolor(I)
        x75 = palette(x72)
        x76 = contained(x14, x75)
        x77 = matcher(first, x74)
        x78 = compose(flip, x77)
        x79 = rbind(sfilter, x78)
        x80 = mapply(dneighbors, x73)
        x81 = lbind(toobject, x80)
        x82 = compose(x79, x81)
        x83 = rbind(recolor, x73)
        x84 = chain(x83, mostcolor, x82)
        x85 = fork(paint, identity, x84)
        x86 = branch(x76, x85, identity)
        x87 = x86(x72)
        return x87

    def verify_23581191(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = palette(I)
        x2 = remove(x0, x1)
        x3 = totuple(x2)
        x4 = fork(combine, hfrontier, vfrontier)
        x5 = lbind(mapply, x4)
        x6 = lbind(ofcolor, I)
        x7 = compose(x5, x6)
        x8 = first(x3)
        x9 = last(x3)
        x10 = x7(x8)
        x11 = x7(x9)
        x12 = ofcolor(I, x0)
        x13 = intersection(x12, x10)
        x14 = intersection(x12, x11)
        x15 = intersection(x10, x11)
        x16 = intersection(x12, x15)
        x17 = fill(I, x8, x13)
        x18 = fill(x17, x9, x14)
        x19 = fill(x18, TWO, x16)
        return x19

    def verify_239be575(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = lbind(apply, normalize)
        x2 = lbind(colorfilter, x0)
        x3 = chain(size, x1, x2)
        x4 = matcher(x3, ONE)
        x5 = lbind(colorcount, I)
        x6 = matcher(x5, EIGHT)
        x7 = lbind(colorfilter, x0)
        x8 = compose(size, x7)
        x9 = matcher(x8, TWO)
        x10 = fork(both, x6, x9)
        x11 = fork(both, x10, x4)
        x12 = palette(I)
        x13 = extract(x12, x11)
        x14 = colorfilter(x0, x13)
        x15 = totuple(x14)
        x16 = first(x15)
        x17 = last(x15)
        x18 = palette(I)
        x19 = remove(ZERO, x18)
        x20 = remove(x13, x19)
        x21 = first(x20)
        x22 = colorfilter(x0, x21)
        x23 = rbind(adjacent, x16)
        x24 = rbind(adjacent, x17)
        x25 = fork(both, x23, x24)
        x26 = sfilter(x22, x25)
        x27 = size(x26)
        x28 = positive(x27)
        x29 = branch(x28, x21, ZERO)
        x30 = canvas(x29, UNITY)
        return x30

    def verify_23b5c85d(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = fork(equality, size, x1)
        x3 = sfilter(x0, x2)
        x4 = argmin(x3, x1)
        x5 = subgrid(x4, I)
        return x5

    def verify_253bf280(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = prapply(connect, x1, x1)
        x3 = rbind(greater, ONE)
        x4 = compose(x3, size)
        x5 = sfilter(x2, x4)
        x6 = fork(either, vline, hline)
        x7 = mfilter(x5, x6)
        x8 = fill(I, THREE, x7)
        x9 = leastcolor(I)
        x10 = fill(x8, x9, x1)
        return x10

    def verify_25d487eb(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = lbind(matcher, first)
        x2 = compose(x1, leastcolor)
        x3 = lbind(matcher, first)
        x4 = compose(x3, mostcolor)
        x5 = fork(extract, identity, x2)
        x6 = compose(last, x5)
        x7 = compose(dneighbors, x6)
        x8 = lbind(apply, last)
        x9 = fork(sfilter, identity, x4)
        x10 = compose(x8, x9)
        x11 = fork(difference, x7, x10)
        x12 = compose(first, x11)
        x13 = fork(subtract, x6, x12)
        x14 = fork(shoot, x6, x13)
        x15 = fork(recolor, leastcolor, x14)
        x16 = mapply(x15, x0)
        x17 = underpaint(I, x16)
        return x17

    def verify_25d8a9c8(I: Grid) -> Grid:
        x0 = width(I)
        x1 = rbind(branch, ZERO)
        x2 = rbind(x1, FIVE)
        x3 = compose(size, dedupe)
        x4 = matcher(x3, ONE)
        x5 = compose(x2, x4)
        x6 = rbind(repeat, x0)
        x7 = compose(x6, x5)
        x8 = apply(x7, I)
        return x8

    def verify_25ff71a9(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = first(x0)
        x2 = move(I, x1, DOWN)
        return x2

    def verify_264363fd(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = fork(multiply, height, width)
        x2 = argmax(x0, x1)
        x3 = mostcolor(x2)
        x4 = shape(I)
        x5 = canvas(x3, x4)
        x6 = hconcat(I, x5)
        x7 = objects(x6, F, F, T)
        x8 = argmin(x7, size)
        x9 = cover(I, x8)
        x10 = normalize(x8)
        x11 = remove(x8, x7)
        x12 = toindices(x10)
        x13 = lbind(intersection, x12)
        x14 = chain(x13, dneighbors, last)
        x15 = rbind(greater, ONE)
        x16 = chain(x15, size, x14)
        x17 = sfilter(x10, x16)
        x18 = center(x17)
        x19 = matcher(last, x18)
        x20 = extract(x17, x19)
        x21 = first(x20)
        x22 = difference(x10, x17)
        x23 = color(x22)
        x24 = center(x17)
        x25 = invert(x24)
        x26 = shift(x10, x25)
        x27 = invert(x24)
        x28 = shift(x22, x27)
        x29 = toindices(x28)
        x30 = rbind(mapply, x29)
        x31 = lbind(lbind, shoot)
        x32 = compose(x30, x31)
        x33 = power(outbox, TWO)
        x34 = chain(backdrop, x33, initset)
        x35 = fork(difference, x32, x34)
        x36 = lbind(recolor, x23)
        x37 = compose(x36, x35)
        x38 = lbind(shift, x26)
        x39 = fork(combine, x37, x38)
        x40 = lbind(mapply, x39)
        x41 = rbind(ofcolor, x21)
        x42 = compose(x40, x41)
        x43 = fork(paint, identity, x42)
        x44 = rbind(subgrid, I)
        x45 = chain(asobject, x43, x44)
        x46 = fork(shift, x45, ulcorner)
        x47 = mapply(x46, x11)
        x48 = paint(x9, x47)
        return x48

    def verify_272f95fa(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = index(I, ORIGIN)
        x2 = colorfilter(x0, x1)
        x3 = apply(toindices, x2)
        x4 = rbind(bordering, I)
        x5 = compose(flip, x4)
        x6 = extract(x3, x5)
        x7 = remove(x6, x3)
        x8 = lbind(vmatching, x6)
        x9 = lbind(hmatching, x6)
        x10 = sfilter(x7, x8)
        x11 = sfilter(x7, x9)
        x12 = argmin(x10, uppermost)
        x13 = argmax(x10, uppermost)
        x14 = argmin(x11, leftmost)
        x15 = argmax(x11, leftmost)
        x16 = fill(I, SIX, x6)
        x17 = fill(x16, TWO, x12)
        x18 = fill(x17, ONE, x13)
        x19 = fill(x18, FOUR, x14)
        x20 = fill(x19, THREE, x15)
        return x20

    def verify_27a28665(I: Grid) -> Grid:
        x0 = lbind(apply, last)
        x1 = compose(positive, first)
        x2 = lbind(interval, ZERO)
        x3 = rbind(x2, ONE)
        x4 = rbind(sfilter, x1)
        x5 = compose(x3, size)
        x6 = fork(pair, x5, identity)
        x7 = chain(x0, x4, x6)
        x8 = rbind(branch, identity)
        x9 = rbind(x8, x7)
        x10 = chain(size, dedupe, first)
        x11 = lbind(equality, ONE)
        x12 = chain(x9, x11, x10)
        x13 = compose(initset, x12)
        x14 = fork(rapply, x13, identity)
        x15 = compose(first, x14)
        x16 = rbind(branch, identity)
        x17 = rbind(x16, x15)
        x18 = chain(x17, positive, size)
        x19 = compose(initset, x18)
        x20 = fork(rapply, x19, identity)
        x21 = compose(first, x20)
        x22 = multiply(TEN, THREE)
        x23 = power(x21, x22)
        x24 = compose(rot90, x23)
        x25 = power(x24, FOUR)
        x26 = x25(I)
        x27 = width(x26)
        x28 = divide(x27, THREE)
        x29 = downscale(x26, x28)
        x30 = objects(x29, T, F, F)
        x31 = valmax(x30, size)
        x32 = equality(x31, ONE)
        x33 = equality(x31, FOUR)
        x34 = equality(x31, FIVE)
        x35 = branch(x32, TWO, ONE)
        x36 = branch(x33, THREE, x35)
        x37 = branch(x34, SIX, x36)
        x38 = canvas(x37, UNITY)
        return x38

    def verify_28bf18c6(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = first(x0)
        x2 = subgrid(x1, I)
        x3 = hconcat(x2, x2)
        return x3

    def verify_28e73c20(I: Grid) -> Grid:
        x0 = astuple(RIGHT, DOWN)
        x1 = astuple(DOWN, LEFT)
        x2 = astuple(x0, x1)
        x3 = astuple(LEFT, UP)
        x4 = astuple(UP, RIGHT)
        x5 = astuple(x3, x4)
        x6 = combine(x2, x5)
        x7 = height(I)
        x8 = astuple(x7, ONE)
        x9 = canvas(THREE, x8)
        x10 = hconcat(x9, I)
        x11 = height(x10)
        x12 = width(x10)
        x13 = decrement(x12)
        x14 = tojvec(x13)
        x15 = identity(DOWN)
        x16 = connect(ORIGIN, x14)
        x17 = fill(x10, THREE, x16)
        x18 = identity(x12)
        x19 = identity(x11)
        x20 = identity(x11)
        x21 = identity(F)
        x22 = identity(ZERO)
        x23 = compose(first, first)
        x24 = chain(first, last, x23)
        x25 = compose(first, first)
        x26 = chain(last, last, x25)
        x27 = chain(first, first, first)
        x28 = chain(first, last, last)
        x29 = chain(first, first, last)
        x30 = chain(last, first, last)
        x31 = compose(decrement, x24)
        x32 = compose(decrement, x26)
        x33 = fork(astuple, x31, x32)
        x34 = compose(decrement, x26)
        x35 = fork(multiply, x29, x34)
        x36 = fork(add, x28, x35)
        x37 = compose(decrement, x27)
        x38 = fork(multiply, x29, x37)
        x39 = fork(add, x28, x38)
        x40 = fork(astuple, x39, x36)
        x41 = lbind(extract, x6)
        x42 = lbind(matcher, first)
        x43 = compose(x42, x29)
        x44 = chain(last, x41, x43)
        x45 = compose(last, first)
        x46 = lbind(recolor, THREE)
        x47 = compose(decrement, x27)
        x48 = fork(multiply, x29, x47)
        x49 = fork(add, x28, x48)
        x50 = fork(connect, x28, x49)
        x51 = compose(x46, x50)
        x52 = fork(paint, x45, x51)
        x53 = compose(decrement, x26)
        x54 = fork(multiply, x30, x53)
        x55 = compose(flip, x30)
        x56 = compose(decrement, x24)
        x57 = fork(multiply, x55, x56)
        x58 = fork(add, x54, x57)
        x59 = power(first, THREE)
        x60 = chain(flip, positive, x59)
        x61 = fork(astuple, x58, x33)
        x62 = compose(flip, x30)
        x63 = fork(astuple, x44, x62)
        x64 = fork(astuple, x61, x52)
        x65 = fork(astuple, x63, x40)
        x66 = fork(astuple, x64, x65)
        x67 = rbind(branch, x66)
        x68 = rbind(x67, identity)
        x69 = chain(initset, x68, x60)
        x70 = fork(rapply, x69, identity)
        x71 = compose(first, x70)
        x72 = multiply(TEN, THREE)
        x73 = power(x71, x72)
        x74 = astuple(x18, x19)
        x75 = astuple(x15, x21)
        x76 = astuple(x14, x22)
        x77 = astuple(x20, x74)
        x78 = astuple(x75, x76)
        x79 = astuple(x77, x17)
        x80 = astuple(x79, x78)
        x81 = x73(x80)
        x82 = first(x81)
        x83 = last(x82)
        x84 = dmirror(x83)
        x85 = shape(x84)
        x86 = add(x85, UP)
        x87 = crop(x84, DOWN, x86)
        x88 = dmirror(x87)
        return x88

    def verify_29623171(I: Grid) -> Grid:
        x0 = compress(I)
        x1 = leastcolor(x0)
        x2 = mostcolor(x0)
        x3 = frontiers(I)
        x4 = sfilter(x3, hline)
        x5 = size(x4)
        x6 = increment(x5)
        x7 = sfilter(x3, vline)
        x8 = size(x7)
        x9 = increment(x8)
        x10 = height(I)
        x11 = decrement(x6)
        x12 = subtract(x10, x11)
        x13 = divide(x12, x6)
        x14 = width(I)
        x15 = decrement(x9)
        x16 = subtract(x14, x15)
        x17 = divide(x16, x9)
        x18 = astuple(x13, x17)
        x19 = canvas(ZERO, x18)
        x20 = asindices(x19)
        x21 = astuple(x6, x9)
        x22 = canvas(ZERO, x21)
        x23 = asindices(x22)
        x24 = astuple(x13, x17)
        x25 = increment(x24)
        x26 = rbind(multiply, x25)
        x27 = apply(x26, x23)
        x28 = rbind(toobject, I)
        x29 = lbind(shift, x20)
        x30 = compose(x28, x29)
        x31 = apply(x30, x27)
        x32 = rbind(colorcount, x1)
        x33 = valmax(x31, x32)
        x34 = rbind(colorcount, x1)
        x35 = matcher(x34, x33)
        x36 = mfilter(x31, x35)
        x37 = replace(I, x1, x2)
        x38 = fill(x37, x1, x36)
        return x38

    def verify_29c11459(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = product(x0, x0)
        x2 = fork(hmatching, first, last)
        x3 = fork(vmatching, first, last)
        x4 = fork(either, x2, x3)
        x5 = sfilter(x1, x4)
        x6 = mostcolor(I)
        x7 = rbind(toobject, I)
        x8 = compose(delta, merge)
        x9 = chain(palette, x7, x8)
        x10 = initset(x6)
        x11 = matcher(x9, x10)
        x12 = sfilter(x5, x11)
        x13 = shape(I)
        x14 = subtract(x13, TWO_BY_ZERO)
        x15 = crop(I, DOWN, x14)
        x16 = numcolors(x15)
        x17 = equality(ONE, x16)
        x18 = branch(x17, vline, hline)
        x19 = compose(center, first)
        x20 = compose(center, last)
        x21 = fork(add, x19, x20)
        x22 = compose(halve, x21)
        x23 = compose(color, first)
        x24 = compose(color, last)
        x25 = fork(connect, x19, x22)
        x26 = fork(remove, x22, x25)
        x27 = fork(recolor, x23, x26)
        x28 = fork(connect, x20, x22)
        x29 = fork(remove, x22, x28)
        x30 = fork(recolor, x24, x29)
        x31 = lbind(recolor, FIVE)
        x32 = chain(x31, initset, x22)
        x33 = fork(combine, x27, x30)
        x34 = fork(combine, x33, x32)
        x35 = apply(x34, x12)
        x36 = mfilter(x35, x18)
        x37 = paint(I, x36)
        x38 = merge(x0)
        x39 = paint(x37, x38)
        return x39

    def verify_29ec7d0e(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = objects(I, T, F, F)
        x2 = lbind(colorfilter, x1)
        x3 = compose(size, x2)
        x4 = valmin(x0, x3)
        x5 = matcher(x3, x4)
        x6 = sfilter(x0, x5)
        x7 = lbind(colorcount, I)
        x8 = argmin(x6, x7)
        x9 = asobject(I)
        x10 = matcher(first, x8)
        x11 = compose(flip, x10)
        x12 = sfilter(x9, x11)
        x13 = lbind(contained, x8)
        x14 = compose(flip, x13)
        x15 = sfilter(I, x14)
        x16 = asobject(x15)
        x17 = hperiod(x16)
        x18 = dmirror(I)
        x19 = sfilter(x18, x14)
        x20 = asobject(x19)
        x21 = hperiod(x20)
        x22 = astuple(x21, x17)
        x23 = lbind(multiply, x22)
        x24 = neighbors(ORIGIN)
        x25 = mapply(neighbors, x24)
        x26 = apply(x23, x25)
        x27 = lbind(shift, x12)
        x28 = mapply(x27, x26)
        x29 = paint(I, x28)
        return x29

    def verify_2bcee788(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = argmax(x0, x1)
        x3 = remove(x2, x0)
        x4 = argmin(x3, size)
        x5 = argmax(x3, size)
        x6 = hmatching(x4, x5)
        x7 = branch(x6, vmirror, hmirror)
        x8 = x7(x5)
        x9 = branch(x6, leftmost, uppermost)
        x10 = branch(x6, tojvec, toivec)
        x11 = x9(x4)
        x12 = x9(x5)
        x13 = greater(x11, x12)
        x14 = double(x13)
        x15 = decrement(x14)
        x16 = x10(x15)
        x17 = shape(x5)
        x18 = multiply(x16, x17)
        x19 = shift(x8, x18)
        x20 = fill(I, THREE, x2)
        x21 = paint(x20, x19)
        return x21

    def verify_2bee17df(I: Grid) -> Grid:
        x0 = trim(I)
        x1 = mostcolor(x0)
        x2 = repeat(x1, ONE)
        x3 = lbind(repeat, THREE)
        x4 = compose(x3, size)
        x5 = matcher(dedupe, x2)
        x6 = rbind(branch, identity)
        x7 = rbind(x6, x4)
        x8 = compose(x7, x5)
        x9 = compose(initset, x8)
        x10 = fork(rapply, x9, identity)
        x11 = compose(first, x10)
        x12 = apply(x11, x0)
        x13 = dmirror(x0)
        x14 = apply(x11, x13)
        x15 = dmirror(x14)
        x16 = ofcolor(x12, THREE)
        x17 = ofcolor(x15, THREE)
        x18 = combine(x16, x17)
        x19 = shift(x18, UNITY)
        x20 = fill(I, THREE, x19)
        return x20

    def verify_2c608aff(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(equality, toindices, backdrop)
        x2 = sfilter(x0, x1)
        x3 = argmax(x2, size)
        x4 = color(x3)
        x5 = palette(I)
        x6 = remove(x4, x5)
        x7 = lbind(colorcount, I)
        x8 = argmin(x6, x7)
        x9 = toindices(x3)
        x10 = apply(first, x9)
        x11 = toindices(x3)
        x12 = apply(last, x11)
        x13 = rbind(contained, x10)
        x14 = compose(x13, first)
        x15 = rbind(contained, x12)
        x16 = compose(x15, last)
        x17 = fork(either, x14, x16)
        x18 = ofcolor(I, x8)
        x19 = sfilter(x18, x17)
        x20 = rbind(gravitate, x3)
        x21 = compose(x20, initset)
        x22 = fork(add, identity, x21)
        x23 = fork(connect, identity, x22)
        x24 = mapply(x23, x19)
        x25 = fill(I, x8, x24)
        return x25

    def verify_2dc579da(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = mfilter(x0, hline)
        x2 = mfilter(x0, vline)
        x3 = uppermost(x1)
        x4 = leftmost(x2)
        x5 = astuple(x3, x4)
        x6 = add(x5, NEG_UNITY)
        x7 = uppermost(x1)
        x8 = rightmost(x2)
        x9 = astuple(x7, x8)
        x10 = add(x9, UP_RIGHT)
        x11 = lowermost(x1)
        x12 = leftmost(x2)
        x13 = astuple(x11, x12)
        x14 = add(x13, DOWN_LEFT)
        x15 = lowermost(x1)
        x16 = rightmost(x2)
        x17 = astuple(x15, x16)
        x18 = add(x17, UNITY)
        x19 = initset(ORIGIN)
        x20 = insert(x6, x19)
        x21 = width(I)
        x22 = decrement(x21)
        x23 = tojvec(x22)
        x24 = initset(x23)
        x25 = insert(x10, x24)
        x26 = height(I)
        x27 = decrement(x26)
        x28 = toivec(x27)
        x29 = initset(x28)
        x30 = insert(x14, x29)
        x31 = shape(I)
        x32 = decrement(x31)
        x33 = initset(x32)
        x34 = insert(x18, x33)
        x35 = astuple(x20, x25)
        x36 = astuple(x30, x34)
        x37 = combine(x35, x36)
        x38 = rbind(toobject, I)
        x39 = compose(x38, backdrop)
        x40 = apply(x39, x37)
        x41 = matcher(numcolors, ONE)
        x42 = sfilter(x40, x41)
        x43 = apply(color, x42)
        x44 = mostcommon(x43)
        x45 = initset(x44)
        x46 = matcher(palette, x45)
        x47 = compose(flip, x46)
        x48 = extract(x40, x47)
        x49 = subgrid(x48, I)
        return x49

    def verify_2dd70a9a(I: Grid) -> Grid:
        x0 = ofcolor(I, TWO)
        x1 = vline(x0)
        x2 = branch(x1, dmirror, identity)
        x3 = x2(I)
        x4 = ofcolor(x3, THREE)
        x5 = ofcolor(x3, TWO)
        x6 = center(x4)
        x7 = hfrontier(x6)
        x8 = center(x5)
        x9 = hfrontier(x8)
        x10 = mostcolor(I)
        x11 = palette(I)
        x12 = remove(THREE, x11)
        x13 = remove(TWO, x12)
        x14 = other(x13, x10)
        x15 = replace(x3, THREE, x10)
        x16 = difference(x7, x4)
        x17 = underfill(x15, THREE, x16)
        x18 = replace(x3, TWO, x10)
        x19 = difference(x9, x5)
        x20 = underfill(x18, TWO, x19)
        x21 = objects(x17, T, F, F)
        x22 = colorfilter(x21, THREE)
        x23 = rbind(adjacent, x4)
        x24 = sfilter(x22, x23)
        x25 = objects(x20, T, F, F)
        x26 = colorfilter(x25, TWO)
        x27 = rbind(adjacent, x5)
        x28 = sfilter(x26, x27)
        x29 = mapply(toindices, x24)
        x30 = rbind(equality, x14)
        x31 = lbind(index, x3)
        x32 = compose(x30, x31)
        x33 = rbind(add, LEFT)
        x34 = compose(x32, x33)
        x35 = rbind(add, RIGHT)
        x36 = compose(x32, x35)
        x37 = fork(either, x34, x36)
        x38 = rbind(add, UP)
        x39 = compose(x32, x38)
        x40 = rbind(add, DOWN)
        x41 = compose(x32, x40)
        x42 = fork(either, x39, x41)
        x43 = sfilter(x29, x37)
        x44 = mapply(toindices, x28)
        x45 = sfilter(x44, x42)
        x46 = fork(connect, first, last)
        x47 = product(x43, x45)
        x48 = compose(vline, x46)
        x49 = rbind(toobject, x3)
        x50 = chain(numcolors, x49, x46)
        x51 = matcher(x50, ONE)
        x52 = fork(both, x48, x51)
        x53 = extract(x47, x52)
        x54 = x46(x53)
        x55 = center(x4)
        x56 = center(x5)
        x57 = fork(either, hline, vline)
        x58 = lbind(connect, x55)
        x59 = corners(x54)
        x60 = apply(x58, x59)
        x61 = mfilter(x60, x57)
        x62 = lbind(connect, x56)
        x63 = corners(x54)
        x64 = apply(x62, x63)
        x65 = mfilter(x64, x57)
        x66 = combine(x61, x65)
        x67 = combine(x54, x66)
        x68 = fill(x3, THREE, x67)
        x69 = fill(x68, TWO, x5)
        x70 = x2(x69)
        return x70

    def verify_2dee498d(I: Grid) -> Grid:
        x0 = hsplit(I, THREE)
        x1 = first(x0)
        return x1

    def verify_31aa019c(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = first(x1)
        x3 = neighbors(x2)
        x4 = mostcolor(I)
        x5 = shape(I)
        x6 = canvas(x4, x5)
        x7 = initset(x2)
        x8 = fill(x6, x0, x7)
        x9 = fill(x8, TWO, x3)
        return x9

    def verify_321b1fc6(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = argmax(x0, numcolors)
        x2 = remove(x1, x0)
        x3 = normalize(x1)
        x4 = apply(ulcorner, x2)
        x5 = lbind(shift, x3)
        x6 = mapply(x5, x4)
        x7 = paint(I, x6)
        x8 = cover(x7, x1)
        return x8

    def verify_32597951(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = argmin(x0, x1)
        x3 = delta(x2)
        x4 = fill(I, THREE, x3)
        return x4

    def verify_3345333e(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = toobject(x1, I)
        x3 = mostcolor(x2)
        x4 = partition(I)
        x5 = fork(multiply, height, width)
        x6 = fork(equality, size, x5)
        x7 = extract(x4, x6)
        x8 = color(x7)
        x9 = palette(I)
        x10 = remove(x3, x9)
        x11 = other(x10, x8)
        x12 = ofcolor(I, x11)
        x13 = vmirror(x12)
        x14 = hmirror(x12)
        x15 = toindices(x7)
        x16 = combine(x15, x12)
        x17 = height(x16)
        x18 = halve(x17)
        x19 = increment(x18)
        x20 = width(x16)
        x21 = halve(x20)
        x22 = increment(x21)
        x23 = astuple(x19, x22)
        x24 = maximum(x23)
        x25 = invert(x24)
        x26 = increment(x24)
        x27 = interval(x25, x26, ONE)
        x28 = product(x27, x27)
        x29 = initset(x14)
        x30 = insert(x13, x29)
        x31 = product(x28, x30)
        x32 = ofcolor(I, x3)
        x33 = rbind(intersection, x32)
        x34 = fork(shift, last, first)
        x35 = chain(size, x33, x34)
        x36 = matcher(x35, ZERO)
        x37 = sfilter(x31, x36)
        x38 = rbind(intersection, x12)
        x39 = fork(shift, last, first)
        x40 = chain(size, x38, x39)
        x41 = argmax(x37, x40)
        x42 = first(x41)
        x43 = last(x41)
        x44 = fill(I, x3, x7)
        x45 = shift(x43, x42)
        x46 = fill(x44, x11, x45)
        return x46

    def verify_3428a4f5(I: Grid) -> Grid:
        x0 = width(I)
        x1 = halve(x0)
        x2 = tojvec(x1)
        x3 = height(I)
        x4 = decrement(x3)
        x5 = astuple(x4, x1)
        x6 = connect(x2, x5)
        x7 = toobject(x6, I)
        x8 = numcolors(x7)
        x9 = equality(x8, ONE)
        x10 = branch(x9, lefthalf, tophalf)
        x11 = branch(x9, righthalf, bottomhalf)
        x12 = x10(I)
        x13 = x11(I)
        x14 = palette(x12)
        x15 = other(x14, ZERO)
        x16 = palette(x13)
        x17 = other(x16, ZERO)
        x18 = shape(x12)
        x19 = canvas(ZERO, x18)
        x20 = ofcolor(x12, x15)
        x21 = ofcolor(x13, x17)
        x22 = combine(x20, x21)
        x23 = intersection(x20, x21)
        x24 = difference(x22, x23)
        x25 = fill(x19, THREE, x24)
        return x25

    def verify_3618c87e(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = objects(I, T, F, F)
        x2 = sizefilter(x1, ONE)
        x3 = totuple(x2)
        x4 = apply(color, x3)
        x5 = mostcommon(x4)
        x6 = palette(I)
        x7 = remove(x5, x6)
        x8 = other(x7, x0)
        x9 = replace(I, x5, x0)
        x10 = ofcolor(I, x5)
        x11 = repeat(x8, ONE)
        x12 = rbind(equality, x11)
        x13 = first(I)
        x14 = dedupe(x13)
        x15 = x12(x14)
        x16 = last(I)
        x17 = dedupe(x16)
        x18 = x12(x17)
        x19 = dmirror(I)
        x20 = first(x19)
        x21 = dedupe(x20)
        x22 = x12(x21)
        x23 = dmirror(I)
        x24 = last(x23)
        x25 = dedupe(x24)
        x26 = x12(x25)
        x27 = apply(last, x10)
        x28 = apply(first, x10)
        x29 = either(x15, x18)
        x30 = branch(x29, x27, x28)
        x31 = branch(x29, lbind, rbind)
        x32 = lbind(x31, astuple)
        x33 = branch(x29, height, width)
        x34 = x33(I)
        x35 = decrement(x34)
        x36 = either(x15, x22)
        x37 = branch(x36, ZERO, x35)
        x38 = x32(x37)
        x39 = apply(x38, x30)
        x40 = fill(x9, x5, x39)
        return x40

    def verify_3631a71a(I: Grid) -> Grid:
        x0 = lbind(compose, flip)
        x1 = lbind(matcher, first)
        x2 = compose(x0, x1)
        x3 = rbind(compose, asobject)
        x4 = lbind(rbind, sfilter)
        x5 = chain(x3, x4, x2)
        x6 = rbind(shift, ORIGIN)
        x7 = compose(x6, dmirror)
        x8 = rbind(shift, TWO_BY_TWO)
        x9 = compose(x8, cmirror)
        x10 = rbind(shift, TWO_BY_ZERO)
        x11 = compose(x10, hmirror)
        x12 = rbind(shift, ZERO_BY_TWO)
        x13 = compose(x12, vmirror)
        x14 = lbind(fork, paint)
        x15 = lbind(x14, identity)
        x16 = lbind(compose, x7)
        x17 = chain(x15, x16, x5)
        x18 = lbind(compose, x9)
        x19 = chain(x15, x18, x5)
        x20 = lbind(compose, x11)
        x21 = chain(x15, x20, x5)
        x22 = lbind(compose, x13)
        x23 = chain(x15, x22, x5)
        x24 = rbind(rapply, I)
        x25 = chain(first, x24, initset)
        x26 = fork(compose, x23, x21)
        x27 = fork(compose, x19, x17)
        x28 = fork(compose, x26, x27)
        x29 = compose(x25, x28)
        x30 = palette(I)
        x31 = fork(equality, identity, dmirror)
        x32 = compose(x31, x29)
        x33 = argmax(x30, x32)
        x34 = x29(x33)
        return x34

    def verify_363442ee(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = mostcolor(I)
        x3 = fill(I, x2, x1)
        x4 = objects(x3, F, F, T)
        x5 = argmax(x4, size)
        x6 = remove(x5, x4)
        x7 = apply(center, x6)
        x8 = normalize(x5)
        x9 = shape(x5)
        x10 = halve(x9)
        x11 = invert(x10)
        x12 = shift(x8, x11)
        x13 = lbind(shift, x12)
        x14 = mapply(x13, x7)
        x15 = paint(I, x14)
        return x15

    def verify_36d67576(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = argmax(x0, size)
        x2 = remove(x1, x0)
        x3 = merge(x2)
        x4 = palette(x3)
        x5 = repeat(identity, ONE)
        x6 = astuple(cmirror, dmirror)
        x7 = astuple(vmirror, hmirror)
        x8 = combine(x6, x7)
        x9 = combine(x5, x8)
        x10 = fork(compose, first, last)
        x11 = product(x9, x9)
        x12 = apply(x10, x11)
        x13 = rbind(contained, x4)
        x14 = compose(x13, first)
        x15 = rbind(sfilter, x14)
        x16 = lbind(chain, ulcorner)
        x17 = lbind(x16, x15)
        x18 = lbind(fork, shift)
        x19 = lbind(lbind, shift)
        x20 = lbind(occurrences, I)
        x21 = rbind(rapply, x1)
        x22 = chain(first, x21, initset)
        x23 = lbind(compose, invert)
        x24 = compose(x23, x17)
        x25 = lbind(compose, x15)
        x26 = fork(x18, x25, x24)
        x27 = compose(x22, x26)
        x28 = rbind(rapply, x1)
        x29 = chain(first, x28, initset)
        x30 = rbind(rapply, x1)
        x31 = compose(initset, x17)
        x32 = chain(first, x30, x31)
        x33 = compose(invert, x32)
        x34 = fork(shift, x29, x33)
        x35 = compose(x19, x34)
        x36 = compose(x20, x27)
        x37 = fork(mapply, x35, x36)
        x38 = rbind(astuple, x37)
        x39 = compose(last, x38)
        x40 = rbind(astuple, x12)
        x41 = compose(last, x40)
        x42 = fork(mapply, x39, x41)
        x43 = fork(paint, identity, x42)
        x44 = rbind(contained, x4)
        x45 = compose(x44, first)
        x46 = sfilter(x1, x45)
        x47 = size(x46)
        x48 = equality(x47, ZERO)
        x49 = branch(x48, identity, x43)
        x50 = x49(I)
        return x50

    def verify_36fdfd69(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = fork(subtract, first, last)
        x3 = fork(multiply, sign, identity)
        x4 = compose(x3, x2)
        x5 = lbind(greater, THREE)
        x6 = chain(x5, maximum, x4)
        x7 = lbind(lbind, astuple)
        x8 = rbind(chain, x7)
        x9 = lbind(compose, x6)
        x10 = rbind(x8, x9)
        x11 = lbind(lbind, sfilter)
        x12 = compose(x10, x11)
        x13 = lbind(mapply, backdrop)
        x14 = fork(apply, x12, identity)
        x15 = compose(x13, x14)
        x16 = power(x15, TWO)
        x17 = x16(x1)
        x18 = fill(I, FOUR, x17)
        x19 = fill(x18, x0, x1)
        return x19

    def verify_3906de3d(I: Grid) -> Grid:
        x0 = first(I)
        x1 = dedupe(x0)
        x2 = size(x1)
        x3 = equality(ONE, x2)
        x4 = branch(x3, dmirror, identity)
        x5 = x4(I)
        x6 = first(x5)
        x7 = first(x6)
        x8 = first(x5)
        x9 = matcher(identity, x7)
        x10 = sfilter(x8, x9)
        x11 = size(x10)
        x12 = last(x5)
        x13 = sfilter(x12, x9)
        x14 = size(x13)
        x15 = greater(x11, x14)
        x16 = branch(x15, hmirror, identity)
        x17 = x16(x5)
        x18 = partition(x17)
        x19 = matcher(color, x7)
        x20 = extract(x18, x19)
        x21 = remove(x20, x18)
        x22 = argmin(x21, uppermost)
        x23 = other(x21, x22)
        x24 = color(x22)
        x25 = color(x23)
        x26 = fill(x17, TWO, x20)
        x27 = fill(x26, ONE, x23)
        x28 = fill(x27, ZERO, x22)
        x29 = rbind(order, identity)
        x30 = dmirror(x28)
        x31 = apply(x29, x30)
        x32 = dmirror(x31)
        x33 = x16(x32)
        x34 = x4(x33)
        x35 = ofcolor(x34, TWO)
        x36 = fill(x34, x7, x35)
        x37 = ofcolor(x34, ONE)
        x38 = fill(x36, x25, x37)
        x39 = ofcolor(x34, ZERO)
        x40 = fill(x38, x24, x39)
        return x40

    def verify_39a8645d(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = totuple(x0)
        x2 = apply(normalize, x1)
        x3 = mostcommon(x2)
        x4 = mostcolor(I)
        x5 = shape(x3)
        x6 = canvas(x4, x5)
        x7 = paint(x6, x3)
        return x7

    def verify_39e1d7f9(I: Grid) -> Grid:
        x0 = compress(I)
        x1 = objects(x0, F, F, T)
        x2 = argmax(x1, numcolors)
        x3 = remove(x2, x1)
        x4 = merge(x3)
        x5 = size(x4)
        x6 = positive(x5)
        x7 = astuple(color, x4)
        x8 = astuple(leastcolor, x2)
        x9 = branch(x6, x7, x8)
        x10 = compose(initset, first)
        x11 = fork(rapply, x10, last)
        x12 = compose(first, x11)
        x13 = x12(x9)
        x14 = normalize(x2)
        x15 = matcher(first, x13)
        x16 = sfilter(x14, x15)
        x17 = ulcorner(x16)
        x18 = invert(x17)
        x19 = shift(x14, x18)
        x20 = lbind(shift, x19)
        x21 = objects(x0, T, F, T)
        x22 = colorfilter(x21, x13)
        x23 = apply(ulcorner, x22)
        x24 = mapply(x20, x23)
        x25 = paint(x0, x24)
        x26 = height(x0)
        x27 = frontiers(I)
        x28 = sfilter(x27, hline)
        x29 = size(x28)
        x30 = increment(x29)
        x31 = divide(x26, x30)
        x32 = width(x0)
        x33 = frontiers(I)
        x34 = sfilter(x33, vline)
        x35 = size(x34)
        x36 = increment(x35)
        x37 = divide(x32, x36)
        x38 = rbind(multiply, x37)
        x39 = rbind(divide, x37)
        x40 = compose(x38, x39)
        x41 = fork(equality, x40, identity)
        x42 = compose(x41, first)
        x43 = rbind(multiply, x31)
        x44 = rbind(divide, x31)
        x45 = compose(x43, x44)
        x46 = fork(equality, x45, identity)
        x47 = compose(x46, first)
        x48 = lbind(interval, ZERO)
        x49 = rbind(x48, ONE)
        x50 = compose(x49, size)
        x51 = fork(pair, x50, identity)
        x52 = lbind(apply, last)
        x53 = rbind(sfilter, x42)
        x54 = chain(x52, x53, x51)
        x55 = compose(x54, last)
        x56 = height(x25)
        x57 = interval(ZERO, x56, ONE)
        x58 = pair(x57, x25)
        x59 = sfilter(x58, x47)
        x60 = apply(x55, x59)
        x61 = increment(x37)
        x62 = hupscale(x60, x61)
        x63 = increment(x31)
        x64 = vupscale(x62, x63)
        x65 = frontiers(I)
        x66 = merge(x65)
        x67 = paint(x64, x66)
        x68 = shape(I)
        x69 = crop(x67, ORIGIN, x68)
        return x69

    def verify_3aa6fb7a(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = mapply(corners, x0)
        x2 = underfill(I, ONE, x1)
        return x2

    def verify_3ac3eb23(I: Grid) -> Grid:
        x0 = astuple(identity, dmirror)
        x1 = astuple(cmirror, hmirror)
        x2 = combine(x0, x1)
        x3 = chain(lowermost, merge, fgpartition)
        x4 = rbind(rapply, I)
        x5 = lbind(compose, x3)
        x6 = compose(initset, x5)
        x7 = chain(first, x4, x6)
        x8 = matcher(x7, ZERO)
        x9 = extract(x2, x8)
        x10 = x9(I)
        x11 = objects(x10, T, F, T)
        x12 = height(x10)
        x13 = interval(ZERO, x12, TWO)
        x14 = height(x10)
        x15 = interval(ONE, x14, TWO)
        x16 = rbind(apply, x13)
        x17 = lbind(rbind, astuple)
        x18 = chain(x16, x17, last)
        x19 = rbind(apply, x15)
        x20 = lbind(rbind, astuple)
        x21 = compose(increment, last)
        x22 = chain(x19, x20, x21)
        x23 = rbind(apply, x15)
        x24 = lbind(rbind, astuple)
        x25 = compose(decrement, last)
        x26 = chain(x23, x24, x25)
        x27 = fork(combine, x18, x22)
        x28 = fork(combine, x27, x26)
        x29 = compose(x28, center)
        x30 = fork(recolor, color, x29)
        x31 = mapply(x30, x11)
        x32 = paint(x10, x31)
        x33 = x9(x32)
        return x33

    def verify_3af2c5a8(I: Grid) -> Grid:
        x0 = vmirror(I)
        x1 = hconcat(I, x0)
        x2 = hmirror(x1)
        x3 = vconcat(x1, x2)
        return x3

    def verify_3bd67248(I: Grid) -> Grid:
        x0 = astuple(identity, identity)
        x1 = astuple(rot90, rot270)
        x2 = astuple(x0, x1)
        x3 = astuple(rot180, rot180)
        x4 = astuple(rot270, rot90)
        x5 = astuple(x3, x4)
        x6 = combine(x2, x5)
        x7 = leastcolor(I)
        x8 = repeat(x7, ONE)
        x9 = rbind(rapply, I)
        x10 = chain(x9, initset, first)
        x11 = compose(first, x10)
        x12 = chain(dedupe, first, x11)
        x13 = matcher(x12, x8)
        x14 = extract(x6, x13)
        x15 = first(x14)
        x16 = last(x14)
        x17 = x15(I)
        x18 = ofcolor(x17, x7)
        x19 = height(x18)
        x20 = interval(ZERO, x19, ONE)
        x21 = lbind(astuple, x19)
        x22 = apply(x21, x20)
        x23 = rbind(shoot, DOWN)
        x24 = mapply(x23, x22)
        x25 = fill(x17, FOUR, x24)
        x26 = astuple(x19, x19)
        x27 = canvas(ZERO, x26)
        x28 = asindices(x27)
        x29 = shift(x28, x26)
        x30 = shape(I)
        x31 = maximum(x30)
        x32 = lbind(shift, x29)
        x33 = interval(ZERO, x31, x19)
        x34 = pair(x33, x33)
        x35 = mapply(x32, x34)
        x36 = fill(x25, TWO, x35)
        x37 = x16(x36)
        return x37

    def verify_3bdb4ada(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = fork(equality, size, x1)
        x3 = compose(flip, x2)
        x4 = extract(x0, x3)
        x5 = remove(x4, x0)
        x6 = compose(flip, even)
        x7 = rbind(chain, first)
        x8 = rbind(chain, last)
        x9 = lbind(rbind, subtract)
        x10 = lbind(x7, x6)
        x11 = lbind(x8, x6)
        x12 = chain(x10, x9, uppermost)
        x13 = chain(x11, x9, leftmost)
        x14 = lbind(fork, both)
        x15 = fork(x14, x12, x13)
        x16 = fork(sfilter, toindices, x15)
        x17 = mapply(x16, x5)
        x18 = color(x4)
        x19 = fill(I, x18, x17)
        return x19

    def verify_3befdf3e(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = rbind(compose, last)
        x2 = lbind(rbind, contained)
        x3 = chain(x1, x2, box)
        x4 = fork(sfilter, identity, x3)
        x5 = compose(color, x4)
        x6 = fork(other, palette, x5)
        x7 = chain(decrement, decrement, height)
        x8 = chain(decrement, decrement, width)
        x9 = compose(toivec, x7)
        x10 = fork(shift, toindices, x9)
        x11 = chain(toivec, invert, x7)
        x12 = fork(shift, toindices, x11)
        x13 = compose(tojvec, x8)
        x14 = fork(shift, toindices, x13)
        x15 = chain(tojvec, invert, x8)
        x16 = fork(shift, toindices, x15)
        x17 = fork(combine, x10, x12)
        x18 = fork(combine, x14, x16)
        x19 = fork(combine, x17, x18)
        x20 = fork(combine, backdrop, x19)
        x21 = fork(difference, x20, box)
        x22 = fork(recolor, x5, x21)
        x23 = fork(recolor, x6, box)
        x24 = fork(combine, x22, x23)
        x25 = mapply(x24, x0)
        x26 = paint(I, x25)
        return x26

    def verify_3c9b0459(I: Grid) -> Grid:
        x0 = rot180(I)
        return x0

    def verify_3de23699(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = corners(x0)
        x2 = mapply(dneighbors, x1)
        x3 = toobject(x2, I)
        x4 = mostcolor(x3)
        x5 = palette(I)
        x6 = remove(x4, x5)
        x7 = order(x6, identity)
        x8 = first(x7)
        x9 = last(x7)
        x10 = ofcolor(I, x8)
        x11 = ofcolor(I, x9)
        x12 = switch(I, x9, x8)
        x13 = combine(x10, x11)
        x14 = subgrid(x13, x12)
        x15 = trim(x14)
        return x15

    def verify_3e980e27(I: Grid) -> Grid:
        x0 = ofcolor(I, THREE)
        x1 = ofcolor(I, TWO)
        x2 = matcher(first, THREE)
        x3 = matcher(first, TWO)
        x4 = rbind(objects, T)
        x5 = rbind(x4, T)
        x6 = rbind(x5, F)
        x7 = lbind(contained, THREE)
        x8 = compose(x7, palette)
        x9 = lbind(contained, TWO)
        x10 = compose(x9, palette)
        x11 = rbind(sfilter, x8)
        x12 = compose(x11, x6)
        x13 = rbind(sfilter, x10)
        x14 = compose(x13, x6)
        x15 = rbind(argmax, numcolors)
        x16 = chain(normalize, x15, x12)
        x17 = rbind(argmax, numcolors)
        x18 = compose(x17, x14)
        x19 = chain(normalize, vmirror, x18)
        x20 = rbind(sfilter, x2)
        x21 = chain(ulcorner, x20, x16)
        x22 = rbind(sfilter, x3)
        x23 = chain(ulcorner, x22, x19)
        x24 = rbind(sfilter, x3)
        x25 = chain(center, x24, x18)
        x26 = lbind(lbind, shift)
        x27 = compose(x26, x16)
        x28 = lbind(lbind, shift)
        x29 = compose(x28, x19)
        x30 = rbind(apply, x0)
        x31 = lbind(lbind, add)
        x32 = compose(invert, x21)
        x33 = chain(x30, x31, x32)
        x34 = rbind(remove, x1)
        x35 = compose(x34, x25)
        x36 = lbind(lbind, add)
        x37 = chain(x36, invert, x23)
        x38 = fork(apply, x37, x35)
        x39 = fork(mapply, x27, x33)
        x40 = fork(mapply, x29, x38)
        x41 = fork(paint, identity, x39)
        x42 = fork(paint, identity, x40)
        x43 = size(x0)
        x44 = positive(x43)
        x45 = size(x1)
        x46 = positive(x45)
        x47 = branch(x44, x41, identity)
        x48 = branch(x46, x42, identity)
        x49 = compose(x47, x48)
        x50 = x49(I)
        return x50

    def verify_3eda0437(I: Grid) -> Grid:
        x0 = matcher(identity, ZERO)
        x1 = rbind(sfilter, x0)
        x2 = compose(size, x1)
        x3 = apply(x2, I)
        x4 = maximum(x3)
        x5 = dmirror(I)
        x6 = apply(x2, x5)
        x7 = maximum(x6)
        x8 = increment(x7)
        x9 = interval(TWO, x8, ONE)
        x10 = increment(x4)
        x11 = interval(TWO, x10, ONE)
        x12 = product(x9, x11)
        x13 = fork(multiply, first, last)
        x14 = apply(x13, x12)
        x15 = lbind(sfilter, x12)
        x16 = lbind(matcher, x13)
        x17 = compose(x15, x16)
        x18 = apply(x17, x14)
        x19 = lbind(occurrences, I)
        x20 = lbind(recolor, ZERO)
        x21 = lbind(canvas, NEG_ONE)
        x22 = compose(asindices, x21)
        x23 = chain(x19, x20, x22)
        x24 = lbind(mapply, x23)
        x25 = chain(positive, size, x24)
        x26 = sfilter(x18, x25)
        x27 = compose(x13, first)
        x28 = rbind(argmax, x27)
        x29 = lbind(recolor, ZERO)
        x30 = lbind(canvas, NEG_ONE)
        x31 = chain(x29, asindices, x30)
        x32 = lbind(lbind, shift)
        x33 = lbind(occurrences, I)
        x34 = fork(mapply, x32, x33)
        x35 = compose(x34, x31)
        x36 = size(x26)
        x37 = positive(x36)
        x38 = lbind(recolor, SIX)
        x39 = lbind(mapply, x35)
        x40 = chain(x38, x39, x28)
        x41 = fork(difference, identity, identity)
        x42 = branch(x37, x40, x41)
        x43 = x42(x26)
        x44 = paint(I, x43)
        return x44

    def verify_3f7978a0(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = objects(I, T, F, F)
        x2 = compose(double, height)
        x3 = fork(equality, x2, size)
        x4 = compose(double, width)
        x5 = fork(equality, x4, size)
        x6 = fork(either, x3, x5)
        x7 = rbind(equality, TWO)
        x8 = lbind(colorfilter, x1)
        x9 = rbind(sfilter, vline)
        x10 = rbind(sfilter, hline)
        x11 = chain(x9, x8, color)
        x12 = chain(x7, size, x11)
        x13 = chain(x10, x8, color)
        x14 = chain(x7, size, x13)
        x15 = fork(either, x12, x14)
        x16 = fork(both, x6, x15)
        x17 = extract(x0, x16)
        x18 = color(x17)
        x19 = colorfilter(x1, x18)
        x20 = first(x19)
        x21 = vline(x20)
        x22 = ulcorner(x17)
        x23 = lrcorner(x17)
        x24 = branch(x21, UP, LEFT)
        x25 = add(x22, x24)
        x26 = branch(x21, DOWN, RIGHT)
        x27 = add(x23, x26)
        x28 = initset(x27)
        x29 = insert(x25, x28)
        x30 = subgrid(x29, I)
        return x30

    def verify_40853293(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(recolor, color, backdrop)
        x2 = apply(x1, x0)
        x3 = mfilter(x2, hline)
        x4 = mfilter(x2, vline)
        x5 = paint(I, x3)
        x6 = paint(x5, x4)
        return x6

    def verify_4093f84a(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = palette(x1)
        x3 = fork(multiply, height, width)
        x4 = lbind(ofcolor, I)
        x5 = compose(x3, x4)
        x6 = argmin(x2, x5)
        x7 = palette(I)
        x8 = remove(x6, x7)
        x9 = lbind(colorcount, I)
        x10 = argmin(x8, x9)
        x11 = ofcolor(I, x6)
        x12 = leftmost(x11)
        x13 = positive(x12)
        x14 = branch(x13, identity, dmirror)
        x15 = x14(I)
        x16 = ofcolor(x15, x6)
        x17 = subgrid(x16, x15)
        x18 = leftmost(x16)
        x19 = rightmost(x16)
        x20 = lbind(greater, x18)
        x21 = compose(x20, last)
        x22 = rbind(greater, x19)
        x23 = compose(x22, last)
        x24 = asindices(x15)
        x25 = sfilter(x24, x21)
        x26 = subgrid(x25, x15)
        x27 = asindices(x15)
        x28 = sfilter(x27, x23)
        x29 = subgrid(x28, x15)
        x30 = rbind(equality, x10)
        x31 = rbind(order, x30)
        x32 = apply(x31, x26)
        x33 = vmirror(x29)
        x34 = apply(x31, x33)
        x35 = vmirror(x34)
        x36 = hconcat(x32, x17)
        x37 = hconcat(x36, x35)
        x38 = x14(x37)
        x39 = replace(x38, x10, x6)
        return x39

    def verify_41e4d17e(I: Grid) -> Grid:
        x0 = lbind(equality, NINE)
        x1 = compose(x0, size)
        x2 = fork(equality, height, width)
        x3 = fork(both, x1, x2)
        x4 = objects(I, T, F, F)
        x5 = sfilter(x4, x3)
        x6 = fork(combine, vfrontier, hfrontier)
        x7 = compose(x6, center)
        x8 = mapply(x7, x5)
        x9 = underfill(I, SIX, x8)
        return x9

    def verify_4258a5f9(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = mapply(neighbors, x1)
        x3 = difference(x2, x1)
        x4 = fill(I, ONE, x3)
        return x4

    def verify_4290ef0e(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = fgpartition(I)
        x2 = objects(I, T, F, T)
        x3 = rbind(valmax, width)
        x4 = lbind(colorfilter, x2)
        x5 = chain(x3, x4, color)
        x6 = compose(maximum, shape)
        x7 = fork(add, x6, x5)
        x8 = compose(invert, x7)
        x9 = order(x1, x8)
        x10 = rbind(add, DOWN)
        x11 = compose(x10, ulcorner)
        x12 = fork(contained, x11, toindices)
        x13 = rbind(add, RIGHT)
        x14 = compose(x13, ulcorner)
        x15 = fork(contained, x14, toindices)
        x16 = fork(add, x12, x15)
        x17 = rbind(argmax, x16)
        x18 = compose(initset, identity)
        x19 = fork(insert, vmirror, x18)
        x20 = fork(insert, cmirror, x19)
        x21 = fork(insert, hmirror, x20)
        x22 = compose(x17, x21)
        x23 = apply(x22, x9)
        x24 = size(x1)
        x25 = apply(size, x1)
        x26 = contained(ONE, x25)
        x27 = increment(x24)
        x28 = branch(x26, x24, x27)
        x29 = double(x28)
        x30 = decrement(x29)
        x31 = apply(normalize, x23)
        x32 = interval(ZERO, x28, ONE)
        x33 = pair(x32, x32)
        x34 = mpapply(shift, x31, x33)
        x35 = astuple(x30, x30)
        x36 = canvas(x0, x35)
        x37 = paint(x36, x34)
        x38 = rot90(x37)
        x39 = paint(x38, x34)
        x40 = rot90(x39)
        x41 = paint(x40, x34)
        x42 = rot90(x41)
        x43 = paint(x42, x34)
        return x43

    def verify_42a50994(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = sizefilter(x0, ONE)
        x2 = merge(x1)
        x3 = cover(I, x2)
        return x3

    def verify_4347f46a(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = fork(difference, toindices, box)
        x2 = mapply(x1, x0)
        x3 = mostcolor(I)
        x4 = fill(I, x3, x2)
        return x4

    def verify_444801d8(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = sizefilter(x0, ONE)
        x2 = difference(x0, x1)
        x3 = rbind(toobject, I)
        x4 = chain(leastcolor, x3, delta)
        x5 = rbind(shift, UP)
        x6 = fork(connect, ulcorner, urcorner)
        x7 = compose(x5, x6)
        x8 = rbind(shift, DOWN)
        x9 = fork(connect, llcorner, lrcorner)
        x10 = compose(x8, x9)
        x11 = fork(astuple, x7, x10)
        x12 = lbind(rbind, manhattan)
        x13 = compose(x12, delta)
        x14 = fork(argmin, x11, x13)
        x15 = fork(combine, delta, x14)
        x16 = fork(recolor, x4, x15)
        x17 = mapply(x16, x2)
        x18 = paint(I, x17)
        return x18

    def verify_445eab21(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = fork(multiply, height, width)
        x2 = argmax(x0, x1)
        x3 = color(x2)
        x4 = canvas(x3, TWO_BY_TWO)
        return x4

    def verify_447fd412(I: Grid) -> Grid:
        x0 = asobject(I)
        x1 = shape(I)
        x2 = shift(x0, x1)
        x3 = mostcolor(I)
        x4 = shape(I)
        x5 = multiply(x4, THREE)
        x6 = canvas(x3, x5)
        x7 = paint(x6, x2)
        x8 = objects(x7, F, T, T)
        x9 = argmax(x8, numcolors)
        x10 = normalize(x9)
        x11 = remove(x10, x8)
        x12 = merge(x11)
        x13 = mostcolor(x12)
        x14 = palette(x10)
        x15 = matcher(identity, x13)
        x16 = argmin(x14, x15)
        x17 = matcher(first, x13)
        x18 = sfilter(x10, x17)
        x19 = matcher(first, x16)
        x20 = sfilter(x10, x19)
        x21 = recolor(x3, x20)
        x22 = combine(x18, x21)
        x23 = lbind(mfilter, x8)
        x24 = lbind(occurrences, x7)
        x25 = lbind(upscale, x22)
        x26 = compose(x24, x25)
        x27 = lbind(lbind, shift)
        x28 = lbind(upscale, x10)
        x29 = compose(x27, x28)
        x30 = fork(apply, x29, x26)
        x31 = compose(positive, size)
        x32 = lbind(chain, x31)
        x33 = rbind(x32, toindices)
        x34 = lbind(rbind, intersection)
        x35 = chain(x23, x33, x34)
        x36 = chain(size, x35, toindices)
        x37 = rbind(colorcount, x13)
        x38 = fork(equality, x36, x37)
        x39 = rbind(sfilter, x38)
        x40 = chain(merge, x39, x30)
        x41 = interval(ONE, SIX, ONE)
        x42 = mapply(x40, x41)
        x43 = paint(x7, x42)
        x44 = subgrid(x2, x43)
        return x44

    def verify_44d8ac46(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = apply(delta, x0)
        x2 = mfilter(x1, square)
        x3 = fill(I, TWO, x2)
        return x3

    def verify_44f52bb0(I: Grid) -> Grid:
        x0 = vmirror(I)
        x1 = equality(x0, I)
        x2 = hmirror(I)
        x3 = equality(x2, I)
        x4 = either(x1, x3)
        x5 = branch(x4, ONE, SEVEN)
        x6 = canvas(x5, UNITY)
        return x6

    def verify_4522001f(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = multiply(THREE, x0)
        x2 = mostcolor(I)
        x3 = canvas(x2, x1)
        x4 = objects(I, F, F, T)
        x5 = merge(x4)
        x6 = mostcolor(x5)
        x7 = first(x4)
        x8 = matcher(first, x6)
        x9 = sfilter(x7, x8)
        x10 = normalize(x9)
        x11 = delta(x10)
        x12 = first(x11)
        x13 = subtract(ONE, x12)
        x14 = asobject(I)
        x15 = shape(I)
        x16 = double(x15)
        x17 = multiply(x13, x16)
        x18 = shift(x14, x17)
        x19 = paint(x3, x18)
        x20 = objects(x19, F, F, T)
        x21 = lbind(mapply, dneighbors)
        x22 = matcher(first, x6)
        x23 = rbind(sfilter, x22)
        x24 = chain(x21, delta, x23)
        x25 = ineighbors(ORIGIN)
        x26 = apply(double, x25)
        x27 = rbind(apply, x26)
        x28 = lbind(lbind, shift)
        x29 = compose(x27, x28)
        x30 = lbind(rbind, adjacent)
        x31 = compose(x30, x24)
        x32 = fork(extract, x29, x31)
        x33 = fork(combine, identity, x32)
        x34 = compose(backdrop, x33)
        x35 = double(x12)
        x36 = decrement(x35)
        x37 = multiply(x36, FOUR)
        x38 = rbind(shift, x37)
        x39 = compose(x38, x34)
        x40 = fork(combine, x34, x39)
        x41 = mapply(x40, x20)
        x42 = fill(x19, x6, x41)
        return x42

    def verify_4612dd53(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = box(x1)
        x3 = fill(I, TWO, x2)
        x4 = subgrid(x1, x3)
        x5 = ofcolor(x4, x0)
        x6 = mapply(vfrontier, x5)
        x7 = mapply(hfrontier, x5)
        x8 = size(x6)
        x9 = size(x7)
        x10 = greater(x8, x9)
        x11 = branch(x10, x7, x6)
        x12 = fill(x4, TWO, x11)
        x13 = ofcolor(x12, TWO)
        x14 = ulcorner(x1)
        x15 = shift(x13, x14)
        x16 = underfill(I, TWO, x15)
        return x16

    def verify_46442a0e(I: Grid) -> Grid:
        x0 = rot90(I)
        x1 = rot180(I)
        x2 = rot270(I)
        x3 = hconcat(I, x0)
        x4 = hconcat(x2, x1)
        x5 = vconcat(x3, x4)
        return x5

    def verify_469497ad(I: Grid) -> Grid:
        x0 = numcolors(I)
        x1 = decrement(x0)
        x2 = upscale(I, x1)
        x3 = rbind(toobject, I)
        x4 = lbind(ofcolor, I)
        x5 = compose(outbox, x4)
        x6 = chain(numcolors, x3, x5)
        x7 = matcher(x6, ONE)
        x8 = palette(I)
        x9 = sfilter(x8, x7)
        x10 = fork(multiply, height, width)
        x11 = lbind(ofcolor, I)
        x12 = compose(x10, x11)
        x13 = argmin(x9, x12)
        x14 = ofcolor(x2, x13)
        x15 = outbox(x14)
        x16 = toobject(x15, x2)
        x17 = mostcolor(x16)
        x18 = ulcorner(x14)
        x19 = shoot(x18, NEG_UNITY)
        x20 = lrcorner(x14)
        x21 = shoot(x20, UNITY)
        x22 = urcorner(x14)
        x23 = shoot(x22, UP_RIGHT)
        x24 = llcorner(x14)
        x25 = shoot(x24, DOWN_LEFT)
        x26 = combine(x19, x21)
        x27 = combine(x23, x25)
        x28 = combine(x26, x27)
        x29 = ofcolor(x2, x17)
        x30 = intersection(x28, x29)
        x31 = fill(x2, TWO, x30)
        return x31

    def verify_46f33fce(I: Grid) -> Grid:
        x0 = rot180(I)
        x1 = downscale(x0, TWO)
        x2 = rot180(x1)
        x3 = upscale(x2, FOUR)
        return x3

    def verify_47c1f68c(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = color(x1)
        x3 = compress(I)
        x4 = mostcolor(x3)
        x5 = tophalf(I)
        x6 = lefthalf(x5)
        x7 = vmirror(x6)
        x8 = hconcat(x6, x7)
        x9 = hmirror(x8)
        x10 = vconcat(x8, x9)
        x11 = tophalf(I)
        x12 = righthalf(x11)
        x13 = vmirror(x12)
        x14 = hconcat(x13, x12)
        x15 = hmirror(x14)
        x16 = vconcat(x14, x15)
        x17 = bottomhalf(I)
        x18 = lefthalf(x17)
        x19 = vmirror(x18)
        x20 = hconcat(x18, x19)
        x21 = hmirror(x20)
        x22 = vconcat(x21, x20)
        x23 = bottomhalf(I)
        x24 = righthalf(x23)
        x25 = vmirror(x24)
        x26 = hconcat(x25, x24)
        x27 = hmirror(x26)
        x28 = vconcat(x27, x26)
        x29 = astuple(x10, x16)
        x30 = astuple(x22, x28)
        x31 = combine(x29, x30)
        x32 = argmax(x31, numcolors)
        x33 = asindices(x32)
        x34 = ofcolor(x32, x4)
        x35 = difference(x33, x34)
        x36 = fill(x32, x2, x35)
        return x36

    def verify_484b58aa(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = objects(I, T, F, F)
        x2 = lbind(colorfilter, x1)
        x3 = compose(size, x2)
        x4 = valmin(x0, x3)
        x5 = matcher(x3, x4)
        x6 = sfilter(x0, x5)
        x7 = lbind(colorcount, I)
        x8 = argmin(x6, x7)
        x9 = asobject(I)
        x10 = matcher(first, x8)
        x11 = compose(flip, x10)
        x12 = sfilter(x9, x11)
        x13 = lbind(contained, x8)
        x14 = compose(flip, x13)
        x15 = sfilter(I, x14)
        x16 = asobject(x15)
        x17 = hperiod(x16)
        x18 = dmirror(I)
        x19 = sfilter(x18, x14)
        x20 = asobject(x19)
        x21 = hperiod(x20)
        x22 = astuple(x21, x17)
        x23 = lbind(multiply, x22)
        x24 = neighbors(ORIGIN)
        x25 = mapply(neighbors, x24)
        x26 = apply(x23, x25)
        x27 = lbind(shift, x12)
        x28 = mapply(x27, x26)
        x29 = paint(I, x28)
        return x29

    def verify_48d8fb45(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = argmax(x0, numcolors)
        x2 = mostcolor(x1)
        x3 = matcher(first, x2)
        x4 = sfilter(x1, x3)
        x5 = shape(x4)
        x6 = normalize(x4)
        x7 = mostcolor(I)
        x8 = canvas(x7, x5)
        x9 = paint(x8, x6)
        return x9

    def verify_4938f0c2(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = matcher(size, FOUR)
        x2 = fork(both, square, x1)
        x3 = extract(x0, x2)
        x4 = color(x3)
        x5 = merge(x0)
        x6 = compose(hmirror, vmirror)
        x7 = initset(x6)
        x8 = insert(vmirror, x7)
        x9 = insert(hmirror, x8)
        x10 = rapply(x9, x5)
        x11 = ulcorner(x3)
        x12 = lbind(subtract, x11)
        x13 = matcher(first, x4)
        x14 = rbind(sfilter, x13)
        x15 = chain(x12, ulcorner, x14)
        x16 = fork(shift, identity, x15)
        x17 = mapply(x16, x10)
        x18 = paint(I, x17)
        return x18

    def verify_496994bd(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = vsplit(I, TWO)
        x2 = apply(numcolors, x1)
        x3 = contained(ONE, x2)
        x4 = branch(x3, hmirror, vmirror)
        x5 = x4(I)
        x6 = asobject(x5)
        x7 = matcher(first, x0)
        x8 = compose(flip, x7)
        x9 = sfilter(x6, x8)
        x10 = paint(I, x9)
        return x10

    def verify_49d1d64f(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = increment(x0)
        x2 = increment(x1)
        x3 = canvas(ZERO, x2)
        x4 = asobject(I)
        x5 = shift(x4, UNITY)
        x6 = shift(x5, LEFT)
        x7 = paint(x3, x6)
        x8 = shift(x5, RIGHT)
        x9 = paint(x7, x8)
        x10 = shift(x5, UP)
        x11 = paint(x9, x10)
        x12 = shift(x5, DOWN)
        x13 = paint(x11, x12)
        x14 = paint(x13, x5)
        return x14

    def verify_4be741c5(I: Grid) -> Grid:
        x0 = first(I)
        x1 = dedupe(x0)
        x2 = size(x1)
        x3 = equality(x2, ONE)
        x4 = branch(x3, dmirror, identity)
        x5 = branch(x3, height, width)
        x6 = x5(I)
        x7 = astuple(ONE, x6)
        x8 = x4(I)
        x9 = crop(x8, ORIGIN, x7)
        x10 = apply(dedupe, x9)
        x11 = x4(x10)
        return x11

    def verify_4c4377d9(I: Grid) -> Grid:
        x0 = hmirror(I)
        x1 = vconcat(x0, I)
        return x1

    def verify_4c5c2cf0(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = compose(dneighbors, center)
        x2 = fork(difference, backdrop, x1)
        x3 = fork(equality, toindices, x2)
        x4 = matcher(size, FIVE)
        x5 = fork(both, x3, x4)
        x6 = extract(x0, x5)
        x7 = color(x6)
        x8 = merge(x0)
        x9 = compose(hmirror, vmirror)
        x10 = initset(x9)
        x11 = insert(vmirror, x10)
        x12 = insert(hmirror, x11)
        x13 = rapply(x12, x8)
        x14 = ulcorner(x6)
        x15 = lbind(subtract, x14)
        x16 = matcher(first, x7)
        x17 = rbind(sfilter, x16)
        x18 = chain(x15, ulcorner, x17)
        x19 = fork(shift, identity, x18)
        x20 = mapply(x19, x13)
        x21 = paint(I, x20)
        return x21

    def verify_50846271(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = interval(TWO, FIVE, ONE)
        x3 = rbind(shift, RIGHT)
        x4 = rbind(shift, LEFT)
        x5 = rbind(shift, UP)
        x6 = rbind(shift, DOWN)
        x7 = lbind(fork, intersection)
        x8 = lbind(x7, identity)
        x9 = lbind(rbind, shift)
        x10 = compose(x8, x9)
        x11 = compose(x10, tojvec)
        x12 = chain(x10, tojvec, invert)
        x13 = compose(x10, toivec)
        x14 = chain(x10, toivec, invert)
        x15 = lbind(compose, initset)
        x16 = lbind(rbind, rapply)
        x17 = lbind(chain, first)
        x18 = lbind(compose, x4)
        x19 = x15(x11)
        x20 = rbind(x17, x19)
        x21 = chain(x18, x20, x16)
        x22 = lbind(compose, x3)
        x23 = x15(x12)
        x24 = rbind(x17, x23)
        x25 = chain(x22, x24, x16)
        x26 = lbind(compose, x5)
        x27 = x15(x13)
        x28 = rbind(x17, x27)
        x29 = chain(x26, x28, x16)
        x30 = lbind(compose, x6)
        x31 = x15(x14)
        x32 = rbind(x17, x31)
        x33 = chain(x30, x32, x16)
        x34 = rbind(ofcolor, x0)
        x35 = compose(x21, x34)
        x36 = compose(x25, x34)
        x37 = compose(x29, x34)
        x38 = compose(x33, x34)
        x39 = lbind(fork, combine)
        x40 = fork(x39, x35, x36)
        x41 = fork(x39, x37, x38)
        x42 = fork(x39, x40, x41)
        x43 = lbind(recolor, x0)
        x44 = rbind(mapply, x2)
        x45 = chain(x43, x44, x42)
        x46 = fork(paint, identity, x45)
        x47 = power(x46, FOUR)
        x48 = x47(I)
        x49 = objects(x48, T, T, T)
        x50 = colorfilter(x49, x0)
        x51 = compose(maximum, shape)
        x52 = apply(x51, x50)
        x53 = maximum(x52)
        x54 = ofcolor(x48, x0)
        x55 = rbind(contained, x54)
        x56 = rbind(add, RIGHT)
        x57 = compose(x55, x56)
        x58 = rbind(add, LEFT)
        x59 = compose(x55, x58)
        x60 = fork(either, x57, x59)
        x61 = rbind(add, DOWN)
        x62 = compose(x55, x61)
        x63 = rbind(add, UP)
        x64 = compose(x55, x63)
        x65 = fork(either, x62, x64)
        x66 = fork(both, x60, x65)
        x67 = matcher(size, x53)
        x68 = fork(either, vline, hline)
        x69 = fork(both, x67, x68)
        x70 = sfilter(x50, x69)
        x71 = apply(center, x70)
        x72 = sfilter(x54, x66)
        x73 = combine(x72, x71)
        x74 = halve(x53)
        x75 = invert(x74)
        x76 = toivec(x75)
        x77 = rbind(add, x76)
        x78 = toivec(x74)
        x79 = rbind(add, x78)
        x80 = fork(connect, x77, x79)
        x81 = invert(x74)
        x82 = tojvec(x81)
        x83 = rbind(add, x82)
        x84 = tojvec(x74)
        x85 = rbind(add, x84)
        x86 = fork(connect, x83, x85)
        x87 = fork(combine, x80, x86)
        x88 = mapply(x87, x73)
        x89 = fill(x48, x0, x88)
        x90 = replace(x89, x0, EIGHT)
        x91 = fill(x90, x0, x1)
        return x91

    def verify_508bd3b6(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = palette(I)
        x2 = compose(maximum, shape)
        x3 = lbind(apply, x2)
        x4 = lbind(colorfilter, x0)
        x5 = chain(maximum, x3, x4)
        x6 = matcher(x5, ONE)
        x7 = extract(x1, x6)
        x8 = lbind(ofcolor, I)
        x9 = compose(backdrop, x8)
        x10 = fork(equality, x8, x9)
        x11 = extract(x1, x10)
        x12 = ofcolor(I, x11)
        x13 = ofcolor(I, x7)
        x14 = rbind(manhattan, x12)
        x15 = compose(x14, initset)
        x16 = argmin(x13, x15)
        x17 = ulcorner(x13)
        x18 = contained(x17, x13)
        x19 = shoot(x16, UNITY)
        x20 = shoot(x16, NEG_UNITY)
        x21 = combine(x19, x20)
        x22 = shoot(x16, UP_RIGHT)
        x23 = shoot(x16, DOWN_LEFT)
        x24 = combine(x22, x23)
        x25 = branch(x18, x21, x24)
        x26 = asindices(I)
        x27 = outbox(x12)
        x28 = intersection(x26, x27)
        x29 = intersection(x28, x25)
        x30 = initset(x16)
        x31 = rbind(manhattan, x30)
        x32 = compose(x31, initset)
        x33 = argmin(x29, x32)
        x34 = height(x12)
        x35 = height(I)
        x36 = equality(x34, x35)
        x37 = leftmost(x13)
        x38 = leftmost(x12)
        x39 = greater(x37, x38)
        x40 = uppermost(x13)
        x41 = uppermost(x12)
        x42 = greater(x40, x41)
        x43 = lbind(shoot, x33)
        x44 = branch(x39, UNITY, NEG_UNITY)
        x45 = branch(x39, UP_RIGHT, DOWN_LEFT)
        x46 = branch(x42, UNITY, NEG_UNITY)
        x47 = branch(x42, DOWN_LEFT, UP_RIGHT)
        x48 = branch(x36, x44, x46)
        x49 = branch(x36, x45, x47)
        x50 = x43(x48)
        x51 = x43(x49)
        x52 = combine(x50, x51)
        x53 = difference(x52, x13)
        x54 = fill(I, THREE, x53)
        return x54

    def verify_50cb2852(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = compose(backdrop, inbox)
        x2 = mapply(x1, x0)
        x3 = fill(I, EIGHT, x2)
        return x3

    def verify_5117e062(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = argmax(x0, numcolors)
        x2 = mostcolor(x1)
        x3 = normalize(x1)
        x4 = mostcolor(I)
        x5 = shape(x1)
        x6 = canvas(x4, x5)
        x7 = fill(x6, x2, x3)
        return x7

    def verify_5168d44c(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = valmax(x0, x1)
        x3 = matcher(x1, x2)
        x4 = sfilter(x0, x3)
        x5 = argmax(x4, size)
        x6 = color(x5)
        x7 = remove(x5, x0)
        x8 = objects(I, T, F, F)
        x9 = lbind(colorfilter, x8)
        x10 = chain(size, x9, color)
        x11 = argmin(x7, x10)
        x12 = other(x7, x11)
        x13 = color(x12)
        x14 = colorfilter(x8, x13)
        x15 = apply(leftmost, x14)
        x16 = size(x15)
        x17 = equality(ONE, x16)
        x18 = apply(uppermost, x14)
        x19 = size(x18)
        x20 = equality(ONE, x19)
        x21 = fork(add, first, last)
        x22 = compose(x21, ulcorner)
        x23 = argmin(x14, x22)
        x24 = remove(x23, x14)
        x25 = lbind(manhattan, x23)
        x26 = argmin(x24, x25)
        x27 = lowermost(x26)
        x28 = lowermost(x23)
        x29 = subtract(x27, x28)
        x30 = uppermost(x26)
        x31 = uppermost(x23)
        x32 = subtract(x30, x31)
        x33 = astuple(x29, x32)
        x34 = maximum(x33)
        x35 = branch(x20, ZERO, x34)
        x36 = rightmost(x26)
        x37 = rightmost(x23)
        x38 = subtract(x36, x37)
        x39 = leftmost(x26)
        x40 = leftmost(x23)
        x41 = subtract(x39, x40)
        x42 = astuple(x38, x41)
        x43 = maximum(x42)
        x44 = branch(x17, ZERO, x43)
        x45 = astuple(x35, x44)
        x46 = shift(x11, x45)
        x47 = delta(x46)
        x48 = hmirror(x46)
        x49 = ulcorner(x47)
        x50 = delta(x48)
        x51 = ulcorner(x50)
        x52 = subtract(x49, x51)
        x53 = shift(x48, x52)
        x54 = combine(x46, x53)
        x55 = vmirror(x54)
        x56 = ulcorner(x47)
        x57 = delta(x55)
        x58 = ulcorner(x57)
        x59 = subtract(x56, x58)
        x60 = shift(x55, x59)
        x61 = combine(x60, x54)
        x62 = color(x11)
        x63 = replace(I, x62, x6)
        x64 = paint(x63, x61)
        return x64

    def verify_539a4f51(I: Grid) -> Grid:
        x0 = astuple(identity, cmirror)
        x1 = astuple(hmirror, vmirror)
        x2 = combine(x0, x1)
        x3 = fork(multiply, height, width)
        x4 = rbind(objects, F)
        x5 = rbind(x4, F)
        x6 = rbind(x5, T)
        x7 = rbind(argmin, x3)
        x8 = lbind(contained, ORIGIN)
        x9 = chain(x8, toindices, x7)
        x10 = compose(x9, x6)
        x11 = lbind(compose, x10)
        x12 = rbind(rapply, I)
        x13 = compose(initset, x11)
        x14 = chain(first, x12, x13)
        x15 = extract(x2, x14)
        x16 = x15(I)
        x17 = height(I)
        x18 = first(x16)
        x19 = matcher(identity, ZERO)
        x20 = compose(flip, x19)
        x21 = sfilter(x18, x20)
        x22 = size(x21)
        x23 = divide(x17, x22)
        x24 = increment(x23)
        x25 = double(x24)
        x26 = repeat(x21, x25)
        x27 = merge(x26)
        x28 = double(x17)
        x29 = repeat(x27, x28)
        x30 = asobject(x29)
        x31 = chain(increment, last, last)
        x32 = compose(first, last)
        x33 = fork(greater, x31, x32)
        x34 = sfilter(x30, x33)
        x35 = upscale(x16, TWO)
        x36 = dmirror(x34)
        x37 = combine(x34, x36)
        x38 = paint(x35, x37)
        x39 = x15(x38)
        return x39

    def verify_53b68214(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = mostcolor(I)
        x3 = width(I)
        x4 = astuple(TEN, x3)
        x5 = canvas(x2, x4)
        x6 = interval(ONE, SIX, ONE)
        x7 = invert(TEN)
        x8 = interval(x7, TEN, ONE)
        x9 = product(x6, x8)
        x10 = remove(ORIGIN, x9)
        x11 = lbind(intersection, x1)
        x12 = lbind(shift, x1)
        x13 = compose(x11, x12)
        x14 = toindices(x1)
        x15 = lbind(intersection, x14)
        x16 = lbind(shift, x14)
        x17 = compose(x15, x16)
        x18 = compose(size, x13)
        x19 = compose(size, x17)
        x20 = fork(equality, x18, x19)
        x21 = chain(positive, size, x13)
        x22 = fork(both, x20, x21)
        x23 = sfilter(x10, x22)
        x24 = compose(size, x13)
        x25 = valmax(x23, x24)
        x26 = compose(size, x13)
        x27 = matcher(x26, x25)
        x28 = sfilter(x23, x27)
        x29 = fork(multiply, first, last)
        x30 = argmax(x28, x29)
        x31 = interval(ZERO, TEN, ONE)
        x32 = lbind(shift, x1)
        x33 = lbind(multiply, x30)
        x34 = compose(x32, x33)
        x35 = mapply(x34, x31)
        x36 = paint(x5, x35)
        return x36

    def verify_543a7ed5(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = mapply(outbox, x0)
        x2 = fill(I, THREE, x1)
        x3 = mapply(delta, x0)
        x4 = fill(x2, FOUR, x3)
        return x4

    def verify_54d82841(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = mapply(delta, x0)
        x2 = first(x0)
        x3 = toindices(x2)
        x4 = rbind(contained, x3)
        x5 = portrait(x2)
        x6 = apply(first, x1)
        x7 = apply(last, x1)
        x8 = branch(x5, x6, x7)
        x9 = branch(x5, RIGHT, DOWN)
        x10 = delta(x2)
        x11 = center(x10)
        x12 = add(x11, x9)
        x13 = x4(x12)
        x14 = branch(x5, width, height)
        x15 = branch(x5, rbind, lbind)
        x16 = x14(I)
        x17 = decrement(x16)
        x18 = x15(astuple, x17)
        x19 = branch(x5, toivec, tojvec)
        x20 = branch(x13, x19, x18)
        x21 = apply(x20, x8)
        x22 = fill(I, FOUR, x21)
        return x22

    def verify_54d9e175(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = leastcolor(x1)
        x3 = shape(I)
        x4 = canvas(x2, x3)
        x5 = hconcat(I, x4)
        x6 = objects(x5, F, F, T)
        x7 = power(increment, FIVE)
        x8 = lbind(remove, FIVE)
        x9 = lbind(remove, ZERO)
        x10 = chain(x8, x9, palette)
        x11 = chain(x7, first, x10)
        x12 = fork(recolor, x11, toindices)
        x13 = mapply(x12, x6)
        x14 = paint(I, x13)
        return x14

    def verify_5521c0d9(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = toobject(x1, I)
        x3 = mostcolor(x2)
        x4 = rbind(objects, T)
        x5 = rbind(x4, F)
        x6 = rbind(x5, T)
        x7 = lbind(canvas, x3)
        x8 = compose(x7, shape)
        x9 = fork(hconcat, identity, x8)
        x10 = compose(x6, x9)
        x11 = lbind(apply, uppermost)
        x12 = chain(maximum, x11, x10)
        x13 = matcher(x12, ZERO)
        x14 = astuple(identity, dmirror)
        x15 = astuple(cmirror, hmirror)
        x16 = combine(x14, x15)
        x17 = rbind(rapply, I)
        x18 = chain(first, x17, initset)
        x19 = compose(x13, x18)
        x20 = extract(x16, x19)
        x21 = x20(I)
        x22 = shape(x21)
        x23 = canvas(x3, x22)
        x24 = hconcat(x21, x23)
        x25 = objects(x24, T, F, T)
        x26 = compose(toivec, height)
        x27 = fork(shift, identity, x26)
        x28 = mapply(x27, x25)
        x29 = mostcolor(I)
        x30 = merge(x25)
        x31 = fill(x21, x29, x30)
        x32 = paint(x31, x28)
        x33 = x20(x32)
        return x33

    def verify_5582e5ca(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = shape(I)
        x2 = canvas(x0, x1)
        return x2

    def verify_5614dbcf(I: Grid) -> Grid:
        x0 = canvas(ZERO, THREE_BY_THREE)
        x1 = asindices(x0)
        x2 = shape(I)
        x3 = divide(x2, THREE)
        x4 = first(x3)
        x5 = last(x3)
        x6 = interval(ZERO, x4, ONE)
        x7 = interval(ZERO, x5, ONE)
        x8 = product(x6, x7)
        x9 = rbind(multiply, THREE)
        x10 = apply(x9, x8)
        x11 = matcher(first, FIVE)
        x12 = compose(flip, x11)
        x13 = rbind(sfilter, x12)
        x14 = rbind(toobject, I)
        x15 = lbind(shift, x1)
        x16 = chain(x13, x14, x15)
        x17 = compose(color, x16)
        x18 = lbind(shift, x1)
        x19 = fork(recolor, x17, x18)
        x20 = mapply(x19, x10)
        x21 = paint(I, x20)
        x22 = downscale(x21, THREE)
        return x22

    def verify_56dc2b01(I: Grid) -> Grid:
        x0 = ofcolor(I, TWO)
        x1 = hline(x0)
        x2 = branch(x1, dmirror, identity)
        x3 = x2(I)
        x4 = fgpartition(x3)
        x5 = matcher(color, TWO)
        x6 = compose(flip, x5)
        x7 = extract(x4, x6)
        x8 = ofcolor(x3, TWO)
        x9 = leftmost(x8)
        x10 = leftmost(x7)
        x11 = greater(x9, x10)
        x12 = manhattan(x7, x8)
        x13 = decrement(x12)
        x14 = branch(x11, identity, invert)
        x15 = branch(x11, decrement, increment)
        x16 = branch(x11, leftmost, rightmost)
        x17 = x14(x13)
        x18 = tojvec(x17)
        x19 = shift(x7, x18)
        x20 = x16(x19)
        x21 = x15(x20)
        x22 = tojvec(x21)
        x23 = vfrontier(x22)
        x24 = cover(x3, x7)
        x25 = paint(x24, x19)
        x26 = fill(x25, EIGHT, x23)
        x27 = x2(x26)
        return x27

    def verify_56ff96f3(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = fork(recolor, color, backdrop)
        x2 = mapply(x1, x0)
        x3 = paint(I, x2)
        return x3

    def verify_57aa92db(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = palette(I)
        x2 = lbind(sfilter, x0)
        x3 = rbind(compose, palette)
        x4 = lbind(lbind, contained)
        x5 = chain(x2, x3, x4)
        x6 = compose(size, x5)
        x7 = argmax(x1, x6)
        x8 = rbind(colorcount, x7)
        x9 = apply(x8, x0)
        x10 = minimum(x9)
        x11 = rbind(colorcount, x7)
        x12 = matcher(x11, x10)
        x13 = sfilter(x0, x12)
        x14 = argmax(x13, size)
        x15 = matcher(first, x7)
        x16 = rbind(sfilter, x15)
        x17 = lbind(upscale, x14)
        x18 = chain(x17, width, x16)
        x19 = compose(ulcorner, x16)
        x20 = chain(ulcorner, x16, x18)
        x21 = fork(subtract, x19, x20)
        x22 = fork(shift, x18, x21)
        x23 = rbind(other, x7)
        x24 = compose(x23, palette)
        x25 = compose(x16, x22)
        x26 = fork(difference, x22, x25)
        x27 = fork(recolor, x24, x26)
        x28 = compose(x16, x22)
        x29 = fork(combine, x28, x27)
        x30 = remove(x14, x0)
        x31 = mapply(x29, x30)
        x32 = paint(I, x31)
        return x32

    def verify_5ad4f10b(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = toobject(x1, I)
        x3 = mostcolor(x2)
        x4 = palette(I)
        x5 = remove(x3, x4)
        x6 = lbind(chain, size)
        x7 = rbind(x6, dneighbors)
        x8 = lbind(lbind, intersection)
        x9 = lbind(ofcolor, I)
        x10 = chain(x7, x8, x9)
        x11 = rbind(matcher, ZERO)
        x12 = compose(x11, x10)
        x13 = chain(flip, positive, size)
        x14 = lbind(ofcolor, I)
        x15 = fork(sfilter, x14, x12)
        x16 = compose(x13, x15)
        x17 = argmax(x5, x16)
        x18 = other(x5, x17)
        x19 = ofcolor(I, x17)
        x20 = subgrid(x19, I)
        x21 = switch(x20, x17, x18)
        x22 = replace(x21, x17, x3)
        x23 = lbind(downscale, x22)
        x24 = fork(upscale, x23, identity)
        x25 = matcher(x24, x22)
        x26 = shape(x22)
        x27 = maximum(x26)
        x28 = interval(ONE, x27, ONE)
        x29 = sfilter(x28, x25)
        x30 = maximum(x29)
        x31 = downscale(x22, x30)
        return x31

    def verify_5bd6f4ac(I: Grid) -> Grid:
        x0 = rot270(I)
        x1 = crop(x0, ORIGIN, THREE_BY_THREE)
        x2 = rot90(x1)
        return x2

    def verify_5c0a986e(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = colorfilter(x0, TWO)
        x2 = colorfilter(x0, ONE)
        x3 = lbind(recolor, TWO)
        x4 = rbind(shoot, UNITY)
        x5 = chain(x3, x4, lrcorner)
        x6 = lbind(recolor, ONE)
        x7 = rbind(shoot, NEG_UNITY)
        x8 = chain(x6, x7, ulcorner)
        x9 = mapply(x5, x1)
        x10 = mapply(x8, x2)
        x11 = combine(x9, x10)
        x12 = paint(I, x11)
        return x12

    def verify_5c2c9af4(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = height(x1)
        x3 = halve(x2)
        x4 = width(x1)
        x5 = halve(x4)
        x6 = ulcorner(x1)
        x7 = lrcorner(x1)
        x8 = shape(I)
        x9 = maximum(x8)
        x10 = multiply(THREE, TEN)
        x11 = interval(ZERO, x10, ONE)
        x12 = rbind(multiply, x3)
        x13 = apply(x12, x11)
        x14 = rbind(multiply, x5)
        x15 = apply(x14, x11)
        x16 = pair(x13, x15)
        x17 = rbind(add, x6)
        x18 = apply(invert, x16)
        x19 = apply(x17, x18)
        x20 = rbind(add, x7)
        x21 = apply(x20, x16)
        x22 = pair(x19, x21)
        x23 = mapply(box, x22)
        x24 = fill(I, x0, x23)
        return x24

    def verify_5daaa586(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = objects(I, T, F, F)
        x2 = colorfilter(x1, x0)
        x3 = rbind(bordering, I)
        x4 = compose(flip, x3)
        x5 = mfilter(x2, x4)
        x6 = outbox(x5)
        x7 = subgrid(x6, I)
        x8 = trim(x7)
        x9 = palette(x8)
        x10 = matcher(identity, x0)
        x11 = argmin(x9, x10)
        x12 = trim(x7)
        x13 = ofcolor(x12, x11)
        x14 = shift(x13, UNITY)
        x15 = ofcolor(x7, x11)
        x16 = difference(x15, x14)
        x17 = compose(first, first)
        x18 = compose(first, last)
        x19 = fork(equality, x17, x18)
        x20 = compose(last, first)
        x21 = compose(last, last)
        x22 = fork(equality, x20, x21)
        x23 = fork(either, x19, x22)
        x24 = product(x14, x16)
        x25 = sfilter(x24, x23)
        x26 = fork(connect, first, last)
        x27 = mapply(x26, x25)
        x28 = fill(x7, x11, x27)
        return x28

    def verify_60b61512(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = mapply(delta, x0)
        x2 = fill(I, SEVEN, x1)
        return x2

    def verify_6150a2bd(I: Grid) -> Grid:
        x0 = rot180(I)
        return x0

    def verify_623ea044(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = rbind(shoot, UNITY)
        x3 = rbind(shoot, NEG_UNITY)
        x4 = fork(combine, x2, x3)
        x5 = rbind(shoot, UP_RIGHT)
        x6 = rbind(shoot, DOWN_LEFT)
        x7 = fork(combine, x5, x6)
        x8 = fork(combine, x4, x7)
        x9 = mapply(x8, x1)
        x10 = fill(I, x0, x9)
        return x10

    def verify_62c24649(I: Grid) -> Grid:
        x0 = vmirror(I)
        x1 = hconcat(I, x0)
        x2 = hmirror(x1)
        x3 = vconcat(x1, x2)
        return x3

    def verify_63613498(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = mostcolor(I)
        x2 = fork(add, height, width)
        x3 = compose(decrement, x2)
        x4 = fork(equality, x3, size)
        x5 = rbind(bordering, I)
        x6 = fork(both, x4, x5)
        x7 = rbind(toobject, I)
        x8 = chain(numcolors, x7, delta)
        x9 = matcher(x8, TWO)
        x10 = fork(both, x6, x9)
        x11 = sfilter(x0, x10)
        x12 = argmax(x11, size)
        x13 = delta(x12)
        x14 = toobject(x13, I)
        x15 = matcher(first, x1)
        x16 = compose(flip, x15)
        x17 = sfilter(x14, x16)
        x18 = normalize(x17)
        x19 = toindices(x18)
        x20 = compose(toindices, normalize)
        x21 = matcher(x20, x19)
        x22 = remove(x17, x0)
        x23 = argmax(x22, x21)
        x24 = color(x12)
        x25 = fill(I, x24, x23)
        return x25

    def verify_6430c8c4(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = sfilter(x0, hline)
        x2 = size(x1)
        x3 = positive(x2)
        x4 = branch(x3, tophalf, lefthalf)
        x5 = branch(x3, bottomhalf, righthalf)
        x6 = x4(I)
        x7 = x5(I)
        x8 = shape(x6)
        x9 = palette(x6)
        x10 = palette(x7)
        x11 = intersection(x9, x10)
        x12 = first(x11)
        x13 = ofcolor(x6, x12)
        x14 = ofcolor(x7, x12)
        x15 = intersection(x13, x14)
        x16 = canvas(x12, x8)
        x17 = fill(x16, THREE, x15)
        return x17

    def verify_6455b5f5(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = asindices(I)
        x2 = corners(x1)
        x3 = toobject(x2, I)
        x4 = mostcolor(x3)
        x5 = colorfilter(x0, x4)
        x6 = valmax(x5, size)
        x7 = valmin(x5, size)
        x8 = sizefilter(x5, x6)
        x9 = sizefilter(x5, x7)
        x10 = merge(x8)
        x11 = fill(I, ONE, x10)
        x12 = merge(x9)
        x13 = fill(x11, EIGHT, x12)
        return x13

    def verify_662c240a(I: Grid) -> Grid:
        x0 = portrait(I)
        x1 = branch(x0, vsplit, hsplit)
        x2 = shape(I)
        x3 = maximum(x2)
        x4 = minimum(x2)
        x5 = divide(x3, x4)
        x6 = x1(I, x5)
        x7 = fork(equality, identity, dmirror)
        x8 = compose(flip, x7)
        x9 = extract(x6, x8)
        return x9

    def verify_67385a82(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = palette(I)
        x2 = other(x1, ZERO)
        x3 = colorfilter(x0, x2)
        x4 = sizefilter(x3, ONE)
        x5 = difference(x3, x4)
        x6 = merge(x5)
        x7 = fill(I, EIGHT, x6)
        return x7

    def verify_673ef223(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = merge(x0)
        x2 = palette(x1)
        x3 = lbind(colorfilter, x0)
        x4 = compose(size, x3)
        x5 = matcher(x4, TWO)
        x6 = asindices(I)
        x7 = box(x6)
        x8 = rbind(difference, x7)
        x9 = lbind(ofcolor, I)
        x10 = chain(size, x8, x9)
        x11 = matcher(x10, ZERO)
        x12 = rbind(greater, ONE)
        x13 = lbind(apply, size)
        x14 = lbind(colorfilter, x0)
        x15 = compose(x13, x14)
        x16 = chain(x12, minimum, x15)
        x17 = fork(both, x11, x16)
        x18 = fork(both, x5, x17)
        x19 = extract(x2, x18)
        x20 = other(x2, x19)
        x21 = ofcolor(I, x20)
        x22 = colorfilter(x0, x19)
        x23 = rbind(vmatching, x21)
        x24 = rbind(hmatching, x21)
        x25 = fork(either, x23, x24)
        x26 = extract(x22, x25)
        x27 = other(x22, x26)
        x28 = rbind(gravitate, x26)
        x29 = compose(x28, initset)
        x30 = fork(add, identity, x29)
        x31 = fork(connect, identity, x30)
        x32 = mapply(x31, x21)
        x33 = fill(I, x20, x32)
        x34 = fill(x33, FOUR, x21)
        x35 = ofcolor(I, x19)
        x36 = apply(first, x35)
        x37 = size(x36)
        x38 = apply(last, x35)
        x39 = size(x38)
        x40 = greater(x37, x39)
        x41 = compose(toivec, first)
        x42 = compose(tojvec, last)
        x43 = branch(x40, x41, x42)
        x44 = branch(x40, hfrontier, vfrontier)
        x45 = ulcorner(x26)
        x46 = ulcorner(x27)
        x47 = subtract(x46, x45)
        x48 = x43(x47)
        x49 = shift(x21, x48)
        x50 = mapply(x44, x49)
        x51 = fill(x34, x20, x50)
        x52 = fill(x51, x19, x35)
        return x52

    def verify_6773b310(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = color(x1)
        x3 = shape(I)
        x4 = canvas(x2, x3)
        x5 = hconcat(I, x4)
        x6 = palette(I)
        x7 = remove(x2, x6)
        x8 = lbind(colorcount, I)
        x9 = argmin(x7, x8)
        x10 = other(x7, x9)
        x11 = objects(x5, F, T, T)
        x12 = rbind(colorcount, x9)
        x13 = valmax(x11, x12)
        x14 = rbind(colorcount, x9)
        x15 = matcher(x14, x13)
        x16 = sfilter(x11, x15)
        x17 = apply(ulcorner, x16)
        x18 = first(x11)
        x19 = shape(x18)
        x20 = increment(x19)
        x21 = rbind(divide, x20)
        x22 = apply(x21, x17)
        x23 = sfilter(x0, hline)
        x24 = size(x23)
        x25 = sfilter(x0, vline)
        x26 = size(x25)
        x27 = astuple(x24, x26)
        x28 = increment(x27)
        x29 = canvas(x10, x28)
        x30 = fill(x29, ONE, x22)
        return x30

    def verify_67a3c6ac(I: Grid) -> Grid:
        x0 = vmirror(I)
        return x0

    def verify_67a423a3(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = palette(I)
        x2 = remove(x0, x1)
        x3 = totuple(x2)
        x4 = first(x3)
        x5 = last(x3)
        x6 = ofcolor(I, x4)
        x7 = backdrop(x6)
        x8 = ofcolor(I, x5)
        x9 = backdrop(x8)
        x10 = intersection(x7, x9)
        x11 = outbox(x10)
        x12 = fill(I, FOUR, x11)
        return x12

    def verify_67e8384a(I: Grid) -> Grid:
        x0 = vmirror(I)
        x1 = hconcat(I, x0)
        x2 = hmirror(x1)
        x3 = vconcat(x1, x2)
        return x3

    def verify_681b3aeb(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = totuple(x0)
        x2 = first(x1)
        x3 = normalize(x2)
        x4 = last(x1)
        x5 = normalize(x4)
        x6 = color(x3)
        x7 = color(x5)
        x8 = toindices(x3)
        x9 = toindices(x5)
        x10 = fork(multiply, height, width)
        x11 = fork(equality, size, x10)
        x12 = lbind(shift, x8)
        x13 = lbind(shift, x9)
        x14 = compose(x12, first)
        x15 = compose(x13, last)
        x16 = fork(intersection, x14, x15)
        x17 = compose(size, x16)
        x18 = compose(x12, first)
        x19 = compose(x13, last)
        x20 = fork(combine, x18, x19)
        x21 = compose(x11, x20)
        x22 = matcher(x17, ZERO)
        x23 = fork(both, x22, x21)
        x24 = valmax(x1, height)
        x25 = valmax(x1, width)
        x26 = interval(ZERO, x24, ONE)
        x27 = interval(ZERO, x25, ONE)
        x28 = product(x26, x27)
        x29 = product(x28, x28)
        x30 = argmax(x29, x23)
        x31 = first(x30)
        x32 = shift(x8, x31)
        x33 = last(x30)
        x34 = shift(x9, x33)
        x35 = combine(x32, x34)
        x36 = shape(x35)
        x37 = canvas(x7, x36)
        x38 = ulcorner(x35)
        x39 = invert(x38)
        x40 = shift(x32, x39)
        x41 = fill(x37, x6, x40)
        return x41

    def verify_6855a6e4(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(difference, toindices, box)
        x2 = compose(size, x1)
        x3 = matcher(x2, ZERO)
        x4 = rbind(add, FOUR)
        x5 = chain(x4, double, width)
        x6 = fork(equality, size, x5)
        x7 = chain(x4, double, height)
        x8 = fork(equality, size, x7)
        x9 = fork(either, x6, x8)
        x10 = fork(both, x3, x9)
        x11 = extract(x0, x10)
        x12 = toindices(x11)
        x13 = center(x11)
        x14 = vfrontier(x13)
        x15 = intersection(x12, x14)
        x16 = size(x15)
        x17 = positive(x16)
        x18 = branch(x17, dmirror, identity)
        x19 = x18(I)
        x20 = color(x11)
        x21 = palette(I)
        x22 = remove(x20, x21)
        x23 = lbind(colorcount, I)
        x24 = argmin(x22, x23)
        x25 = other(x22, x24)
        x26 = ofcolor(x19, x24)
        x27 = ofcolor(x19, x20)
        x28 = leftmost(x27)
        x29 = lbind(greater, x28)
        x30 = compose(x29, last)
        x31 = sfilter(x26, x30)
        x32 = difference(x26, x31)
        x33 = vmirror(x31)
        x34 = leftmost(x27)
        x35 = leftmost(x31)
        x36 = subtract(x34, x35)
        x37 = add(TWO, x36)
        x38 = tojvec(x37)
        x39 = shift(x33, x38)
        x40 = vmirror(x32)
        x41 = rightmost(x32)
        x42 = rightmost(x27)
        x43 = subtract(x41, x42)
        x44 = add(TWO, x43)
        x45 = tojvec(x44)
        x46 = invert(x45)
        x47 = shift(x40, x46)
        x48 = fill(x19, x25, x26)
        x49 = combine(x39, x47)
        x50 = fill(x48, x24, x49)
        x51 = x18(x50)
        return x51

    def verify_68b16354(I: Grid) -> Grid:
        x0 = hmirror(I)
        return x0

    def verify_694f12f3(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = fork(multiply, height, width)
        x2 = fork(equality, size, x1)
        x3 = sfilter(x0, x2)
        x4 = compose(backdrop, inbox)
        x5 = argmin(x3, size)
        x6 = argmax(x3, size)
        x7 = x4(x5)
        x8 = x4(x6)
        x9 = fill(I, ONE, x7)
        x10 = fill(x9, TWO, x8)
        return x10

    def verify_6a1e5592(I: Grid) -> Grid:
        x0 = astuple(identity, dmirror)
        x1 = astuple(cmirror, hmirror)
        x2 = combine(x0, x1)
        x3 = fork(vsplit, identity, height)
        x4 = chain(asobject, first, x3)
        x5 = mostcolor(I)
        x6 = lbind(chain, numcolors)
        x7 = lbind(x6, x4)
        x8 = lbind(chain, color)
        x9 = lbind(x8, x4)
        x10 = rbind(rapply, I)
        x11 = compose(initset, x7)
        x12 = chain(first, x10, x11)
        x13 = rbind(rapply, I)
        x14 = compose(initset, x9)
        x15 = chain(first, x13, x14)
        x16 = matcher(x12, ONE)
        x17 = matcher(x15, x5)
        x18 = compose(flip, x17)
        x19 = fork(both, x16, x18)
        x20 = argmax(x2, x19)
        x21 = x20(I)
        x22 = x4(x21)
        x23 = color(x22)
        x24 = palette(x21)
        x25 = remove(x23, x24)
        x26 = other(x25, x5)
        x27 = objects(x21, T, T, T)
        x28 = colorfilter(x27, x26)
        x29 = ofcolor(x21, x23)
        x30 = ofcolor(x21, x5)
        x31 = mapply(neighbors, x30)
        x32 = mapply(neighbors, x31)
        x33 = lowermost(x29)
        x34 = dneighbors(ORIGIN)
        x35 = remove(DOWN, x34)
        x36 = rbind(mapply, x35)
        x37 = lbind(chain, x36)
        x38 = lbind(lbind, add)
        x39 = rbind(x37, x38)
        x40 = lbind(lbind, compose)
        x41 = lbind(lbind, shift)
        x42 = chain(x39, x40, x41)
        x43 = lbind(chain, size)
        x44 = rbind(intersection, x29)
        x45 = lbind(x43, x44)
        x46 = rbind(matcher, ZERO)
        x47 = lbind(lbind, shift)
        x48 = chain(x46, x45, x47)
        x49 = rbind(chain, first)
        x50 = rbind(x49, decrement)
        x51 = lbind(greater, x33)
        x52 = x50(x51)
        x53 = rbind(sfilter, x52)
        x54 = lbind(compose, x53)
        x55 = lbind(chain, size)
        x56 = rbind(difference, x30)
        x57 = lbind(x55, x56)
        x58 = rbind(matcher, ZERO)
        x59 = lbind(lbind, shift)
        x60 = chain(x58, x57, x59)
        x61 = lbind(chain, size)
        x62 = rbind(intersection, x30)
        x63 = lbind(x61, x62)
        x64 = lbind(fork, difference)
        x65 = compose(x54, x42)
        x66 = lbind(lbind, shift)
        x67 = fork(x64, x65, x66)
        x68 = compose(x63, x67)
        x69 = rbind(matcher, ZERO)
        x70 = compose(x69, x68)
        x71 = lbind(fork, both)
        x72 = fork(x71, x70, x60)
        x73 = lbind(fork, both)
        x74 = fork(x73, x48, x72)
        x75 = compose(normalize, toindices)
        x76 = lbind(sfilter, x32)
        x77 = chain(x76, x74, x75)
        x78 = rbind(argmin, first)
        x79 = compose(x78, x77)
        x80 = fork(shift, x75, x79)
        x81 = mapply(x80, x28)
        x82 = merge(x28)
        x83 = cover(x21, x82)
        x84 = fill(x83, ONE, x81)
        x85 = x20(x84)
        return x85

    def verify_6aa20dc0(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = mostcolor(I)
        x2 = valmax(x0, numcolors)
        x3 = matcher(numcolors, x2)
        x4 = mfilter(x0, x3)
        x5 = backdrop(x4)
        x6 = toobject(x5, I)
        x7 = matcher(first, x1)
        x8 = compose(flip, x7)
        x9 = sfilter(x6, x8)
        x10 = mostcolor(x9)
        x11 = initset(identity)
        x12 = insert(dmirror, x11)
        x13 = insert(cmirror, x12)
        x14 = insert(hmirror, x13)
        x15 = insert(vmirror, x14)
        x16 = shape(I)
        x17 = add(TWO, x16)
        x18 = canvas(x1, x17)
        x19 = asobject(I)
        x20 = shift(x19, UNITY)
        x21 = paint(x18, x20)
        x22 = interval(ONE, FIVE, ONE)
        x23 = matcher(first, x10)
        x24 = compose(flip, x23)
        x25 = rbind(sfilter, x24)
        x26 = compose(normalize, x25)
        x27 = chain(normalize, toindices, x26)
        x28 = lbind(upscale, x9)
        x29 = compose(initset, last)
        x30 = compose(x28, first)
        x31 = fork(rapply, x29, x30)
        x32 = chain(normalize, first, x31)
        x33 = compose(normalize, x26)
        x34 = lbind(recolor, x1)
        x35 = lbind(mapply, dneighbors)
        x36 = compose(x35, x27)
        x37 = fork(difference, x36, x27)
        x38 = compose(x34, x37)
        x39 = fork(combine, x33, x38)
        x40 = compose(x39, x32)
        x41 = lbind(lbind, shift)
        x42 = chain(ulcorner, x26, x32)
        x43 = fork(shift, x32, x42)
        x44 = compose(x41, x43)
        x45 = lbind(occurrences, x21)
        x46 = compose(x45, x40)
        x47 = fork(mapply, x44, x46)
        x48 = product(x22, x15)
        x49 = mapply(x47, x48)
        x50 = paint(I, x49)
        return x50

    def verify_6b9890af(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = fork(equality, toindices, box)
        x2 = sfilter(x0, x1)
        x3 = fork(multiply, height, width)
        x4 = argmax(x2, x3)
        x5 = fgpartition(I)
        x6 = merge(x5)
        x7 = difference(x6, x4)
        x8 = subgrid(x4, I)
        x9 = subgrid(x7, I)
        x10 = height(x8)
        x11 = subtract(x10, TWO)
        x12 = height(x9)
        x13 = divide(x11, x12)
        x14 = width(x8)
        x15 = subtract(x14, TWO)
        x16 = width(x9)
        x17 = divide(x15, x16)
        x18 = hupscale(x9, x17)
        x19 = vupscale(x18, x13)
        x20 = asobject(x19)
        x21 = shift(x20, UNITY)
        x22 = paint(x8, x21)
        return x22

    def verify_6c434453(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = rbind(greater, TWO)
        x2 = chain(x1, minimum, shape)
        x3 = sfilter(x0, x2)
        x4 = fork(equality, toindices, box)
        x5 = sfilter(x3, x4)
        x6 = mostcolor(I)
        x7 = merge(x5)
        x8 = fill(I, x6, x7)
        x9 = compose(hfrontier, center)
        x10 = compose(vfrontier, center)
        x11 = fork(combine, x9, x10)
        x12 = fork(intersection, x11, backdrop)
        x13 = mapply(x12, x5)
        x14 = fill(x8, TWO, x13)
        return x14

    def verify_6cdd2623(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = rbind(difference, x1)
        x3 = chain(size, x2, toindices)
        x4 = matcher(x3, ZERO)
        x5 = partition(I)
        x6 = sfilter(x5, x4)
        x7 = argmax(x6, size)
        x8 = color(x7)
        x9 = toindices(x7)
        x10 = fork(either, hline, vline)
        x11 = prapply(connect, x9, x9)
        x12 = compose(flip, x4)
        x13 = fork(both, x12, x10)
        x14 = mfilter(x11, x13)
        x15 = mostcolor(I)
        x16 = shape(I)
        x17 = canvas(x15, x16)
        x18 = fill(x17, x8, x14)
        return x18

    def verify_6cf79266(I: Grid) -> Grid:
        x0 = canvas(ZERO, THREE_BY_THREE)
        x1 = asobject(x0)
        x2 = occurrences(I, x1)
        x3 = lbind(shift, x1)
        x4 = mapply(x3, x2)
        x5 = fill(I, ONE, x4)
        return x5

    def verify_6d0160f0(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = mostcolor(x1)
        x3 = shape(I)
        x4 = canvas(NEG_ONE, x3)
        x5 = hconcat(I, x4)
        x6 = fill(x5, NEG_ONE, x1)
        x7 = objects(x6, F, F, T)
        x8 = lbind(contained, FOUR)
        x9 = compose(x8, palette)
        x10 = extract(x7, x9)
        x11 = lbind(sfilter, x7)
        x12 = compose(size, x11)
        x13 = rbind(compose, palette)
        x14 = lbind(lbind, contained)
        x15 = chain(x12, x13, x14)
        x16 = merge(x7)
        x17 = palette(I)
        x18 = remove(x2, x17)
        x19 = valmax(x18, x15)
        x20 = matcher(x15, x19)
        x21 = sfilter(x18, x20)
        x22 = lbind(colorcount, x16)
        x23 = argmax(x21, x22)
        x24 = shape(I)
        x25 = canvas(x23, x24)
        x26 = paint(x25, x1)
        x27 = normalize(x10)
        x28 = matcher(first, x2)
        x29 = compose(flip, x28)
        x30 = sfilter(x27, x29)
        x31 = shape(x27)
        x32 = increment(x31)
        x33 = matcher(first, FOUR)
        x34 = sfilter(x27, x33)
        x35 = center(x34)
        x36 = multiply(x32, x35)
        x37 = shift(x30, x36)
        x38 = paint(x26, x37)
        return x38

    def verify_6d0aefbc(I: Grid) -> Grid:
        x0 = vmirror(I)
        x1 = hconcat(I, x0)
        return x1

    def verify_6d58a25d(I: Grid) -> Grid:
        x0 = astuple(ONE, THREE)
        x1 = astuple(TWO, FOUR)
        x2 = initset(x1)
        x3 = insert(TWO_BY_TWO, x2)
        x4 = insert(x0, x3)
        x5 = tojvec(THREE)
        x6 = toivec(THREE)
        x7 = connect(x5, x6)
        x8 = astuple(THREE, SIX)
        x9 = connect(x5, x8)
        x10 = combine(x7, x9)
        x11 = combine(x4, x10)
        x12 = lbind(contained, x11)
        x13 = compose(normalize, toindices)
        x14 = lbind(apply, x13)
        x15 = chain(x12, x14, partition)
        x16 = astuple(identity, identity)
        x17 = astuple(rot90, rot270)
        x18 = astuple(x16, x17)
        x19 = astuple(rot180, rot180)
        x20 = astuple(rot270, rot90)
        x21 = astuple(x19, x20)
        x22 = combine(x18, x21)
        x23 = rbind(rapply, I)
        x24 = compose(initset, first)
        x25 = chain(first, x23, x24)
        x26 = compose(x15, x25)
        x27 = extract(x22, x26)
        x28 = first(x27)
        x29 = last(x27)
        x30 = x28(I)
        x31 = palette(I)
        x32 = lbind(ofcolor, x30)
        x33 = compose(normalize, x32)
        x34 = matcher(x33, x11)
        x35 = extract(x31, x34)
        x36 = remove(x35, x31)
        x37 = lbind(colorcount, x30)
        x38 = argmin(x36, x37)
        x39 = ofcolor(x30, x38)
        x40 = ofcolor(x30, x35)
        x41 = compose(positive, size)
        x42 = rbind(intersection, x40)
        x43 = rbind(shoot, UP)
        x44 = chain(x41, x42, x43)
        x45 = sfilter(x39, x44)
        x46 = height(x30)
        x47 = rbind(valmax, first)
        x48 = lbind(sfilter, x40)
        x49 = lbind(matcher, last)
        x50 = chain(x48, x49, last)
        x51 = chain(increment, x47, x50)
        x52 = fork(astuple, x51, last)
        x53 = decrement(x46)
        x54 = lbind(astuple, x53)
        x55 = compose(x54, last)
        x56 = fork(connect, x52, x55)
        x57 = mapply(x56, x45)
        x58 = fill(x30, x38, x57)
        x59 = x29(x58)
        return x59

    def verify_6d75e8bb(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = argmin(x0, size)
        x2 = delta(x1)
        x3 = fill(I, TWO, x2)
        return x3

    def verify_6e02f1e3(I: Grid) -> Grid:
        x0 = numcolors(I)
        x1 = equality(x0, THREE)
        x2 = height(I)
        x3 = decrement(x2)
        x4 = toivec(x3)
        x5 = branch(x1, x4, ORIGIN)
        x6 = equality(x0, TWO)
        x7 = shape(I)
        x8 = decrement(x7)
        x9 = width(I)
        x10 = decrement(x9)
        x11 = tojvec(x10)
        x12 = branch(x6, x8, x11)
        x13 = shape(I)
        x14 = canvas(ZERO, x13)
        x15 = connect(x5, x12)
        x16 = fill(x14, FIVE, x15)
        return x16

    def verify_6e19193c(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = rbind(shoot, UNITY)
        x2 = rbind(add, UNITY)
        x3 = chain(x1, x2, lrcorner)
        x4 = fork(recolor, color, x3)
        x5 = rbind(shoot, UP_RIGHT)
        x6 = rbind(add, UP_RIGHT)
        x7 = chain(x5, x6, urcorner)
        x8 = fork(recolor, color, x7)
        x9 = rbind(shoot, NEG_UNITY)
        x10 = rbind(add, NEG_UNITY)
        x11 = chain(x9, x10, ulcorner)
        x12 = fork(recolor, color, x11)
        x13 = rbind(shoot, DOWN_LEFT)
        x14 = rbind(add, DOWN_LEFT)
        x15 = chain(x13, x14, llcorner)
        x16 = fork(recolor, color, x15)
        x17 = fork(remove, lrcorner, toindices)
        x18 = fork(equality, toindices, x17)
        x19 = sfilter(x0, x18)
        x20 = fork(remove, urcorner, toindices)
        x21 = fork(equality, toindices, x20)
        x22 = sfilter(x0, x21)
        x23 = fork(remove, ulcorner, toindices)
        x24 = fork(equality, toindices, x23)
        x25 = sfilter(x0, x24)
        x26 = fork(remove, llcorner, toindices)
        x27 = fork(equality, toindices, x26)
        x28 = sfilter(x0, x27)
        x29 = mapply(x4, x19)
        x30 = mapply(x8, x22)
        x31 = combine(x29, x30)
        x32 = mapply(x12, x25)
        x33 = mapply(x16, x28)
        x34 = combine(x32, x33)
        x35 = combine(x31, x34)
        x36 = paint(I, x35)
        return x36

    def verify_6e82a1ae(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = matcher(size, TWO)
        x2 = mfilter(x0, x1)
        x3 = matcher(size, THREE)
        x4 = mfilter(x0, x3)
        x5 = matcher(size, FOUR)
        x6 = mfilter(x0, x5)
        x7 = fill(I, THREE, x2)
        x8 = fill(x7, TWO, x4)
        x9 = fill(x8, ONE, x6)
        return x9

    def verify_6ecd11f4(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = argmax(x0, numcolors)
        x2 = argmin(x0, numcolors)
        x3 = mostcolor(I)
        x4 = shape(x2)
        x5 = canvas(x3, x4)
        x6 = normalize(x2)
        x7 = paint(x5, x6)
        x8 = height(x1)
        x9 = width(x1)
        x10 = height(x2)
        x11 = width(x2)
        x12 = normalize(x1)
        x13 = divide(x10, x8)
        x14 = divide(x11, x9)
        x15 = width(x7)
        x16 = interval(ZERO, x15, ONE)
        x17 = height(x7)
        x18 = interval(ZERO, x17, ONE)
        x19 = rbind(multiply, x14)
        x20 = rbind(divide, x14)
        x21 = compose(x19, x20)
        x22 = fork(equality, identity, x21)
        x23 = rbind(multiply, x13)
        x24 = rbind(divide, x13)
        x25 = compose(x23, x24)
        x26 = fork(equality, identity, x25)
        x27 = lbind(apply, last)
        x28 = compose(x22, first)
        x29 = rbind(sfilter, x28)
        x30 = lbind(pair, x16)
        x31 = chain(x27, x29, x30)
        x32 = compose(x31, last)
        x33 = pair(x18, x7)
        x34 = compose(x26, first)
        x35 = sfilter(x33, x34)
        x36 = apply(x32, x35)
        x37 = color(x2)
        x38 = ofcolor(x36, x37)
        x39 = rbind(contained, x38)
        x40 = compose(x39, last)
        x41 = sfilter(x12, x40)
        x42 = paint(x36, x41)
        return x42

    def verify_6f8cd79b(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = fill(I, EIGHT, x1)
        return x2

    def verify_6fa7a44f(I: Grid) -> Grid:
        x0 = hmirror(I)
        x1 = vconcat(I, x0)
        return x1

    def verify_72322fa7(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = matcher(numcolors, TWO)
        x2 = sfilter(x0, x1)
        x3 = apply(normalize, x2)
        x4 = chain(first, totuple, palette)
        x5 = chain(last, totuple, palette)
        x6 = lbind(matcher, first)
        x7 = compose(x6, x4)
        x8 = lbind(matcher, first)
        x9 = compose(x8, x5)
        x10 = fork(sfilter, identity, x7)
        x11 = fork(sfilter, identity, x9)
        x12 = lbind(occurrences, I)
        x13 = chain(invert, ulcorner, x10)
        x14 = chain(invert, ulcorner, x11)
        x15 = lbind(lbind, shift)
        x16 = fork(shift, identity, x13)
        x17 = fork(shift, identity, x14)
        x18 = compose(x15, x16)
        x19 = compose(x12, x10)
        x20 = fork(mapply, x18, x19)
        x21 = compose(x15, x17)
        x22 = compose(x12, x11)
        x23 = fork(mapply, x21, x22)
        x24 = fork(combine, x20, x23)
        x25 = mapply(x24, x3)
        x26 = paint(I, x25)
        return x26

    def verify_72ca375d(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = fork(equality, identity, vmirror)
        x2 = extract(x0, x1)
        x3 = subgrid(x2, I)
        return x3

    def verify_73251a56(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = asindices(I)
        x2 = urcorner(x1)
        x3 = index(I, ORIGIN)
        x4 = shoot(ORIGIN, UNITY)
        x5 = recolor(x3, x4)
        x6 = index(I, x2)
        x7 = shoot(x2, DOWN_LEFT)
        x8 = recolor(x6, x7)
        x9 = astuple(dmirror, x5)
        x10 = astuple(cmirror, x8)
        x11 = initset(x10)
        x12 = insert(x9, x11)
        x13 = product(x0, x12)
        x14 = asobject(I)
        x15 = lbind(sfilter, x14)
        x16 = lbind(compose, flip)
        x17 = lbind(matcher, first)
        x18 = chain(x15, x16, x17)
        x19 = lbind(paint, I)
        x20 = compose(last, last)
        x21 = compose(first, last)
        x22 = lbind(fork, equality)
        x23 = rbind(x22, identity)
        x24 = compose(x18, first)
        x25 = compose(x23, x21)
        x26 = compose(initset, x21)
        x27 = fork(rapply, x26, x24)
        x28 = compose(first, x27)
        x29 = compose(x19, x28)
        x30 = fork(paint, x29, x20)
        x31 = compose(initset, x25)
        x32 = fork(rapply, x31, x30)
        x33 = compose(first, x32)
        x34 = sfilter(x13, x33)
        x35 = lbind(colorcount, I)
        x36 = compose(x35, first)
        x37 = argmin(x34, x36)
        x38 = first(x37)
        x39 = last(x37)
        x40 = first(x39)
        x41 = last(x37)
        x42 = last(x41)
        x43 = x18(x38)
        x44 = x40(x43)
        x45 = paint(I, x44)
        x46 = paint(x45, x42)
        x47 = ofcolor(x46, x38)
        x48 = mapply(dneighbors, x47)
        x49 = difference(x48, x47)
        x50 = toobject(x49, x46)
        x51 = size(x50)
        x52 = positive(x51)
        x53 = rbind(astuple, x38)
        x54 = compose(last, x53)
        x55 = branch(x52, mostcolor, x54)
        x56 = x55(x50)
        x57 = replace(x46, x38, x56)
        return x57

    def verify_7447852a(I: Grid) -> Grid:
        x0 = index(I, ORIGIN)
        x1 = shape(I)
        x2 = canvas(x0, x1)
        x3 = hconcat(I, x2)
        x4 = objects(x3, F, F, T)
        x5 = compose(last, centerofmass)
        x6 = order(x4, x5)
        x7 = size(x6)
        x8 = interval(ZERO, x7, ONE)
        x9 = pair(x6, x8)
        x10 = rbind(multiply, THREE)
        x11 = rbind(divide, THREE)
        x12 = chain(x10, x11, last)
        x13 = fork(equality, last, x12)
        x14 = sfilter(x9, x13)
        x15 = mapply(first, x14)
        x16 = fill(I, FOUR, x15)
        return x16

    def verify_7468f01a(I: Grid) -> Grid:
        x0 = compress(I)
        x1 = vmirror(x0)
        return x1

    def verify_746b3537(I: Grid) -> Grid:
        x0 = first(I)
        x1 = dedupe(x0)
        x2 = size(x1)
        x3 = equality(ONE, x2)
        x4 = branch(x3, dmirror, identity)
        x5 = x4(I)
        x6 = objects(x5, T, F, F)
        x7 = order(x6, leftmost)
        x8 = apply(color, x7)
        x9 = repeat(x8, ONE)
        x10 = x4(x9)
        return x10

    def verify_74dd1130(I: Grid) -> Grid:
        x0 = dmirror(I)
        return x0

    def verify_75b8110e(I: Grid) -> Grid:
        x0 = tophalf(I)
        x1 = lefthalf(x0)
        x2 = tophalf(I)
        x3 = righthalf(x2)
        x4 = bottomhalf(I)
        x5 = righthalf(x4)
        x6 = bottomhalf(I)
        x7 = lefthalf(x6)
        x8 = palette(x1)
        x9 = palette(x3)
        x10 = intersection(x8, x9)
        x11 = palette(x5)
        x12 = palette(x7)
        x13 = intersection(x11, x12)
        x14 = intersection(x10, x13)
        x15 = first(x14)
        x16 = shape(x1)
        x17 = canvas(x15, x16)
        x18 = matcher(first, x15)
        x19 = compose(flip, x18)
        x20 = rbind(sfilter, x19)
        x21 = compose(x20, asobject)
        x22 = x21(x1)
        x23 = x21(x5)
        x24 = x21(x7)
        x25 = x21(x3)
        x26 = paint(x17, x22)
        x27 = paint(x26, x23)
        x28 = paint(x27, x24)
        x29 = paint(x28, x25)
        return x29

    def verify_760b3cac(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = matcher(shape, THREE_BY_THREE)
        x2 = matcher(size, FIVE)
        x3 = fork(intersection, toindices, box)
        x4 = compose(size, x3)
        x5 = matcher(x4, FOUR)
        x6 = fork(intersection, toindices, corners)
        x7 = compose(size, x6)
        x8 = matcher(x7, ONE)
        x9 = fork(both, x1, x2)
        x10 = fork(both, x5, x8)
        x11 = fork(both, x9, x10)
        x12 = extract(x0, x11)
        x13 = toindices(x12)
        x14 = lowermost(x12)
        x15 = matcher(first, x14)
        x16 = uppermost(x12)
        x17 = matcher(first, x16)
        x18 = rightmost(x12)
        x19 = matcher(last, x18)
        x20 = leftmost(x12)
        x21 = matcher(last, x20)
        x22 = sfilter(x13, x15)
        x23 = size(x22)
        x24 = equality(x23, TWO)
        x25 = sfilter(x13, x17)
        x26 = size(x25)
        x27 = equality(x26, TWO)
        x28 = sfilter(x13, x19)
        x29 = size(x28)
        x30 = equality(x29, TWO)
        x31 = sfilter(x13, x21)
        x32 = size(x31)
        x33 = equality(x32, TWO)
        x34 = either(x24, x27)
        x35 = branch(x34, hmirror, vmirror)
        x36 = multiply(x24, DOWN)
        x37 = multiply(x27, UP)
        x38 = add(x36, x37)
        x39 = multiply(x30, RIGHT)
        x40 = multiply(x33, LEFT)
        x41 = add(x39, x40)
        x42 = add(x38, x41)
        x43 = other(x0, x12)
        x44 = x35(x43)
        x45 = shape(x43)
        x46 = multiply(x45, x42)
        x47 = shift(x44, x46)
        x48 = paint(I, x47)
        return x48

    def verify_776ffc46(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = fork(equality, toindices, box)
        x2 = sfilter(x0, x1)
        x3 = fork(multiply, height, width)
        x4 = argmax(x2, x3)
        x5 = mostcolor(I)
        x6 = inbox(x4)
        x7 = backdrop(x6)
        x8 = toobject(x7, I)
        x9 = matcher(first, x5)
        x10 = compose(flip, x9)
        x11 = sfilter(x8, x10)
        x12 = normalize(x11)
        x13 = color(x12)
        x14 = toindices(x12)
        x15 = compose(toindices, normalize)
        x16 = matcher(x15, x14)
        x17 = mfilter(x0, x16)
        x18 = fill(I, x13, x17)
        return x18

    def verify_77fdfe62(I: Grid) -> Grid:
        x0 = trim(I)
        x1 = trim(x0)
        x2 = tophalf(x1)
        x3 = lefthalf(x2)
        x4 = tophalf(x1)
        x5 = righthalf(x4)
        x6 = bottomhalf(x1)
        x7 = lefthalf(x6)
        x8 = bottomhalf(x1)
        x9 = righthalf(x8)
        x10 = index(I, ORIGIN)
        x11 = width(I)
        x12 = decrement(x11)
        x13 = tojvec(x12)
        x14 = index(I, x13)
        x15 = height(I)
        x16 = decrement(x15)
        x17 = toivec(x16)
        x18 = index(I, x17)
        x19 = shape(I)
        x20 = decrement(x19)
        x21 = index(I, x20)
        x22 = compress(I)
        x23 = asindices(x22)
        x24 = box(x23)
        x25 = corners(x23)
        x26 = difference(x24, x25)
        x27 = toobject(x26, x22)
        x28 = color(x27)
        x29 = palette(x1)
        x30 = other(x29, x28)
        x31 = replace(x3, x30, x10)
        x32 = replace(x5, x30, x14)
        x33 = replace(x7, x30, x18)
        x34 = replace(x9, x30, x21)
        x35 = hconcat(x31, x32)
        x36 = hconcat(x33, x34)
        x37 = vconcat(x35, x36)
        return x37

    def verify_780d0b14(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = color(x1)
        x3 = merge(x0)
        x4 = fill(I, NEG_ONE, x3)
        x5 = shape(I)
        x6 = canvas(NEG_ONE, x5)
        x7 = hconcat(x4, x6)
        x8 = objects(x7, F, F, T)
        x9 = rbind(other, x2)
        x10 = compose(x9, palette)
        x11 = fork(astuple, x10, ulcorner)
        x12 = apply(x11, x8)
        x13 = merge(x8)
        x14 = fill(I, x2, x13)
        x15 = paint(x14, x12)
        x16 = compress(x15)
        return x16

    def verify_7837ac64(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = fork(equality, toindices, backdrop)
        x2 = sfilter(x0, x1)
        x3 = fork(multiply, height, width)
        x4 = argmax(x2, x3)
        x5 = color(x4)
        x6 = palette(I)
        x7 = remove(x5, x6)
        x8 = lbind(colorcount, I)
        x9 = argmax(x7, x8)
        x10 = remove(x9, x7)
        x11 = lbind(ofcolor, I)
        x12 = mapply(x11, x10)
        x13 = subgrid(x12, I)
        x14 = objects(x13, T, F, F)
        x15 = colorfilter(x14, x5)
        x16 = initset(x9)
        x17 = insert(x5, x16)
        x18 = lbind(intersection, x17)
        x19 = chain(positive, size, x18)
        x20 = chain(positive, decrement, size)
        x21 = fork(either, x19, x20)
        x22 = rbind(toobject, x13)
        x23 = compose(corners, outbox)
        x24 = chain(palette, x22, x23)
        x25 = rbind(branch, x5)
        x26 = chain(flip, x21, x24)
        x27 = compose(first, x24)
        x28 = fork(x25, x26, x27)
        x29 = apply(uppermost, x15)
        x30 = order(x29, identity)
        x31 = lbind(apply, x28)
        x32 = rbind(order, leftmost)
        x33 = lbind(sfilter, x15)
        x34 = lbind(matcher, uppermost)
        x35 = compose(x33, x34)
        x36 = chain(x31, x32, x35)
        x37 = apply(x36, x30)
        return x37

    def verify_794b24be(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = remove(ONE, x0)
        x2 = lbind(colorcount, I)
        x3 = argmax(x1, x2)
        x4 = canvas(x3, THREE_BY_THREE)
        x5 = colorcount(I, ONE)
        x6 = decrement(x5)
        x7 = tojvec(x6)
        x8 = connect(ORIGIN, x7)
        x9 = fill(x4, TWO, x8)
        x10 = initset(UNITY)
        x11 = equality(x5, FOUR)
        x12 = branch(x11, x10, x8)
        x13 = fill(x9, TWO, x12)
        return x13

    def verify_7b6016b9(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = asindices(I)
        x2 = box(x1)
        x3 = toobject(x2, I)
        x4 = mostcolor(x3)
        x5 = colorfilter(x0, x4)
        x6 = rbind(bordering, I)
        x7 = compose(flip, x6)
        x8 = mfilter(x5, x7)
        x9 = fill(I, TWO, x8)
        x10 = replace(x9, x4, THREE)
        return x10

    def verify_7b7f7511(I: Grid) -> Grid:
        x0 = lefthalf(I)
        x1 = righthalf(I)
        x2 = equality(x0, x1)
        x3 = branch(x2, lefthalf, tophalf)
        x4 = x3(I)
        return x4

    def verify_7c008303(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = color(x1)
        x3 = shape(I)
        x4 = canvas(x2, x3)
        x5 = hconcat(I, x4)
        x6 = objects(x5, F, F, T)
        x7 = argmin(x6, size)
        x8 = argmax(x6, size)
        x9 = remove(x8, x6)
        x10 = remove(x7, x9)
        x11 = merge(x10)
        x12 = color(x11)
        x13 = subgrid(x8, I)
        x14 = subgrid(x7, I)
        x15 = width(x8)
        x16 = halve(x15)
        x17 = hupscale(x14, x16)
        x18 = height(x8)
        x19 = halve(x18)
        x20 = vupscale(x17, x19)
        x21 = asobject(x20)
        x22 = asindices(x13)
        x23 = ofcolor(x13, x12)
        x24 = difference(x22, x23)
        x25 = rbind(contained, x24)
        x26 = compose(x25, last)
        x27 = sfilter(x21, x26)
        x28 = paint(x13, x27)
        return x28

    def verify_7ddcd7ec(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = argmax(x0, size)
        x2 = remove(x1, x0)
        x3 = lbind(position, x1)
        x4 = fork(shoot, center, x3)
        x5 = fork(recolor, color, x4)
        x6 = mapply(x5, x2)
        x7 = paint(I, x6)
        return x7

    def verify_7df24a62(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = compose(maximum, shape)
        x2 = argmin(x0, x1)
        x3 = color(x2)
        x4 = palette(I)
        x5 = remove(x3, x4)
        x6 = lbind(colorcount, I)
        x7 = argmin(x5, x6)
        x8 = mostcolor(I)
        x9 = shape(I)
        x10 = increment(x9)
        x11 = increment(x10)
        x12 = canvas(x8, x11)
        x13 = asobject(I)
        x14 = shift(x13, UNITY)
        x15 = paint(x12, x14)
        x16 = repeat(identity, ONE)
        x17 = astuple(cmirror, dmirror)
        x18 = astuple(hmirror, vmirror)
        x19 = combine(x17, x18)
        x20 = combine(x16, x19)
        x21 = fork(compose, first, last)
        x22 = product(x20, x20)
        x23 = apply(x21, x22)
        x24 = ofcolor(x15, x3)
        x25 = backdrop(x24)
        x26 = toobject(x25, x15)
        x27 = matcher(first, x7)
        x28 = rbind(sfilter, x27)
        x29 = matcher(first, x3)
        x30 = rbind(sfilter, x29)
        x31 = lbind(recolor, x8)
        x32 = compose(x31, x30)
        x33 = fork(combine, x28, x32)
        x34 = lbind(lbind, shift)
        x35 = lbind(occurrences, x15)
        x36 = compose(x35, x33)
        x37 = fork(mapply, x34, x36)
        x38 = lbind(chain, x37)
        x39 = lbind(x38, normalize)
        x40 = rbind(rapply, x26)
        x41 = initset(x39)
        x42 = lbind(rapply, x41)
        x43 = chain(first, x40, x42)
        x44 = mapply(x43, x23)
        x45 = paint(x15, x44)
        x46 = trim(x45)
        return x46

    def verify_7e0986d6(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = objects(I, T, F, T)
        x2 = lbind(greater, THREE)
        x3 = compose(x2, size)
        x4 = sfilter(x1, x3)
        x5 = mapply(toindices, x4)
        x6 = fill(I, x0, x5)
        x7 = objects(x6, T, F, T)
        x8 = fork(recolor, color, backdrop)
        x9 = mapply(x8, x7)
        x10 = paint(x6, x9)
        return x10

    def verify_7f4411dc(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = totuple(x0)
        x2 = apply(color, x1)
        x3 = mostcommon(x2)
        x4 = canvas(x3, TWO_BY_TWO)
        x5 = asobject(x4)
        x6 = palette(I)
        x7 = matcher(identity, x3)
        x8 = argmin(x6, x7)
        x9 = shape(I)
        x10 = canvas(x8, x9)
        x11 = lbind(shift, x5)
        x12 = occurrences(I, x5)
        x13 = mapply(x11, x12)
        x14 = paint(x10, x13)
        return x14

    def verify_7fe24cdd(I: Grid) -> Grid:
        x0 = rot90(I)
        x1 = rot180(I)
        x2 = rot270(I)
        x3 = hconcat(I, x0)
        x4 = hconcat(x2, x1)
        x5 = vconcat(x3, x4)
        return x5

    def verify_80af3007(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = argmin(x0, x1)
        x3 = color(x2)
        x4 = palette(I)
        x5 = other(x4, x3)
        x6 = subgrid(x2, I)
        x7 = fork(multiply, identity, identity)
        x8 = width(x6)
        x9 = matcher(x7, x8)
        x10 = fork(multiply, identity, identity)
        x11 = height(x6)
        x12 = matcher(x10, x11)
        x13 = width(x6)
        x14 = interval(ONE, x13, ONE)
        x15 = extract(x14, x9)
        x16 = height(x6)
        x17 = interval(ONE, x16, ONE)
        x18 = extract(x17, x12)
        x19 = width(x6)
        x20 = interval(ZERO, x19, ONE)
        x21 = height(x6)
        x22 = interval(ZERO, x21, ONE)
        x23 = rbind(multiply, x15)
        x24 = rbind(divide, x15)
        x25 = compose(x23, x24)
        x26 = fork(equality, identity, x25)
        x27 = compose(x26, last)
        x28 = rbind(multiply, x18)
        x29 = rbind(divide, x18)
        x30 = compose(x28, x29)
        x31 = fork(equality, identity, x30)
        x32 = compose(x31, last)
        x33 = lbind(apply, first)
        x34 = rbind(sfilter, x27)
        x35 = rbind(pair, x20)
        x36 = chain(x33, x34, x35)
        x37 = pair(x6, x22)
        x38 = sfilter(x37, x32)
        x39 = apply(first, x38)
        x40 = apply(x36, x39)
        x41 = shape(x40)
        x42 = multiply(x41, x41)
        x43 = canvas(x5, x42)
        x44 = ofcolor(x40, x3)
        x45 = rbind(multiply, x41)
        x46 = apply(x45, x44)
        x47 = lbind(shift, x44)
        x48 = mapply(x47, x46)
        x49 = fill(x43, x3, x48)
        return x49

    def verify_810b9b61(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = rbind(greater, TWO)
        x2 = chain(x1, minimum, shape)
        x3 = fork(equality, toindices, box)
        x4 = fork(both, x2, x3)
        x5 = mfilter(x0, x4)
        x6 = fill(I, THREE, x5)
        return x6

    def verify_82819916(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = sfilter(x0, hline)
        x2 = size(x1)
        x3 = positive(x2)
        x4 = branch(x3, identity, dmirror)
        x5 = x4(I)
        x6 = frontiers(I)
        x7 = merge(x6)
        x8 = mostcolor(x7)
        x9 = matcher(identity, x8)
        x10 = rbind(sfilter, x9)
        x11 = compose(size, x10)
        x12 = argmin(x5, x11)
        x13 = repeat(x12, ONE)
        x14 = asobject(x13)
        x15 = palette(x14)
        x16 = totuple(x15)
        x17 = first(x16)
        x18 = last(x16)
        x19 = fgpartition(x5)
        x20 = merge(x19)
        x21 = toindices(x20)
        x22 = apply(first, x21)
        x23 = lbind(sfilter, x20)
        x24 = compose(first, last)
        x25 = lbind(matcher, x24)
        x26 = compose(x23, x25)
        x27 = apply(x26, x22)
        x28 = lbind(shift, x14)
        x29 = chain(x28, toivec, uppermost)
        x30 = matcher(first, x17)
        x31 = rbind(sfilter, x30)
        x32 = rbind(compose, last)
        x33 = lbind(rbind, contained)
        x34 = chain(toindices, x31, x29)
        x35 = chain(x32, x33, x34)
        x36 = fork(sfilter, identity, x35)
        x37 = compose(color, x36)
        x38 = compose(x31, x29)
        x39 = fork(recolor, x37, x38)
        x40 = fork(other, palette, x37)
        x41 = compose(x31, x29)
        x42 = fork(difference, x29, x41)
        x43 = fork(recolor, x40, x42)
        x44 = fork(combine, x39, x43)
        x45 = mapply(x44, x27)
        x46 = paint(x5, x45)
        x47 = x4(x46)
        return x47

    def verify_83302e8f(I: Grid) -> Grid:
        x0 = index(I, ORIGIN)
        x1 = objects(I, T, F, F)
        x2 = fork(multiply, height, width)
        x3 = fork(equality, size, x2)
        x4 = chain(positive, decrement, size)
        x5 = colorfilter(x1, x0)
        x6 = fork(both, x3, x4)
        x7 = sfilter(x5, x6)
        x8 = merge(x7)
        x9 = ofcolor(I, x0)
        x10 = fill(I, FOUR, x9)
        x11 = fill(x10, THREE, x8)
        return x11

    def verify_834ec97d(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = argmin(x0, size)
        x2 = cover(I, x1)
        x3 = shift(x1, DOWN)
        x4 = paint(x2, x3)
        x5 = leftmost(x1)
        x6 = width(I)
        x7 = interval(x5, x6, TWO)
        x8 = leftmost(x1)
        x9 = interval(x8, NEG_ONE, NEG_TWO)
        x10 = combine(x7, x9)
        x11 = rbind(shoot, UP)
        x12 = uppermost(x1)
        x13 = lbind(astuple, x12)
        x14 = apply(x13, x10)
        x15 = mapply(x11, x14)
        x16 = fill(x4, FOUR, x15)
        return x16

    def verify_8403a5d5(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = argmin(x0, size)
        x2 = color(x1)
        x3 = leftmost(x1)
        x4 = width(I)
        x5 = interval(x3, x4, TWO)
        x6 = apply(tojvec, x5)
        x7 = mapply(vfrontier, x6)
        x8 = fill(I, x2, x7)
        x9 = increment(x3)
        x10 = width(I)
        x11 = interval(x9, x10, FOUR)
        x12 = add(x3, THREE)
        x13 = width(I)
        x14 = interval(x12, x13, FOUR)
        x15 = apply(tojvec, x11)
        x16 = height(I)
        x17 = decrement(x16)
        x18 = lbind(astuple, x17)
        x19 = apply(x18, x14)
        x20 = combine(x15, x19)
        x21 = fill(x8, FIVE, x20)
        return x21

    def verify_846bdb03(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(equality, corners, toindices)
        x2 = extract(x0, x1)
        x3 = subgrid(x2, I)
        x4 = backdrop(x2)
        x5 = cover(I, x4)
        x6 = frontiers(x3)
        x7 = sfilter(x6, hline)
        x8 = size(x7)
        x9 = positive(x8)
        x10 = branch(x9, dmirror, identity)
        x11 = x10(x3)
        x12 = x10(x5)
        x13 = fgpartition(x12)
        x14 = merge(x13)
        x15 = normalize(x14)
        x16 = mostcolor(x12)
        x17 = color(x2)
        x18 = palette(x11)
        x19 = remove(x17, x18)
        x20 = remove(x16, x19)
        x21 = first(x20)
        x22 = last(x20)
        x23 = ofcolor(x11, x22)
        x24 = leftmost(x23)
        x25 = ofcolor(x11, x21)
        x26 = leftmost(x25)
        x27 = greater(x24, x26)
        x28 = ofcolor(x12, x22)
        x29 = leftmost(x28)
        x30 = ofcolor(x12, x21)
        x31 = leftmost(x30)
        x32 = greater(x29, x31)
        x33 = equality(x27, x32)
        x34 = branch(x33, identity, vmirror)
        x35 = x34(x15)
        x36 = shift(x35, UNITY)
        x37 = paint(x11, x36)
        x38 = x10(x37)
        return x38

    def verify_855e0971(I: Grid) -> Grid:
        x0 = lbind(greater, THREE)
        x1 = chain(x0, size, dedupe)
        x2 = apply(x1, I)
        x3 = contained(F, x2)
        x4 = flip(x3)
        x5 = branch(x4, identity, dmirror)
        x6 = x5(I)
        x7 = rbind(toobject, I)
        x8 = chain(palette, x7, neighbors)
        x9 = lbind(chain, flip)
        x10 = rbind(x9, x8)
        x11 = lbind(lbind, contained)
        x12 = compose(x10, x11)
        x13 = lbind(ofcolor, I)
        x14 = fork(sfilter, x13, x12)
        x15 = compose(size, x14)
        x16 = palette(I)
        x17 = argmax(x16, x15)
        x18 = objects(x6, T, T, F)
        x19 = colorfilter(x18, x17)
        x20 = difference(x18, x19)
        x21 = rbind(subgrid, x6)
        x22 = order(x20, uppermost)
        x23 = apply(x21, x22)
        x24 = lbind(recolor, x17)
        x25 = lbind(mapply, vfrontier)
        x26 = rbind(ofcolor, x17)
        x27 = chain(x24, x25, x26)
        x28 = fork(paint, identity, x27)
        x29 = mapply(x28, x23)
        x30 = x5(x29)
        return x30

    def verify_85c4e7cd(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = shape(I)
        x3 = minimum(x2)
        x4 = halve(x3)
        x5 = interval(ONE, x4, ONE)
        x6 = lbind(power, inbox)
        x7 = rbind(rapply, x1)
        x8 = compose(initset, x6)
        x9 = chain(first, x7, x8)
        x10 = apply(x9, x5)
        x11 = repeat(x1, ONE)
        x12 = combine(x11, x10)
        x13 = rbind(toobject, I)
        x14 = compose(color, x13)
        x15 = apply(x14, x12)
        x16 = interval(ZERO, x4, ONE)
        x17 = pair(x16, x15)
        x18 = compose(invert, first)
        x19 = order(x17, x18)
        x20 = apply(last, x19)
        x21 = mpapply(recolor, x20, x12)
        x22 = paint(I, x21)
        return x22

    def verify_868de0fa(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = sfilter(x0, square)
        x2 = compose(even, height)
        x3 = sfilter(x1, x2)
        x4 = difference(x1, x3)
        x5 = merge(x3)
        x6 = merge(x4)
        x7 = fill(I, TWO, x5)
        x8 = fill(x7, SEVEN, x6)
        return x8

    def verify_8731374e(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = argmax(x0, size)
        x2 = color(x1)
        x3 = subgrid(x1, I)
        x4 = lbind(insert, DOWN)
        x5 = compose(lrcorner, asindices)
        x6 = chain(x4, initset, x5)
        x7 = fork(subgrid, x6, identity)
        x8 = matcher(identity, x2)
        x9 = rbind(subtract, TWO)
        x10 = rbind(sfilter, x8)
        x11 = compose(x9, width)
        x12 = chain(size, x10, first)
        x13 = fork(greater, x11, x12)
        x14 = rbind(branch, identity)
        x15 = rbind(x14, x7)
        x16 = chain(initset, x15, x13)
        x17 = fork(rapply, x16, identity)
        x18 = compose(first, x17)
        x19 = compose(x18, rot90)
        x20 = double(EIGHT)
        x21 = double(x20)
        x22 = power(x19, x21)
        x23 = x22(x3)
        x24 = leastcolor(x23)
        x25 = ofcolor(x23, x24)
        x26 = fork(combine, vfrontier, hfrontier)
        x27 = mapply(x26, x25)
        x28 = fill(x23, x24, x27)
        return x28

    def verify_88a10436(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = argmax(x0, size)
        x2 = normalize(x1)
        x3 = shape(x1)
        x4 = halve(x3)
        x5 = invert(x4)
        x6 = shift(x2, x5)
        x7 = sizefilter(x0, ONE)
        x8 = apply(center, x7)
        x9 = lbind(shift, x6)
        x10 = mapply(x9, x8)
        x11 = paint(I, x10)
        return x11

    def verify_88a62173(I: Grid) -> Grid:
        x0 = lefthalf(I)
        x1 = righthalf(I)
        x2 = tophalf(x0)
        x3 = tophalf(x1)
        x4 = bottomhalf(x0)
        x5 = bottomhalf(x1)
        x6 = astuple(x2, x3)
        x7 = astuple(x4, x5)
        x8 = combine(x6, x7)
        x9 = leastcommon(x8)
        return x9

    def verify_890034e9(I: Grid) -> Grid:
        x0 = rbind(greater, TWO)
        x1 = chain(x0, minimum, shape)
        x2 = objects(I, T, F, F)
        x3 = sfilter(x2, x1)
        x4 = fork(equality, toindices, box)
        x5 = sfilter(x3, x4)
        x6 = totuple(x5)
        x7 = apply(color, x6)
        x8 = leastcommon(x7)
        x9 = ofcolor(I, x8)
        x10 = inbox(x9)
        x11 = recolor(ZERO, x10)
        x12 = occurrences(I, x11)
        x13 = normalize(x9)
        x14 = shift(x13, NEG_UNITY)
        x15 = lbind(shift, x14)
        x16 = mapply(x15, x12)
        x17 = fill(I, x8, x16)
        return x17

    def verify_8a004b2b(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(equality, toindices, corners)
        x2 = sfilter(x0, x1)
        x3 = argmax(x2, size)
        x4 = fgpartition(I)
        x5 = merge(x4)
        x6 = backdrop(x3)
        x7 = toobject(x6, I)
        x8 = difference(x5, x7)
        x9 = mostcolor(I)
        x10 = inbox(x3)
        x11 = backdrop(x10)
        x12 = toobject(x11, I)
        x13 = matcher(first, x9)
        x14 = compose(flip, x13)
        x15 = sfilter(x12, x14)
        x16 = subgrid(x8, I)
        x17 = palette(x15)
        x18 = order(x17, identity)
        x19 = lbind(colorcount, x15)
        x20 = apply(x19, x18)
        x21 = lbind(colorcount, x8)
        x22 = apply(x21, x18)
        x23 = pair(x20, x22)
        x24 = fork(divide, first, last)
        x25 = apply(x24, x23)
        x26 = mostcommon(x25)
        x27 = lbind(colorcount, x15)
        x28 = lbind(colorcount, x8)
        x29 = fork(divide, x27, x28)
        x30 = matcher(x29, x26)
        x31 = palette(x8)
        x32 = sfilter(x31, x30)
        x33 = rbind(contained, x32)
        x34 = compose(x33, first)
        x35 = sfilter(x15, x34)
        x36 = sfilter(x8, x34)
        x37 = height(x35)
        x38 = height(x36)
        x39 = divide(x37, x38)
        x40 = width(x35)
        x41 = width(x36)
        x42 = divide(x40, x41)
        x43 = vupscale(x16, x39)
        x44 = hupscale(x43, x42)
        x45 = asobject(x44)
        x46 = matcher(first, x9)
        x47 = compose(flip, x46)
        x48 = sfilter(x45, x47)
        x49 = ulcorner(x15)
        x50 = sfilter(x48, x34)
        x51 = ulcorner(x50)
        x52 = subtract(x49, x51)
        x53 = shift(x48, x52)
        x54 = paint(I, x53)
        x55 = subgrid(x3, x54)
        return x55

    def verify_8be77c9e(I: Grid) -> Grid:
        x0 = hmirror(I)
        x1 = vconcat(I, x0)
        return x1

    def verify_8d5021e8(I: Grid) -> Grid:
        x0 = vmirror(I)
        x1 = hconcat(x0, I)
        x2 = hmirror(x1)
        x3 = vconcat(x1, x2)
        x4 = vconcat(x3, x1)
        x5 = hmirror(x4)
        return x5

    def verify_8d510a79(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = totuple(x0)
        x2 = apply(color, x1)
        x3 = leastcommon(x2)
        x4 = frontiers(I)
        x5 = colorfilter(x4, x3)
        x6 = size(x5)
        x7 = positive(x6)
        x8 = branch(x7, dmirror, identity)
        x9 = ofcolor(I, x3)
        x10 = ofcolor(I, TWO)
        x11 = ofcolor(I, ONE)
        x12 = rbind(gravitate, x9)
        x13 = compose(x12, initset)
        x14 = fork(add, identity, x13)
        x15 = fork(connect, identity, x14)
        x16 = shape(I)
        x17 = maximum(x16)
        x18 = lbind(multiply, x17)
        x19 = lbind(gravitate, x9)
        x20 = chain(x18, sign, x19)
        x21 = compose(x20, initset)
        x22 = fork(add, identity, x21)
        x23 = fork(connect, identity, x22)
        x24 = mapply(x15, x10)
        x25 = mapply(x23, x11)
        x26 = fill(I, TWO, x24)
        x27 = fill(x26, ONE, x25)
        return x27

    def verify_8e1813be(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = matcher(height, ONE)
        x2 = matcher(width, ONE)
        x3 = fork(either, x1, x2)
        x4 = sfilter(x0, x3)
        x5 = matcher(height, ONE)
        x6 = sfilter(x4, x5)
        x7 = size(x6)
        x8 = matcher(width, ONE)
        x9 = sfilter(x4, x8)
        x10 = size(x9)
        x11 = greater(x7, x10)
        x12 = branch(x11, dmirror, identity)
        x13 = branch(x11, uppermost, leftmost)
        x14 = order(x4, x13)
        x15 = apply(color, x14)
        x16 = size(x4)
        x17 = repeat(x15, x16)
        x18 = x12(x17)
        return x18

    def verify_8e5a5113(I: Grid) -> Grid:
        x0 = portrait(I)
        x1 = branch(x0, identity, rot90)
        x2 = branch(x0, identity, rot270)
        x3 = x1(I)
        x4 = width(x3)
        x5 = toivec(x4)
        x6 = index(x3, x5)
        x7 = shape(x3)
        x8 = canvas(x6, x7)
        x9 = hconcat(x3, x8)
        x10 = objects(x9, F, T, T)
        x11 = argmax(x10, numcolors)
        x12 = subgrid(x11, x3)
        x13 = interval(ONE, FOUR, ONE)
        x14 = lbind(power, rot90)
        x15 = lbind(power, rot270)
        x16 = rbind(rapply, x12)
        x17 = compose(initset, x14)
        x18 = chain(first, x16, x17)
        x19 = rbind(rapply, x12)
        x20 = compose(initset, x15)
        x21 = chain(first, x19, x20)
        x22 = compose(asobject, x18)
        x23 = uppermost(x11)
        x24 = lbind(add, x23)
        x25 = height(x11)
        x26 = increment(x25)
        x27 = lbind(multiply, x26)
        x28 = chain(toivec, x24, x27)
        x29 = fork(shift, x22, x28)
        x30 = compose(asobject, x21)
        x31 = uppermost(x11)
        x32 = lbind(subtract, x31)
        x33 = height(x11)
        x34 = increment(x33)
        x35 = lbind(multiply, x34)
        x36 = chain(toivec, x32, x35)
        x37 = fork(shift, x30, x36)
        x38 = fork(combine, x29, x37)
        x39 = mapply(x38, x13)
        x40 = paint(x3, x39)
        x41 = x2(x40)
        return x41

    def verify_8eb1be9a(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = height(x1)
        x3 = height(I)
        x4 = interval(ZERO, x3, x2)
        x5 = lbind(shift, x1)
        x6 = compose(x5, toivec)
        x7 = compose(x6, invert)
        x8 = fork(combine, x6, x7)
        x9 = mapply(x8, x4)
        x10 = paint(I, x9)
        return x10

    def verify_8efcae92(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = fork(multiply, height, width)
        x2 = argmax(x0, x1)
        x3 = remove(x2, x0)
        x4 = lbind(chain, positive)
        x5 = lbind(x4, size)
        x6 = rbind(compose, backdrop)
        x7 = lbind(lbind, intersection)
        x8 = chain(x5, x6, x7)
        x9 = chain(x8, backdrop, outbox)
        x10 = lbind(sfilter, x3)
        x11 = compose(x10, x9)
        x12 = chain(positive, size, x11)
        x13 = sfilter(x3, x12)
        x14 = compose(merge, x11)
        x15 = apply(x14, x13)
        x16 = rbind(subgrid, I)
        x17 = apply(x16, x15)
        x18 = merge(x15)
        x19 = palette(x18)
        x20 = lbind(colorcount, x18)
        x21 = argmin(x19, x20)
        x22 = rbind(colorcount, x21)
        x23 = argmax(x17, x22)
        return x23

    def verify_8f2ea7aa(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = normalize(x1)
        x3 = mostcolor(I)
        x4 = shape(x2)
        x5 = multiply(x4, x4)
        x6 = canvas(x3, x5)
        x7 = shape(x2)
        x8 = rbind(multiply, x7)
        x9 = toindices(x2)
        x10 = apply(x8, x9)
        x11 = lbind(shift, x2)
        x12 = mapply(x11, x10)
        x13 = paint(x6, x12)
        return x13

    def verify_90c28cc7(I: Grid) -> Grid:
        x0 = matcher(identity, ZERO)
        x1 = compose(flip, x0)
        x2 = rbind(sfilter, x1)
        x3 = chain(positive, size, x2)
        x4 = rbind(sfilter, x3)
        x5 = compose(dmirror, x4)
        x6 = power(x5, FOUR)
        x7 = x6(I)
        x8 = dedupe(x7)
        x9 = dmirror(x8)
        x10 = dedupe(x9)
        x11 = dmirror(x10)
        return x11

    def verify_90f3ed37(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = apply(first, x1)
        x3 = asindices(I)
        x4 = apply(first, x3)
        x5 = difference(x4, x2)
        x6 = ofcolor(I, x0)
        x7 = rbind(interval, ONE)
        x8 = lbind(rbind, contained)
        x9 = lbind(sfilter, x5)
        x10 = rbind(matcher, ZERO)
        x11 = chain(size, x9, x8)
        x12 = lbind(sfilter, x6)
        x13 = lbind(compose, x11)
        x14 = chain(x12, x10, x13)
        x15 = lbind(fork, x7)
        x16 = compose(increment, minimum)
        x17 = lbind(lbind, astuple)
        x18 = lbind(chain, x16)
        x19 = rbind(x18, first)
        x20 = chain(x19, x17, first)
        x21 = lbind(chain, maximum)
        x22 = rbind(x21, first)
        x23 = chain(x22, x17, first)
        x24 = fork(x15, x20, x23)
        x25 = compose(x14, x24)
        x26 = apply(toivec, x2)
        x27 = apply(x25, x26)
        x28 = argmax(x27, width)
        x29 = remove(x28, x27)
        x30 = ulcorner(x28)
        x31 = invert(x30)
        x32 = shift(x28, x31)
        x33 = asindices(I)
        x34 = center(x33)
        x35 = invert(x34)
        x36 = shift(x33, x35)
        x37 = width(I)
        x38 = double(x37)
        x39 = tojvec(x38)
        x40 = rbind(apply, x36)
        x41 = lbind(rbind, add)
        x42 = chain(x40, x41, center)
        x43 = compose(positive, size)
        x44 = lbind(compose, size)
        x45 = lbind(shift, x32)
        x46 = rbind(compose, x45)
        x47 = lbind(rbind, intersection)
        x48 = compose(x46, x47)
        x49 = lbind(compose, x43)
        x50 = compose(x49, x48)
        x51 = fork(sfilter, x42, x50)
        x52 = compose(x44, x48)
        x53 = fork(valmax, x51, x52)
        x54 = compose(x44, x48)
        x55 = fork(matcher, x54, x53)
        x56 = fork(sfilter, x51, x55)
        x57 = lbind(shift, x32)
        x58 = lbind(insert, x39)
        x59 = lbind(rbind, greater)
        x60 = compose(x59, rightmost)
        x61 = compose(leftmost, x58)
        x62 = rbind(compose, x57)
        x63 = lbind(rbind, difference)
        x64 = compose(x62, x63)
        x65 = lbind(compose, x61)
        x66 = compose(x65, x64)
        x67 = fork(compose, x60, x66)
        x68 = fork(argmax, x56, x67)
        x69 = lbind(shift, x32)
        x70 = compose(x69, x68)
        x71 = fork(difference, x70, identity)
        x72 = mapply(x71, x29)
        x73 = fill(I, ONE, x72)
        return x73

    def verify_913fb3ed(I: Grid) -> Grid:
        x0 = lbind(ofcolor, I)
        x1 = lbind(mapply, neighbors)
        x2 = chain(x1, x0, last)
        x3 = fork(recolor, first, x2)
        x4 = astuple(SIX, THREE)
        x5 = astuple(FOUR, EIGHT)
        x6 = astuple(ONE, TWO)
        x7 = initset(x4)
        x8 = insert(x5, x7)
        x9 = insert(x6, x8)
        x10 = mapply(x3, x9)
        x11 = paint(I, x10)
        return x11

    def verify_91413438(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = other(x0, ZERO)
        x2 = colorcount(I, x1)
        x3 = colorcount(I, ZERO)
        x4 = dmirror(I)
        x5 = repeat(x4, x2)
        x6 = dmirror(I)
        x7 = shape(x6)
        x8 = canvas(ZERO, x7)
        x9 = multiply(x3, x3)
        x10 = subtract(x9, x2)
        x11 = repeat(x8, x10)
        x12 = combine(x5, x11)
        x13 = merge(x12)
        x14 = dmirror(x13)
        x15 = hsplit(x14, x3)
        x16 = merge(x15)
        return x16

    def verify_91714a58(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = asindices(I)
        x2 = objects(I, T, F, T)
        x3 = argmax(x2, size)
        x4 = mostcolor(x3)
        x5 = mostcolor(I)
        x6 = canvas(x5, x0)
        x7 = paint(x6, x3)
        x8 = mostcolor(I)
        x9 = color(x3)
        x10 = astuple(x8, ORIGIN)
        x11 = astuple(x9, RIGHT)
        x12 = astuple(x8, ZERO_BY_TWO)
        x13 = initset(x12)
        x14 = insert(x11, x13)
        x15 = insert(x10, x14)
        x16 = dmirror(x15)
        x17 = toindices(x15)
        x18 = lbind(shift, x17)
        x19 = occurrences(x7, x15)
        x20 = mapply(x18, x19)
        x21 = toindices(x16)
        x22 = lbind(shift, x21)
        x23 = occurrences(x7, x16)
        x24 = mapply(x22, x23)
        x25 = combine(x20, x24)
        x26 = fill(x7, x8, x25)
        return x26

    def verify_9172f3a0(I: Grid) -> Grid:
        x0 = upscale(I, THREE)
        return x0

    def verify_928ad970(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = leastcolor(I)
        x3 = palette(I)
        x4 = remove(x2, x3)
        x5 = mostcolor(I)
        x6 = other(x4, x5)
        x7 = inbox(x1)
        x8 = fill(I, x6, x7)
        return x8

    def verify_93b581b8(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = apply(toindices, x0)
        x2 = lbind(index, I)
        x3 = compose(x2, lrcorner)
        x4 = astuple(NEG_TWO, NEG_TWO)
        x5 = rbind(shift, x4)
        x6 = fork(recolor, x3, x5)
        x7 = compose(x2, ulcorner)
        x8 = rbind(shift, TWO_BY_TWO)
        x9 = fork(recolor, x7, x8)
        x10 = compose(x2, llcorner)
        x11 = astuple(NEG_TWO, TWO)
        x12 = rbind(shift, x11)
        x13 = fork(recolor, x10, x12)
        x14 = compose(x2, urcorner)
        x15 = astuple(TWO, NEG_TWO)
        x16 = rbind(shift, x15)
        x17 = fork(recolor, x14, x16)
        x18 = fork(combine, x6, x9)
        x19 = fork(combine, x13, x17)
        x20 = fork(combine, x18, x19)
        x21 = mapply(x20, x1)
        x22 = paint(I, x21)
        return x22

    def verify_941d9a10(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = corners(x0)
        x2 = toobject(x1, I)
        x3 = mostcolor(x2)
        x4 = objects(I, T, T, F)
        x5 = colorfilter(x4, x3)
        x6 = fork(add, leftmost, uppermost)
        x7 = argmin(x5, x6)
        x8 = argmax(x5, x6)
        x9 = lbind(sfilter, x5)
        x10 = rbind(compose, leftmost)
        x11 = chain(size, x9, x10)
        x12 = lbind(sfilter, x5)
        x13 = rbind(compose, uppermost)
        x14 = chain(size, x12, x13)
        x15 = lbind(lbind, greater)
        x16 = chain(x11, x15, leftmost)
        x17 = lbind(rbind, greater)
        x18 = chain(x11, x17, leftmost)
        x19 = lbind(lbind, greater)
        x20 = chain(x14, x19, uppermost)
        x21 = lbind(rbind, greater)
        x22 = chain(x14, x21, uppermost)
        x23 = fork(equality, x16, x18)
        x24 = fork(equality, x20, x22)
        x25 = fork(both, x23, x24)
        x26 = extract(x5, x25)
        x27 = fill(I, ONE, x7)
        x28 = fill(x27, THREE, x8)
        x29 = fill(x28, TWO, x26)
        return x29

    def verify_94f9d214(I: Grid) -> Grid:
        x0 = astuple(vsplit, hsplit)
        x1 = rbind(rbind, TWO)
        x2 = rbind(rapply, I)
        x3 = initset(x1)
        x4 = lbind(rapply, x3)
        x5 = chain(first, x2, x4)
        x6 = lbind(apply, numcolors)
        x7 = compose(x6, x5)
        x8 = matcher(x7, TWO_BY_TWO)
        x9 = extract(x0, x8)
        x10 = x9(I, TWO)
        x11 = first(x10)
        x12 = last(x10)
        x13 = palette(x11)
        x14 = palette(x12)
        x15 = intersection(x13, x14)
        x16 = first(x15)
        x17 = shape(x11)
        x18 = canvas(x16, x17)
        x19 = ofcolor(x11, x16)
        x20 = ofcolor(x12, x16)
        x21 = intersection(x19, x20)
        x22 = fill(x18, TWO, x21)
        return x22

    def verify_952a094c(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = inbox(x1)
        x3 = cover(I, x2)
        x4 = ulcorner(x2)
        x5 = index(I, x4)
        x6 = lrcorner(x1)
        x7 = add(UNITY, x6)
        x8 = initset(x7)
        x9 = fill(x3, x5, x8)
        x10 = lrcorner(x2)
        x11 = index(I, x10)
        x12 = ulcorner(x1)
        x13 = add(NEG_UNITY, x12)
        x14 = initset(x13)
        x15 = fill(x9, x11, x14)
        x16 = urcorner(x2)
        x17 = index(I, x16)
        x18 = llcorner(x1)
        x19 = add(DOWN_LEFT, x18)
        x20 = initset(x19)
        x21 = fill(x15, x17, x20)
        x22 = llcorner(x2)
        x23 = index(I, x22)
        x24 = urcorner(x1)
        x25 = add(UP_RIGHT, x24)
        x26 = initset(x25)
        x27 = fill(x21, x23, x26)
        return x27

    def verify_9565186b(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = partition(I)
        x2 = argmax(x1, size)
        x3 = canvas(FIVE, x0)
        x4 = paint(x3, x2)
        return x4

    def verify_95990924(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = apply(ulcorner, x0)
        x2 = apply(urcorner, x0)
        x3 = apply(llcorner, x0)
        x4 = apply(lrcorner, x0)
        x5 = shift(x1, NEG_UNITY)
        x6 = shift(x2, UP_RIGHT)
        x7 = shift(x3, DOWN_LEFT)
        x8 = shift(x4, UNITY)
        x9 = fill(I, ONE, x5)
        x10 = fill(x9, TWO, x6)
        x11 = fill(x10, THREE, x7)
        x12 = fill(x11, FOUR, x8)
        return x12

    def verify_963e52fc(I: Grid) -> Grid:
        x0 = width(I)
        x1 = asobject(I)
        x2 = hperiod(x1)
        x3 = height(x1)
        x4 = astuple(x3, x2)
        x5 = ulcorner(x1)
        x6 = crop(I, x5, x4)
        x7 = rot90(x6)
        x8 = double(x0)
        x9 = divide(x8, x2)
        x10 = increment(x9)
        x11 = repeat(x7, x10)
        x12 = merge(x11)
        x13 = rot270(x12)
        x14 = astuple(x3, x8)
        x15 = crop(x13, ORIGIN, x14)
        return x15

    def verify_97999447(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = asobject(I)
        x2 = matcher(first, x0)
        x3 = compose(flip, x2)
        x4 = sfilter(x1, x3)
        x5 = apply(initset, x4)
        x6 = apply(toindices, x5)
        x7 = rbind(shoot, RIGHT)
        x8 = compose(x7, center)
        x9 = fork(recolor, color, x8)
        x10 = mapply(x9, x5)
        x11 = paint(I, x10)
        x12 = width(I)
        x13 = interval(ZERO, x12, ONE)
        x14 = apply(double, x13)
        x15 = apply(increment, x14)
        x16 = apply(tojvec, x15)
        x17 = prapply(shift, x6, x16)
        x18 = merge(x17)
        x19 = fill(x11, FIVE, x18)
        return x19

    def verify_97a05b5b(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = fork(multiply, height, width)
        x2 = fork(equality, size, x1)
        x3 = matcher(numcolors, TWO)
        x4 = fork(both, x2, x3)
        x5 = sfilter(x0, x4)
        x6 = difference(x0, x5)
        x7 = merge(x6)
        x8 = color(x7)
        x9 = mostcolor(I)
        x10 = subgrid(x7, I)
        x11 = astuple(hmirror, vmirror)
        x12 = astuple(cmirror, dmirror)
        x13 = combine(x11, x12)
        x14 = astuple(identity, rot180)
        x15 = astuple(rot90, rot270)
        x16 = combine(x14, x15)
        x17 = combine(x16, x13)
        x18 = lbind(canvas, NEG_ONE)
        x19 = compose(x18, shape)
        x20 = fork(paint, x19, normalize)
        x21 = rbind(other, x8)
        x22 = compose(x21, palette)
        x23 = lbind(occurrences, x10)
        x24 = chain(positive, size, x23)
        x25 = compose(x24, asobject)
        x26 = rbind(replace, x8)
        x27 = rbind(replace, x9)
        x28 = rbind(x27, x8)
        x29 = compose(x28, x20)
        x30 = fork(x26, x29, x22)
        x31 = rbind(chain, initset)
        x32 = compose(x25, first)
        x33 = lbind(x31, x32)
        x34 = lbind(rbind, rapply)
        x35 = chain(x33, x34, x30)
        x36 = lbind(occurrences, x10)
        x37 = chain(first, x36, asobject)
        x38 = lbind(argmax, x17)
        x39 = compose(x38, x35)
        x40 = compose(initset, x39)
        x41 = fork(rapply, x40, x20)
        x42 = compose(first, x41)
        x43 = compose(initset, x39)
        x44 = fork(rapply, x43, x30)
        x45 = compose(first, x44)
        x46 = compose(asobject, x42)
        x47 = compose(x37, x45)
        x48 = fork(shift, x46, x47)
        x49 = mapply(x48, x5)
        x50 = paint(x10, x49)
        return x50

    def verify_98cf29f8(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = toobject(x1, I)
        x3 = mostcolor(x2)
        x4 = shape(I)
        x5 = add(TWO, x4)
        x6 = canvas(x3, x5)
        x7 = asobject(I)
        x8 = shift(x7, UNITY)
        x9 = paint(x6, x8)
        x10 = palette(x9)
        x11 = remove(x3, x10)
        x12 = lbind(ofcolor, x9)
        x13 = fork(recolor, identity, x12)
        x14 = apply(x13, x11)
        x15 = fork(equality, toindices, backdrop)
        x16 = extract(x14, x15)
        x17 = other(x14, x16)
        x18 = color(x17)
        x19 = astuple(x18, RIGHT)
        x20 = initset(ZERO_BY_TWO)
        x21 = insert(ORIGIN, x20)
        x22 = recolor(x3, x21)
        x23 = insert(x19, x22)
        x24 = dmirror(x23)
        x25 = lbind(shift, x23)
        x26 = occurrences(x9, x23)
        x27 = mapply(x25, x26)
        x28 = lbind(shift, x24)
        x29 = occurrences(x9, x24)
        x30 = mapply(x28, x29)
        x31 = combine(x27, x30)
        x32 = fill(x9, x3, x31)
        x33 = ofcolor(x32, x18)
        x34 = gravitate(x33, x16)
        x35 = replace(x9, x18, x3)
        x36 = shift(x33, x34)
        x37 = fill(x35, x18, x36)
        x38 = trim(x37)
        return x38

    def verify_995c5fa3(I: Grid) -> Grid:
        x0 = width(I)
        x1 = increment(x0)
        x2 = divide(x1, FIVE)
        x3 = astuple(FOUR, FOUR)
        x4 = canvas(NEG_ONE, x3)
        x5 = asindices(x4)
        x6 = rbind(toobject, I)
        x7 = lbind(shift, x5)
        x8 = compose(x6, x7)
        x9 = multiply(x2, FIVE)
        x10 = interval(ZERO, x9, FIVE)
        x11 = apply(tojvec, x10)
        x12 = apply(x8, x11)
        x13 = matcher(numcolors, ONE)
        x14 = fork(equality, identity, hmirror)
        x15 = compose(flip, x14)
        x16 = lbind(index, I)
        x17 = compose(x16, ulcorner)
        x18 = lbind(add, DOWN)
        x19 = chain(x16, x18, ulcorner)
        x20 = fork(equality, x17, x19)
        x21 = compose(flip, x20)
        x22 = fork(either, x13, x15)
        x23 = fork(either, x22, x21)
        x24 = compose(flip, x23)
        x25 = lbind(multiply, TWO)
        x26 = compose(x25, x13)
        x27 = lbind(multiply, FOUR)
        x28 = compose(x27, x15)
        x29 = fork(add, x26, x28)
        x30 = lbind(multiply, THREE)
        x31 = compose(x30, x21)
        x32 = lbind(multiply, EIGHT)
        x33 = compose(x32, x24)
        x34 = fork(add, x31, x33)
        x35 = fork(add, x29, x34)
        x36 = apply(x35, x12)
        x37 = rbind(repeat, x2)
        x38 = apply(x37, x36)
        return x38

    def verify_99b1bc43(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = sfilter(x0, vline)
        x2 = size(x1)
        x3 = positive(x2)
        x4 = branch(x3, hsplit, vsplit)
        x5 = x4(I, TWO)
        x6 = first(x5)
        x7 = last(x5)
        x8 = palette(x6)
        x9 = palette(x7)
        x10 = intersection(x8, x9)
        x11 = first(x10)
        x12 = shape(x6)
        x13 = canvas(x11, x12)
        x14 = ofcolor(x6, x11)
        x15 = ofcolor(x7, x11)
        x16 = combine(x14, x15)
        x17 = intersection(x14, x15)
        x18 = difference(x16, x17)
        x19 = fill(x13, THREE, x18)
        return x19

    def verify_99fa7670(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = objects(I, T, F, T)
        x2 = rbind(shoot, RIGHT)
        x3 = compose(x2, center)
        x4 = fork(recolor, color, x3)
        x5 = mapply(x4, x1)
        x6 = paint(I, x5)
        x7 = add(x0, DOWN_LEFT)
        x8 = initset(x7)
        x9 = mostcolor(I)
        x10 = recolor(x9, x8)
        x11 = objects(x6, T, F, T)
        x12 = insert(x10, x11)
        x13 = order(x12, uppermost)
        x14 = first(x13)
        x15 = remove(x10, x13)
        x16 = remove(x14, x13)
        x17 = compose(lrcorner, first)
        x18 = compose(lrcorner, last)
        x19 = fork(connect, x17, x18)
        x20 = compose(color, first)
        x21 = fork(recolor, x20, x19)
        x22 = pair(x15, x16)
        x23 = mapply(x21, x22)
        x24 = underpaint(x6, x23)
        return x24

    def verify_9aec4887(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = fork(multiply, height, width)
        x2 = fork(equality, size, x1)
        x3 = sfilter(x0, x2)
        x4 = mostcolor(I)
        x5 = colorfilter(x3, x4)
        x6 = argmax(x5, size)
        x7 = outbox(x6)
        x8 = backdrop(x7)
        x9 = subgrid(x8, I)
        x10 = cover(I, x8)
        x11 = fgpartition(x10)
        x12 = merge(x11)
        x13 = normalize(x12)
        x14 = shift(x13, UNITY)
        x15 = paint(x9, x14)
        x16 = toindices(x14)
        x17 = fgpartition(x9)
        x18 = rbind(remove, x17)
        x19 = lbind(lbind, manhattan)
        x20 = compose(x19, initset)
        x21 = lbind(fork, greater)
        x22 = lbind(sfilter, x16)
        x23 = rbind(compose, x20)
        x24 = lbind(lbind, valmin)
        x25 = chain(x23, x24, x18)
        x26 = rbind(compose, initset)
        x27 = lbind(rbind, manhattan)
        x28 = compose(x26, x27)
        x29 = fork(x21, x25, x28)
        x30 = compose(x22, x29)
        x31 = fork(recolor, color, x30)
        x32 = mapply(x31, x17)
        x33 = paint(x15, x32)
        return x33

    def verify_9af7a82c(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = order(x0, size)
        x2 = valmax(x0, size)
        x3 = rbind(astuple, ONE)
        x4 = lbind(subtract, x2)
        x5 = compose(x3, size)
        x6 = chain(x3, x4, size)
        x7 = fork(canvas, color, x5)
        x8 = lbind(canvas, ZERO)
        x9 = compose(x8, x6)
        x10 = fork(vconcat, x7, x9)
        x11 = compose(cmirror, x10)
        x12 = apply(x11, x1)
        x13 = merge(x12)
        x14 = cmirror(x13)
        return x14

    def verify_9d9215db(I: Grid) -> Grid:
        x0 = hmirror(I)
        x1 = fgpartition(x0)
        x2 = merge(x1)
        x3 = vmirror(I)
        x4 = fgpartition(x3)
        x5 = merge(x4)
        x6 = hmirror(I)
        x7 = vmirror(x6)
        x8 = fgpartition(x7)
        x9 = merge(x8)
        x10 = mostcolor(I)
        x11 = combine(x2, x5)
        x12 = combine(x11, x9)
        x13 = paint(I, x12)
        x14 = compose(increment, first)
        x15 = fork(greater, last, x14)
        x16 = tojvec(NEG_TWO)
        x17 = rbind(shift, x16)
        x18 = compose(x17, vmirror)
        x19 = rbind(sfilter, x15)
        x20 = compose(x19, asindices)
        x21 = compose(x18, x20)
        x22 = fork(intersection, x20, x21)
        x23 = rbind(shoot, RIGHT)
        x24 = compose(x23, last)
        x25 = matcher(first, x10)
        x26 = compose(flip, x25)
        x27 = rbind(sfilter, x26)
        x28 = compose(double, halve)
        x29 = fork(equality, x28, identity)
        x30 = chain(flip, x29, last)
        x31 = lbind(fork, both)
        x32 = rbind(x31, x30)
        x33 = lbind(fork, recolor)
        x34 = lbind(x33, first)
        x35 = rbind(compose, x24)
        x36 = lbind(rbind, contained)
        x37 = lbind(rbind, sfilter)
        x38 = chain(x34, x35, x37)
        x39 = chain(x38, x32, x36)
        x40 = fork(toobject, x22, identity)
        x41 = compose(x27, x40)
        x42 = compose(x39, x22)
        x43 = fork(mapply, x42, x41)
        x44 = fork(paint, identity, x43)
        x45 = compose(rot90, x44)
        x46 = power(x45, FOUR)
        x47 = x46(x13)
        return x47

    def verify_9dfd6313(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = decrement(x0)
        x2 = connect(ORIGIN, x1)
        x3 = height(I)
        x4 = decrement(x3)
        x5 = toivec(x4)
        x6 = width(I)
        x7 = decrement(x6)
        x8 = tojvec(x7)
        x9 = connect(x5, x8)
        x10 = height(I)
        x11 = halve(x10)
        x12 = toivec(x11)
        x13 = width(I)
        x14 = decrement(x13)
        x15 = astuple(x11, x14)
        x16 = connect(x12, x15)
        x17 = width(I)
        x18 = halve(x17)
        x19 = tojvec(x18)
        x20 = height(I)
        x21 = decrement(x20)
        x22 = astuple(x21, x18)
        x23 = connect(x19, x22)
        x24 = astuple(x2, dmirror)
        x25 = astuple(x9, cmirror)
        x26 = astuple(x24, x25)
        x27 = astuple(x23, vmirror)
        x28 = astuple(x16, hmirror)
        x29 = astuple(x27, x28)
        x30 = combine(x26, x29)
        x31 = lbind(colorcount, I)
        x32 = rbind(toobject, I)
        x33 = compose(x32, first)
        x34 = chain(x31, color, x33)
        x35 = compose(size, first)
        x36 = fork(equality, x34, x35)
        x37 = rbind(toobject, I)
        x38 = chain(numcolors, x37, first)
        x39 = matcher(x38, ONE)
        x40 = fork(both, x39, x36)
        x41 = extract(x30, x40)
        x42 = last(x41)
        x43 = x42(I)
        return x43

    def verify_9ecd008a(I: Grid) -> Grid:
        x0 = ofcolor(I, ZERO)
        x1 = rbind(colorcount, ZERO)
        x2 = lbind(toobject, x0)
        x3 = compose(x1, x2)
        x4 = vmirror(I)
        x5 = hmirror(I)
        x6 = astuple(x4, x5)
        x7 = argmin(x6, x3)
        x8 = subgrid(x0, x7)
        return x8

    def verify_9edfc990(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = colorfilter(x0, ZERO)
        x2 = ofcolor(I, ONE)
        x3 = rbind(adjacent, x2)
        x4 = mfilter(x1, x3)
        x5 = recolor(ONE, x4)
        x6 = paint(I, x5)
        return x6

    def verify_9f236235(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = color(x1)
        x3 = shape(I)
        x4 = canvas(x2, x3)
        x5 = hconcat(I, x4)
        x6 = objects(x5, T, F, T)
        x7 = apply(uppermost, x6)
        x8 = order(x7, identity)
        x9 = lbind(sfilter, x6)
        x10 = lbind(matcher, uppermost)
        x11 = compose(x9, x10)
        x12 = lbind(apply, color)
        x13 = rbind(order, leftmost)
        x14 = chain(x12, x13, x11)
        x15 = apply(x14, x8)
        x16 = vmirror(x15)
        return x16

    def verify_a1570a43(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = fork(equality, toindices, corners)
        x3 = fork(multiply, height, width)
        x4 = sfilter(x0, x2)
        x5 = argmax(x4, x3)
        x6 = difference(x1, x5)
        x7 = mostcolor(I)
        x8 = fill(I, x7, x6)
        x9 = normalize(x6)
        x10 = ulcorner(x5)
        x11 = increment(x10)
        x12 = shift(x9, x11)
        x13 = paint(x8, x12)
        return x13

    def verify_a2fd1cf0(I: Grid) -> Grid:
        x0 = ofcolor(I, TWO)
        x1 = ofcolor(I, THREE)
        x2 = uppermost(x0)
        x3 = leftmost(x0)
        x4 = uppermost(x1)
        x5 = leftmost(x1)
        x6 = astuple(x2, x4)
        x7 = minimum(x6)
        x8 = maximum(x6)
        x9 = astuple(x7, x5)
        x10 = astuple(x8, x5)
        x11 = connect(x9, x10)
        x12 = astuple(x3, x5)
        x13 = minimum(x12)
        x14 = maximum(x12)
        x15 = astuple(x2, x13)
        x16 = astuple(x2, x14)
        x17 = connect(x15, x16)
        x18 = combine(x11, x17)
        x19 = underfill(I, EIGHT, x18)
        return x19

    def verify_a3325580(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = valmax(x0, size)
        x2 = sizefilter(x0, x1)
        x3 = order(x2, leftmost)
        x4 = apply(color, x3)
        x5 = astuple(ONE, x1)
        x6 = rbind(canvas, x5)
        x7 = apply(x6, x4)
        x8 = merge(x7)
        x9 = dmirror(x8)
        return x9

    def verify_a3df8b1e(I: Grid) -> Grid:
        x0 = portrait(I)
        x1 = branch(x0, identity, dmirror)
        x2 = x1(I)
        x3 = asindices(x2)
        x4 = shoot(ORIGIN, UNITY)
        x5 = intersection(x4, x3)
        x6 = lrcorner(x5)
        x7 = shoot(x6, DOWN_LEFT)
        x8 = intersection(x7, x3)
        x9 = combine(x5, x8)
        x10 = llcorner(x9)
        x11 = remove(x10, x9)
        x12 = lbind(shift, x11)
        x13 = height(x11)
        x14 = lbind(multiply, x13)
        x15 = chain(x12, toivec, x14)
        x16 = height(x2)
        x17 = height(x11)
        x18 = divide(x16, x17)
        x19 = increment(x18)
        x20 = interval(ZERO, x19, ONE)
        x21 = mapply(x15, x20)
        x22 = rbind(contained, x21)
        x23 = sfilter(x3, x22)
        x24 = asindices(I)
        x25 = corners(x24)
        x26 = difference(x24, x25)
        x27 = toobject(x26, I)
        x28 = mostcolor(x27)
        x29 = palette(I)
        x30 = other(x29, x28)
        x31 = ulcorner(x3)
        x32 = index(x2, x31)
        x33 = equality(x32, x30)
        x34 = urcorner(x3)
        x35 = index(x2, x34)
        x36 = equality(x35, x30)
        x37 = llcorner(x3)
        x38 = index(x2, x37)
        x39 = equality(x38, x30)
        x40 = lrcorner(x3)
        x41 = index(x2, x40)
        x42 = equality(x41, x30)
        x43 = astuple(x33, x36)
        x44 = astuple(x39, x42)
        x45 = combine(x43, x44)
        x46 = vmirror(x23)
        x47 = astuple(x23, x46)
        x48 = hmirror(x23)
        x49 = hmirror(x46)
        x50 = astuple(x48, x49)
        x51 = combine(x47, x50)
        x52 = pair(x45, x51)
        x53 = sfilter(x52, first)
        x54 = mapply(last, x53)
        x55 = fill(x2, x30, x54)
        x56 = x1(x55)
        return x56

    def verify_a416b8f3(I: Grid) -> Grid:
        x0 = hconcat(I, I)
        return x0

    def verify_a48eeaf7(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = fork(equality, toindices, backdrop)
        x2 = sfilter(x0, x1)
        x3 = argmax(x2, size)
        x4 = other(x0, x3)
        x5 = color(x4)
        x6 = toindices(x4)
        x7 = outbox(x3)
        x8 = lbind(argmin, x7)
        x9 = lbind(lbind, manhattan)
        x10 = rbind(compose, initset)
        x11 = chain(x8, x10, x9)
        x12 = compose(x11, initset)
        x13 = apply(x12, x6)
        x14 = cover(I, x4)
        x15 = fill(x14, x5, x13)
        return x15

    def verify_a5313dff(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = rbind(bordering, I)
        x2 = compose(flip, x1)
        x3 = sfilter(x0, x2)
        x4 = totuple(x3)
        x5 = apply(color, x4)
        x6 = mostcommon(x5)
        x7 = mostcolor(I)
        x8 = colorfilter(x0, x7)
        x9 = rbind(bordering, I)
        x10 = compose(flip, x9)
        x11 = mfilter(x8, x10)
        x12 = fill(I, ONE, x11)
        return x12

    def verify_a5f85a15(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = compose(increment, double)
        x3 = shoot(ORIGIN, UNITY)
        x4 = apply(x2, x3)
        x5 = order(x4, identity)
        x6 = lbind(contained, ZERO)
        x7 = sfilter(x1, x6)
        x8 = lbind(shift, x5)
        x9 = mapply(x8, x7)
        x10 = fill(I, FOUR, x9)
        return x10

    def verify_a61ba2ce(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = fork(contained, lrcorner, toindices)
        x2 = compose(flip, x1)
        x3 = extract(x0, x2)
        x4 = fork(contained, llcorner, toindices)
        x5 = compose(flip, x4)
        x6 = extract(x0, x5)
        x7 = fork(contained, urcorner, toindices)
        x8 = compose(flip, x7)
        x9 = extract(x0, x8)
        x10 = fork(contained, ulcorner, toindices)
        x11 = compose(flip, x10)
        x12 = extract(x0, x11)
        x13 = height(x3)
        x14 = height(x9)
        x15 = add(x13, x14)
        x16 = width(x3)
        x17 = width(x6)
        x18 = add(x16, x17)
        x19 = astuple(x15, x18)
        x20 = mostcolor(I)
        x21 = canvas(x20, x19)
        x22 = normalize(x3)
        x23 = paint(x21, x22)
        x24 = normalize(x6)
        x25 = width(x6)
        x26 = subtract(x18, x25)
        x27 = tojvec(x26)
        x28 = shift(x24, x27)
        x29 = paint(x23, x28)
        x30 = normalize(x9)
        x31 = height(x9)
        x32 = subtract(x15, x31)
        x33 = toivec(x32)
        x34 = shift(x30, x33)
        x35 = paint(x29, x34)
        x36 = normalize(x12)
        x37 = shape(x12)
        x38 = subtract(x19, x37)
        x39 = shift(x36, x38)
        x40 = paint(x35, x39)
        return x40

    def verify_a61f2674(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = argmax(x0, size)
        x2 = argmin(x0, size)
        x3 = merge(x0)
        x4 = cover(I, x3)
        x5 = fill(x4, ONE, x1)
        x6 = fill(x5, TWO, x2)
        return x6

    def verify_a64e4611(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = shape(I)
        x2 = add(TWO, x1)
        x3 = canvas(x0, x2)
        x4 = asobject(I)
        x5 = shift(x4, UNITY)
        x6 = paint(x3, x5)
        x7 = double(SIX)
        x8 = astuple(ONE, x7)
        x9 = connect(UNITY, x8)
        x10 = outbox(x9)
        x11 = backdrop(x10)
        x12 = recolor(x0, x11)
        x13 = recolor(THREE, x9)
        x14 = lbind(shift, x13)
        x15 = lbind(mapply, x14)
        x16 = rbind(occurrences, x12)
        x17 = compose(x15, x16)
        x18 = fork(paint, identity, x17)
        x19 = x18(x6)
        x20 = ofcolor(x19, THREE)
        x21 = dmirror(x6)
        x22 = x18(x21)
        x23 = dmirror(x22)
        x24 = ofcolor(x23, THREE)
        x25 = combine(x20, x24)
        x26 = fill(x6, THREE, x25)
        x27 = astuple(TWO, ONE)
        x28 = dneighbors(UNITY)
        x29 = remove(x27, x28)
        x30 = recolor(x0, x29)
        x31 = initset(UNITY)
        x32 = recolor(THREE, x31)
        x33 = combine(x30, x32)
        x34 = recolor(x0, x33)
        x35 = astuple(ONE, THREE)
        x36 = initset(x35)
        x37 = insert(ZERO_BY_TWO, x36)
        x38 = insert(RIGHT, x37)
        x39 = insert(DOWN, x38)
        x40 = recolor(x0, x39)
        x41 = astuple(ONE, TWO)
        x42 = initset(x41)
        x43 = insert(UNITY, x42)
        x44 = recolor(THREE, x43)
        x45 = combine(x40, x44)
        x46 = recolor(x0, x45)
        x47 = lbind(shift, x34)
        x48 = lbind(mapply, x47)
        x49 = rbind(occurrences, x33)
        x50 = compose(x48, x49)
        x51 = fork(paint, identity, x50)
        x52 = lbind(shift, x46)
        x53 = lbind(mapply, x52)
        x54 = rbind(occurrences, x45)
        x55 = compose(x53, x54)
        x56 = fork(paint, identity, x55)
        x57 = compose(x51, x56)
        x58 = compose(rot90, x57)
        x59 = power(x58, FOUR)
        x60 = power(x59, TWO)
        x61 = asindices(x26)
        x62 = box(x61)
        x63 = fill(x26, THREE, x62)
        x64 = x60(x63)
        x65 = trim(x64)
        return x65

    def verify_a65b410d(I: Grid) -> Grid:
        x0 = astuple(identity, rot90)
        x1 = astuple(rot180, rot270)
        x2 = combine(x0, x1)
        x3 = astuple(identity, rot270)
        x4 = astuple(rot180, rot90)
        x5 = combine(x3, x4)
        x6 = pair(x2, x5)
        x7 = leastcolor(I)
        x8 = rbind(ofcolor, x7)
        x9 = rbind(rapply, I)
        x10 = chain(first, x9, initset)
        x11 = chain(hline, x8, x10)
        x12 = rbind(ofcolor, x7)
        x13 = rbind(rapply, I)
        x14 = chain(first, x13, initset)
        x15 = chain(leftmost, x12, x14)
        x16 = matcher(x15, ZERO)
        x17 = fork(both, x11, x16)
        x18 = compose(x17, first)
        x19 = extract(x6, x18)
        x20 = first(x19)
        x21 = last(x19)
        x22 = x20(I)
        x23 = ofcolor(x22, x7)
        x24 = argmax(x23, last)
        x25 = add(x24, UP_RIGHT)
        x26 = shoot(x25, UP_RIGHT)
        x27 = add(x24, DOWN_LEFT)
        x28 = shoot(x27, DOWN_LEFT)
        x29 = rbind(shoot, LEFT)
        x30 = mapply(x29, x26)
        x31 = rbind(shoot, LEFT)
        x32 = mapply(x31, x28)
        x33 = width(x22)
        x34 = invert(x33)
        x35 = tojvec(x34)
        x36 = shift(x30, x35)
        x37 = combine(x30, x36)
        x38 = fill(x22, THREE, x37)
        x39 = shift(x32, x35)
        x40 = combine(x32, x39)
        x41 = fill(x38, ONE, x40)
        x42 = x21(x41)
        return x42

    def verify_a68b268e(I: Grid) -> Grid:
        x0 = tophalf(I)
        x1 = lefthalf(x0)
        x2 = tophalf(I)
        x3 = righthalf(x2)
        x4 = bottomhalf(I)
        x5 = lefthalf(x4)
        x6 = bottomhalf(I)
        x7 = righthalf(x6)
        x8 = palette(x1)
        x9 = palette(x3)
        x10 = intersection(x8, x9)
        x11 = palette(x5)
        x12 = palette(x7)
        x13 = intersection(x11, x12)
        x14 = intersection(x10, x13)
        x15 = first(x14)
        x16 = shape(I)
        x17 = halve(x16)
        x18 = canvas(x15, x17)
        x19 = matcher(first, x15)
        x20 = compose(flip, x19)
        x21 = rbind(sfilter, x20)
        x22 = compose(x21, asobject)
        x23 = x22(x1)
        x24 = x22(x3)
        x25 = x22(x5)
        x26 = x22(x7)
        x27 = paint(x18, x26)
        x28 = paint(x27, x25)
        x29 = paint(x28, x24)
        x30 = paint(x29, x23)
        return x30

    def verify_a699fb00(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = height(I)
        x2 = vsplit(I, x1)
        x3 = lbind(recolor, TWO)
        x4 = rbind(ofcolor, x0)
        x5 = chain(x3, delta, x4)
        x6 = fork(paint, identity, x5)
        x7 = apply(x6, x2)
        x8 = merge(x7)
        return x8

    def verify_a740d043(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = subgrid(x1, I)
        x3 = mostcolor(I)
        x4 = replace(x2, x3, ZERO)
        return x4

    def verify_a78176bb(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = objects(I, T, T, F)
        x2 = fork(connect, ulcorner, lrcorner)
        x3 = fork(equality, toindices, x2)
        x4 = sfilter(x1, x3)
        x5 = size(x4)
        x6 = positive(x5)
        x7 = branch(x6, identity, hmirror)
        x8 = x7(I)
        x9 = objects(x8, T, F, T)
        x10 = compose(flip, x3)
        x11 = sfilter(x9, x10)
        x12 = rbind(shoot, UNITY)
        x13 = rbind(shoot, NEG_UNITY)
        x14 = fork(combine, x12, x13)
        x15 = rbind(branch, llcorner)
        x16 = rbind(x15, urcorner)
        x17 = rbind(branch, DOWN_LEFT)
        x18 = rbind(x17, UP_RIGHT)
        x19 = rbind(branch, RIGHT)
        x20 = rbind(x19, DOWN)
        x21 = fork(contained, urcorner, toindices)
        x22 = lbind(index, x8)
        x23 = compose(x20, x21)
        x24 = fork(add, ulcorner, x23)
        x25 = compose(x22, x24)
        x26 = chain(initset, x16, x21)
        x27 = fork(rapply, x26, identity)
        x28 = compose(first, x27)
        x29 = compose(x18, x21)
        x30 = fork(add, x28, x29)
        x31 = compose(x14, x30)
        x32 = fork(recolor, x25, x31)
        x33 = mapply(x32, x11)
        x34 = merge(x11)
        x35 = cover(x8, x34)
        x36 = paint(x35, x33)
        x37 = x7(x36)
        return x37

    def verify_a79310a0(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = mostcolor(I)
        x3 = fill(I, x2, x1)
        x4 = shift(x1, DOWN)
        x5 = fill(x3, TWO, x4)
        return x5

    def verify_a85d4709(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = height(I)
        x2 = vsplit(I, x1)
        x3 = rbind(ofcolor, x0)
        x4 = compose(leftmost, x3)
        x5 = width(I)
        x6 = divide(x5, THREE)
        x7 = multiply(x6, TWO)
        x8 = lbind(greater, x6)
        x9 = compose(x8, x4)
        x10 = lbind(greater, x7)
        x11 = compose(x10, x4)
        x12 = compose(flip, x9)
        x13 = fork(both, x11, x12)
        x14 = fork(either, x9, x13)
        x15 = compose(flip, x14)
        x16 = rbind(multiply, TWO)
        x17 = compose(x16, x9)
        x18 = rbind(multiply, FOUR)
        x19 = compose(x18, x13)
        x20 = rbind(multiply, THREE)
        x21 = compose(x20, x15)
        x22 = fork(add, x17, x19)
        x23 = fork(add, x22, x21)
        x24 = width(I)
        x25 = rbind(repeat, x24)
        x26 = compose(x25, x23)
        x27 = apply(x26, x2)
        return x27

    def verify_a87f7484(I: Grid) -> Grid:
        x0 = height(I)
        x1 = halve(x0)
        x2 = increment(x1)
        x3 = interval(THREE, x2, ONE)
        x4 = width(I)
        x5 = halve(x4)
        x6 = increment(x5)
        x7 = interval(THREE, x6, ONE)
        x8 = palette(I)
        x9 = lbind(apply, toindices)
        x10 = compose(x9, partition)
        x11 = rbind(compose, palette)
        x12 = lbind(lbind, contained)
        x13 = compose(x11, x12)
        x14 = lbind(chain, size)
        x15 = rbind(x14, x13)
        x16 = lbind(lbind, sfilter)
        x17 = compose(x15, x16)
        x18 = compose(positive, size)
        x19 = lbind(sfilter, x8)
        x20 = fork(matcher, x17, size)
        x21 = chain(x18, x19, x20)
        x22 = lbind(apply, shape)
        x23 = chain(size, dedupe, x22)
        x24 = matcher(x23, ONE)
        x25 = lbind(apply, x10)
        x26 = chain(size, dedupe, x25)
        x27 = matcher(x26, TWO)
        x28 = compose(size, dedupe)
        x29 = fork(equality, size, x28)
        x30 = fork(add, x21, x24)
        x31 = fork(add, x27, x29)
        x32 = fork(add, x30, x31)
        x33 = multiply(TEN, TEN)
        x34 = lbind(multiply, x33)
        x35 = compose(x34, x32)
        x36 = fork(add, x35, size)
        x37 = lbind(vsplit, I)
        x38 = apply(x37, x3)
        x39 = lbind(hsplit, I)
        x40 = apply(x39, x7)
        x41 = combine(x38, x40)
        x42 = argmax(x41, x36)
        x43 = apply(x10, x42)
        x44 = mostcommon(x43)
        x45 = matcher(x10, x44)
        x46 = argmin(x42, x45)
        return x46

    def verify_a8c38be5(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = mostcolor(I)
        x2 = palette(I)
        x3 = remove(x1, x2)
        x4 = lbind(colorcount, I)
        x5 = argmax(x3, x4)
        x6 = astuple(x1, x5)
        x7 = rbind(contained, x6)
        x8 = chain(flip, x7, color)
        x9 = sfilter(x0, x8)
        x10 = fork(connect, ulcorner, urcorner)
        x11 = fork(connect, ulcorner, llcorner)
        x12 = fork(combine, x10, x11)
        x13 = fork(equality, toindices, x12)
        x14 = fork(connect, urcorner, ulcorner)
        x15 = fork(connect, urcorner, lrcorner)
        x16 = fork(combine, x14, x15)
        x17 = fork(equality, toindices, x16)
        x18 = fork(connect, llcorner, ulcorner)
        x19 = fork(connect, llcorner, lrcorner)
        x20 = fork(combine, x18, x19)
        x21 = fork(equality, toindices, x20)
        x22 = fork(connect, lrcorner, llcorner)
        x23 = fork(connect, lrcorner, urcorner)
        x24 = fork(combine, x22, x23)
        x25 = fork(equality, toindices, x24)
        x26 = fork(contained, lrcorner, toindices)
        x27 = compose(flip, x26)
        x28 = fork(contained, llcorner, toindices)
        x29 = compose(flip, x28)
        x30 = fork(contained, urcorner, toindices)
        x31 = compose(flip, x30)
        x32 = fork(contained, ulcorner, toindices)
        x33 = compose(flip, x32)
        x34 = fork(both, x27, x29)
        x35 = fork(both, x31, x33)
        x36 = fork(both, x31, x27)
        x37 = fork(both, x33, x29)
        x38 = lbind(matcher, first)
        x39 = compose(x38, lowermost)
        x40 = fork(sfilter, toindices, x39)
        x41 = compose(size, x40)
        x42 = matcher(x41, ONE)
        x43 = lbind(matcher, first)
        x44 = compose(x43, uppermost)
        x45 = fork(sfilter, toindices, x44)
        x46 = compose(size, x45)
        x47 = matcher(x46, ONE)
        x48 = lbind(matcher, last)
        x49 = compose(x48, rightmost)
        x50 = fork(sfilter, toindices, x49)
        x51 = compose(size, x50)
        x52 = matcher(x51, ONE)
        x53 = lbind(matcher, last)
        x54 = compose(x53, leftmost)
        x55 = fork(sfilter, toindices, x54)
        x56 = compose(size, x55)
        x57 = matcher(x56, ONE)
        x58 = fork(both, x34, x42)
        x59 = fork(both, x35, x47)
        x60 = fork(both, x36, x52)
        x61 = fork(both, x37, x57)
        x62 = fork(connect, ulcorner, urcorner)
        x63 = fork(difference, x62, toindices)
        x64 = compose(size, x63)
        x65 = matcher(x64, ZERO)
        x66 = fork(connect, llcorner, lrcorner)
        x67 = fork(difference, x66, toindices)
        x68 = compose(size, x67)
        x69 = matcher(x68, ZERO)
        x70 = fork(connect, ulcorner, llcorner)
        x71 = fork(difference, x70, toindices)
        x72 = compose(size, x71)
        x73 = matcher(x72, ZERO)
        x74 = fork(connect, urcorner, lrcorner)
        x75 = fork(difference, x74, toindices)
        x76 = compose(size, x75)
        x77 = matcher(x76, ZERO)
        x78 = fork(both, x65, x58)
        x79 = fork(both, x69, x59)
        x80 = fork(both, x73, x60)
        x81 = fork(both, x77, x61)
        x82 = argmax(x9, x13)
        x83 = argmax(x9, x17)
        x84 = argmax(x9, x21)
        x85 = argmax(x9, x25)
        x86 = argmax(x9, x78)
        x87 = argmax(x9, x79)
        x88 = argmax(x9, x80)
        x89 = argmax(x9, x81)
        x90 = height(x82)
        x91 = height(x84)
        x92 = add(x90, x91)
        x93 = height(x88)
        x94 = add(x93, TWO)
        x95 = add(x92, x94)
        x96 = width(x82)
        x97 = width(x83)
        x98 = add(x96, x97)
        x99 = width(x86)
        x100 = add(x99, TWO)
        x101 = add(x98, x100)
        x102 = ulcorner(x82)
        x103 = increment(x102)
        x104 = index(I, x103)
        x105 = astuple(x95, x101)
        x106 = canvas(x104, x105)
        x107 = normalize(x82)
        x108 = paint(x106, x107)
        x109 = normalize(x83)
        x110 = width(x83)
        x111 = subtract(x101, x110)
        x112 = tojvec(x111)
        x113 = shift(x109, x112)
        x114 = paint(x108, x113)
        x115 = normalize(x84)
        x116 = height(x84)
        x117 = subtract(x95, x116)
        x118 = toivec(x117)
        x119 = shift(x115, x118)
        x120 = paint(x114, x119)
        x121 = normalize(x85)
        x122 = height(x85)
        x123 = subtract(x95, x122)
        x124 = width(x85)
        x125 = subtract(x101, x124)
        x126 = astuple(x123, x125)
        x127 = shift(x121, x126)
        x128 = paint(x120, x127)
        x129 = normalize(x88)
        x130 = height(x82)
        x131 = increment(x130)
        x132 = toivec(x131)
        x133 = shift(x129, x132)
        x134 = paint(x128, x133)
        x135 = normalize(x86)
        x136 = width(x82)
        x137 = increment(x136)
        x138 = tojvec(x137)
        x139 = shift(x135, x138)
        x140 = paint(x134, x139)
        x141 = normalize(x89)
        x142 = height(x83)
        x143 = increment(x142)
        x144 = width(x89)
        x145 = subtract(x101, x144)
        x146 = astuple(x143, x145)
        x147 = shift(x141, x146)
        x148 = paint(x140, x147)
        x149 = normalize(x87)
        x150 = height(x87)
        x151 = subtract(x95, x150)
        x152 = width(x84)
        x153 = increment(x152)
        x154 = astuple(x151, x153)
        x155 = shift(x149, x154)
        x156 = paint(x148, x155)
        return x156

    def verify_a8d7556c(I: Grid) -> Grid:
        x0 = initset(ORIGIN)
        x1 = recolor(ZERO, x0)
        x2 = upscale(x1, TWO)
        x3 = occurrences(I, x2)
        x4 = lbind(shift, x2)
        x5 = mapply(x4, x3)
        x6 = fill(I, TWO, x5)
        return x6

    def verify_a9f96cdd(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = shift(x1, NEG_UNITY)
        x3 = recolor(THREE, x2)
        x4 = shift(x1, UNITY)
        x5 = recolor(SEVEN, x4)
        x6 = shift(x1, DOWN_LEFT)
        x7 = recolor(EIGHT, x6)
        x8 = shift(x1, UP_RIGHT)
        x9 = recolor(SIX, x8)
        x10 = mostcolor(I)
        x11 = fill(I, x10, x1)
        x12 = combine(x3, x5)
        x13 = combine(x7, x9)
        x14 = combine(x12, x13)
        x15 = paint(x11, x14)
        return x15

    def verify_aabf363d(I: Grid) -> Grid:
        x0 = fork(multiply, height, width)
        x1 = lbind(ofcolor, I)
        x2 = palette(I)
        x3 = compose(x0, x1)
        x4 = argmax(x2, x3)
        x5 = leastcolor(I)
        x6 = palette(I)
        x7 = remove(x4, x6)
        x8 = other(x7, x5)
        x9 = replace(I, x5, x4)
        x10 = replace(x9, x8, x5)
        return x10

    def verify_aba27056(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = delta(x1)
        x3 = fill(I, FOUR, x2)
        x4 = delta(x1)
        x5 = box(x1)
        x6 = intersection(x4, x5)
        x7 = uppermost(x6)
        x8 = uppermost(x1)
        x9 = equality(x7, x8)
        x10 = leftmost(x6)
        x11 = leftmost(x1)
        x12 = equality(x10, x11)
        x13 = lowermost(x6)
        x14 = lowermost(x1)
        x15 = equality(x13, x14)
        x16 = rightmost(x6)
        x17 = rightmost(x1)
        x18 = equality(x16, x17)
        x19 = urcorner(x6)
        x20 = ulcorner(x6)
        x21 = llcorner(x6)
        x22 = lrcorner(x6)
        x23 = branch(x15, x21, x22)
        x24 = branch(x12, x20, x23)
        x25 = branch(x9, x19, x24)
        x26 = branch(x15, x22, x19)
        x27 = branch(x12, x21, x26)
        x28 = branch(x9, x20, x27)
        x29 = branch(x15, DOWN_LEFT, UNITY)
        x30 = branch(x12, NEG_UNITY, x29)
        x31 = branch(x9, UP_RIGHT, x30)
        x32 = branch(x15, UNITY, UP_RIGHT)
        x33 = branch(x12, DOWN_LEFT, x32)
        x34 = branch(x9, NEG_UNITY, x33)
        x35 = branch(x15, DOWN, RIGHT)
        x36 = branch(x12, LEFT, x35)
        x37 = branch(x9, UP, x36)
        x38 = shoot(x25, x31)
        x39 = shoot(x28, x34)
        x40 = combine(x38, x39)
        x41 = rbind(shoot, x37)
        x42 = mapply(x41, x6)
        x43 = combine(x42, x40)
        x44 = fill(x3, FOUR, x43)
        return x44

    def verify_ac0a08a4(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = colorcount(I, x0)
        x2 = height(I)
        x3 = width(I)
        x4 = multiply(x2, x3)
        x5 = subtract(x4, x1)
        x6 = upscale(I, x5)
        return x6

    def verify_ae3edfdc(I: Grid) -> Grid:
        x0 = ofcolor(I, ONE)
        x1 = center(x0)
        x2 = ofcolor(I, TWO)
        x3 = center(x2)
        x4 = ofcolor(I, THREE)
        x5 = ofcolor(I, SEVEN)
        x6 = lbind(add, x1)
        x7 = initset(x1)
        x8 = rbind(position, x7)
        x9 = compose(invert, x8)
        x10 = chain(x6, x9, initset)
        x11 = lbind(add, x3)
        x12 = initset(x3)
        x13 = rbind(position, x12)
        x14 = compose(invert, x13)
        x15 = chain(x11, x14, initset)
        x16 = apply(x10, x5)
        x17 = apply(x15, x4)
        x18 = combine(x4, x5)
        x19 = cover(I, x18)
        x20 = fill(x19, SEVEN, x16)
        x21 = fill(x20, THREE, x17)
        return x21

    def verify_ae4f1146(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = toobject(x1, I)
        x3 = mostcolor(x2)
        x4 = objects(I, F, F, T)
        x5 = rbind(colorcount, ONE)
        x6 = argmax(x4, x5)
        x7 = subgrid(x6, I)
        return x7

    def verify_aedd82e4(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = canvas(ZERO, x0)
        x2 = hconcat(I, x1)
        x3 = objects(x2, F, F, T)
        x4 = matcher(color, ZERO)
        x5 = compose(flip, x4)
        x6 = sfilter(x3, x5)
        x7 = sizefilter(x6, ONE)
        x8 = merge(x7)
        x9 = fill(I, ONE, x8)
        return x9

    def verify_af902bf9(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = palette(I)
        x2 = remove(x0, x1)
        x3 = interval(THREE, SEVEN, ONE)
        x4 = product(x3, x3)
        x5 = fork(multiply, first, last)
        x6 = order(x4, x5)
        x7 = lbind(canvas, NEG_ONE)
        x8 = chain(x7, first, first)
        x9 = chain(corners, asindices, x8)
        x10 = lbind(recolor, x0)
        x11 = compose(asindices, x8)
        x12 = fork(difference, x11, x9)
        x13 = lbind(recolor, TWO)
        x14 = compose(inbox, x9)
        x15 = chain(x13, backdrop, x14)
        x16 = compose(x10, x12)
        x17 = lbind(lbind, combine)
        x18 = compose(x17, x16)
        x19 = lbind(rbind, recolor)
        x20 = compose(x19, x9)
        x21 = fork(compose, x18, x20)
        x22 = lbind(lbind, mapply)
        x23 = lbind(lbind, shift)
        x24 = chain(x22, x23, x15)
        x25 = lbind(lbind, occurrences)
        x26 = compose(x25, last)
        x27 = fork(compose, x26, x21)
        x28 = fork(compose, x24, x27)
        x29 = rbind(mapply, x2)
        x30 = compose(x29, x28)
        x31 = fork(paint, last, x30)
        x32 = compose(first, first)
        x33 = fork(remove, x32, first)
        x34 = fork(astuple, x33, x31)
        x35 = size(x6)
        x36 = power(x34, x35)
        x37 = astuple(x6, I)
        x38 = x36(x37)
        x39 = last(x38)
        return x39

    def verify_b0c4d837(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = argmax(x0, x1)
        x3 = remove(x2, x0)
        x4 = argmin(x3, x1)
        x5 = argmax(x3, x1)
        x6 = ulcorner(x5)
        x7 = llcorner(x5)
        x8 = connect(x6, x7)
        x9 = urcorner(x5)
        x10 = lrcorner(x5)
        x11 = connect(x9, x10)
        x12 = combine(x8, x11)
        x13 = toindices(x5)
        x14 = difference(x12, x13)
        x15 = size(x14)
        x16 = equality(x15, ZERO)
        x17 = branch(x16, height, width)
        x18 = x17(x5)
        x19 = x17(x4)
        x20 = subtract(x18, x19)
        x21 = decrement(x20)
        x22 = color(x4)
        x23 = color(x2)
        x24 = repeat(x22, x21)
        x25 = subtract(NINE, x21)
        x26 = repeat(x23, x25)
        x27 = combine(x24, x26)
        x28 = repeat(x27, ONE)
        x29 = hsplit(x28, THREE)
        x30 = interval(ZERO, THREE, ONE)
        x31 = pair(x30, x29)
        x32 = matcher(first, ZERO)
        x33 = extract(x31, x32)
        x34 = last(x33)
        x35 = matcher(first, ONE)
        x36 = extract(x31, x35)
        x37 = last(x36)
        x38 = matcher(first, TWO)
        x39 = extract(x31, x38)
        x40 = last(x39)
        x41 = vmirror(x37)
        x42 = vconcat(x34, x41)
        x43 = vconcat(x42, x40)
        return x43

    def verify_b190f7f5(I: Grid) -> Grid:
        x0 = lbind(contained, TWO)
        x1 = lbind(apply, numcolors)
        x2 = compose(x0, x1)
        x3 = lbind(apply, shape)
        x4 = chain(size, dedupe, x3)
        x5 = matcher(x4, ONE)
        x6 = compose(palette, first)
        x7 = compose(palette, last)
        x8 = fork(intersection, x6, x7)
        x9 = compose(size, x8)
        x10 = matcher(x9, ONE)
        x11 = lbind(contained, ONE)
        x12 = compose(minimum, shape)
        x13 = lbind(apply, x12)
        x14 = chain(flip, x11, x13)
        x15 = fork(add, x2, x5)
        x16 = fork(add, x10, x14)
        x17 = fork(add, x15, x16)
        x18 = vsplit(I, TWO)
        x19 = hsplit(I, TWO)
        x20 = astuple(x18, x19)
        x21 = argmax(x20, x17)
        x22 = argmin(x21, numcolors)
        x23 = argmax(x21, numcolors)
        x24 = palette(x22)
        x25 = palette(x23)
        x26 = intersection(x24, x25)
        x27 = first(x26)
        x28 = asindices(x22)
        x29 = ofcolor(x22, x27)
        x30 = difference(x28, x29)
        x31 = asobject(x23)
        x32 = matcher(first, x27)
        x33 = sfilter(x31, x32)
        x34 = difference(x31, x33)
        x35 = shape(x22)
        x36 = multiply(x35, x35)
        x37 = canvas(x27, x36)
        x38 = lbind(shift, x30)
        x39 = lbind(multiply, x35)
        x40 = chain(x38, x39, last)
        x41 = fork(recolor, first, x40)
        x42 = mapply(x41, x34)
        x43 = paint(x37, x42)
        return x43

    def verify_b1948b0a(I: Grid) -> Grid:
        x0 = replace(I, SIX, TWO)
        return x0

    def verify_b230c067(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = lbind(sfilter, x0)
        x2 = lbind(matcher, normalize)
        x3 = compose(x2, normalize)
        x4 = chain(size, x1, x3)
        x5 = argmin(x0, x4)
        x6 = remove(x5, x0)
        x7 = merge(x6)
        x8 = fill(I, TWO, x5)
        x9 = fill(x8, ONE, x7)
        return x9

    def verify_b27ca6d3(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = sizefilter(x0, TWO)
        x2 = mapply(outbox, x1)
        x3 = fill(I, THREE, x2)
        return x3

    def verify_b2862040(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = mostcolor(I)
        x2 = colorfilter(x0, x1)
        x3 = rbind(bordering, I)
        x4 = compose(flip, x3)
        x5 = mfilter(x2, x4)
        x6 = difference(x0, x2)
        x7 = apply(toindices, x6)
        x8 = rbind(adjacent, x5)
        x9 = mfilter(x7, x8)
        x10 = fill(I, EIGHT, x9)
        return x10

    def verify_b527c5c6(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = lbind(matcher, first)
        x2 = compose(x1, leastcolor)
        x3 = fork(sfilter, identity, x2)
        x4 = compose(center, x3)
        x5 = compose(dneighbors, x4)
        x6 = fork(difference, x5, toindices)
        x7 = compose(first, x6)
        x8 = fork(subtract, x7, x4)
        x9 = compose(invert, x8)
        x10 = fork(shoot, x4, x9)
        x11 = fork(intersection, toindices, x10)
        x12 = chain(decrement, size, x11)
        x13 = fork(shoot, x4, x8)
        x14 = lbind(power, outbox)
        x15 = compose(x14, x12)
        x16 = compose(initset, x15)
        x17 = fork(rapply, x16, x13)
        x18 = chain(backdrop, first, x17)
        x19 = fork(recolor, leastcolor, x13)
        x20 = fork(difference, x18, x13)
        x21 = fork(recolor, mostcolor, x20)
        x22 = fork(combine, x19, x21)
        x23 = mapply(x22, x0)
        x24 = paint(I, x23)
        return x24

    def verify_b548a754(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(equality, toindices, box)
        x2 = fork(multiply, height, width)
        x3 = fork(equality, size, x2)
        x4 = compose(flip, x3)
        x5 = fork(both, x1, x4)
        x6 = extract(x0, x5)
        x7 = inbox(x6)
        x8 = backdrop(x7)
        x9 = toobject(x8, I)
        x10 = remove(x9, x0)
        x11 = remove(x6, x10)
        x12 = argmin(x11, size)
        x13 = combine(x12, x6)
        x14 = backdrop(x13)
        x15 = color(x9)
        x16 = fill(I, x15, x14)
        x17 = color(x6)
        x18 = box(x14)
        x19 = fill(x16, x17, x18)
        return x19

    def verify_b60334d2(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = mostcolor(I)
        x2 = ofcolor(I, x0)
        x3 = replace(I, x0, x1)
        x4 = mapply(dneighbors, x2)
        x5 = mapply(ineighbors, x2)
        x6 = fill(x3, ONE, x4)
        x7 = fill(x6, x0, x5)
        return x7

    def verify_b6afb2da(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = fork(equality, toindices, backdrop)
        x2 = compose(flip, x1)
        x3 = extract(x0, x2)
        x4 = color(x3)
        x5 = matcher(color, x4)
        x6 = compose(flip, x5)
        x7 = sfilter(x0, x6)
        x8 = merge(x7)
        x9 = fill(I, TWO, x8)
        x10 = mapply(box, x7)
        x11 = fill(x9, FOUR, x10)
        x12 = mapply(corners, x7)
        x13 = fill(x11, ONE, x12)
        return x13

    def verify_b7249182(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = merge(x0)
        x2 = portrait(x1)
        x3 = branch(x2, identity, dmirror)
        x4 = x3(I)
        x5 = objects(x4, T, F, T)
        x6 = order(x5, uppermost)
        x7 = first(x6)
        x8 = last(x6)
        x9 = color(x7)
        x10 = color(x8)
        x11 = compose(first, toindices)
        x12 = x11(x7)
        x13 = x11(x8)
        x14 = connect(x12, x13)
        x15 = centerofmass(x14)
        x16 = connect(x12, x15)
        x17 = fill(x4, x10, x14)
        x18 = fill(x17, x9, x16)
        x19 = add(x15, DOWN)
        x20 = initset(x15)
        x21 = insert(x19, x20)
        x22 = toobject(x21, x18)
        x23 = astuple(ZERO, NEG_TWO)
        x24 = shift(x22, ZERO_BY_TWO)
        x25 = shift(x22, x23)
        x26 = combine(x24, x25)
        x27 = ulcorner(x26)
        x28 = urcorner(x26)
        x29 = connect(x27, x28)
        x30 = shift(x29, UP)
        x31 = llcorner(x26)
        x32 = lrcorner(x26)
        x33 = connect(x31, x32)
        x34 = shift(x33, DOWN)
        x35 = paint(x18, x26)
        x36 = fill(x35, x9, x30)
        x37 = fill(x36, x10, x34)
        x38 = cover(x37, x21)
        x39 = x3(x38)
        return x39

    def verify_b775ac94(I: Grid) -> Grid:
        x0 = objects(I, F, T, T)
        x1 = neighbors(ORIGIN)
        x2 = lbind(extract, x1)
        x3 = matcher(first, ZERO)
        x4 = matcher(last, ZERO)
        x5 = rbind(branch, hmirror)
        x6 = rbind(x5, identity)
        x7 = rbind(branch, vmirror)
        x8 = rbind(x7, identity)
        x9 = compose(x6, x3)
        x10 = compose(x8, x4)
        x11 = fork(compose, x9, x10)
        x12 = lbind(matcher, first)
        x13 = compose(x12, mostcolor)
        x14 = fork(sfilter, identity, x13)
        x15 = fork(difference, identity, x14)
        x16 = lbind(rbind, multiply)
        x17 = chain(x16, shape, x14)
        x18 = lbind(lbind, shift)
        x19 = chain(x18, backdrop, x14)
        x20 = fork(compose, x19, x17)
        x21 = lbind(lbind, contained)
        x22 = compose(x21, last)
        x23 = rbind(compose, x22)
        x24 = lbind(rbind, compose)
        x25 = chain(x23, x24, x20)
        x26 = lbind(fork, recolor)
        x27 = lbind(x26, first)
        x28 = lbind(fork, shift)
        x29 = lbind(chain, x11)
        x30 = lbind(x29, x2)
        x31 = rbind(compose, x2)
        x32 = compose(x31, x17)
        x33 = fork(compose, x32, x25)
        x34 = compose(x30, x25)
        x35 = lbind(chain, first)
        x36 = lbind(rbind, rapply)
        x37 = compose(x36, x14)
        x38 = lbind(compose, initset)
        x39 = compose(x38, x34)
        x40 = fork(x35, x37, x39)
        x41 = compose(x27, x40)
        x42 = fork(x28, x41, x33)
        x43 = fork(mapply, x42, x15)
        x44 = mapply(x43, x0)
        x45 = paint(I, x44)
        return x45

    def verify_b782dc8a(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = palette(I)
        x2 = remove(x0, x1)
        x3 = lbind(colorcount, I)
        x4 = argmin(x2, x3)
        x5 = ofcolor(I, x0)
        x6 = ofcolor(I, x4)
        x7 = combine(x5, x6)
        x8 = mapply(neighbors, x7)
        x9 = difference(x8, x7)
        x10 = toobject(x9, I)
        x11 = leastcolor(x10)
        x12 = ofcolor(I, x0)
        x13 = first(x12)
        x14 = initset(x13)
        x15 = objects(I, T, F, F)
        x16 = colorfilter(x15, x11)
        x17 = lbind(adjacent, x7)
        x18 = mfilter(x16, x17)
        x19 = toindices(x18)
        x20 = rbind(manhattan, x14)
        x21 = chain(even, x20, initset)
        x22 = sfilter(x19, x21)
        x23 = fill(I, x4, x19)
        x24 = fill(x23, x0, x22)
        return x24

    def verify_b8825c91(I: Grid) -> Grid:
        x0 = replace(I, FOUR, NEG_ONE)
        x1 = dmirror(x0)
        x2 = papply(pair, x0, x1)
        x3 = lbind(apply, maximum)
        x4 = apply(x3, x2)
        x5 = cmirror(x4)
        x6 = papply(pair, x4, x5)
        x7 = apply(x3, x6)
        x8 = hmirror(x7)
        x9 = papply(pair, x7, x8)
        x10 = apply(x3, x9)
        x11 = vmirror(x10)
        x12 = papply(pair, x11, x10)
        x13 = apply(x3, x12)
        return x13

    def verify_b8cdaf2b(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = astuple(dmirror, cmirror)
        x2 = astuple(hmirror, identity)
        x3 = combine(x1, x2)
        x4 = rbind(rapply, I)
        x5 = chain(first, x4, initset)
        x6 = rbind(ofcolor, x0)
        x7 = chain(lowermost, x6, x5)
        x8 = chain(decrement, height, x5)
        x9 = fork(equality, x7, x8)
        x10 = extract(x3, x9)
        x11 = x10(I)
        x12 = ofcolor(x11, x0)
        x13 = shift(x12, UP)
        x14 = ulcorner(x13)
        x15 = urcorner(x13)
        x16 = shoot(x14, NEG_UNITY)
        x17 = shoot(x15, UP_RIGHT)
        x18 = combine(x16, x17)
        x19 = underfill(x11, x0, x18)
        x20 = x10(x19)
        return x20

    def verify_b91ae062(I: Grid) -> Grid:
        x0 = numcolors(I)
        x1 = decrement(x0)
        x2 = upscale(I, x1)
        return x2

    def verify_b94a9452(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = argmax(x0, x1)
        x3 = remove(x2, x0)
        x4 = merge(x3)
        x5 = subgrid(x4, I)
        x6 = mostcolor(x5)
        x7 = leastcolor(x5)
        x8 = switch(x5, x6, x7)
        return x8

    def verify_b9b7f026(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = fork(equality, toindices, backdrop)
        x2 = compose(flip, x1)
        x3 = extract(x0, x2)
        x4 = color(x3)
        x5 = canvas(x4, UNITY)
        return x5

    def verify_ba26e723(I: Grid) -> Grid:
        x0 = asobject(I)
        x1 = matcher(first, ZERO)
        x2 = compose(flip, x1)
        x3 = sfilter(x0, x2)
        x4 = rbind(multiply, THREE)
        x5 = rbind(divide, THREE)
        x6 = compose(x4, x5)
        x7 = fork(equality, identity, x6)
        x8 = toindices(x3)
        x9 = compose(x7, last)
        x10 = sfilter(x8, x9)
        x11 = fill(I, SIX, x10)
        return x11

    def verify_ba97ae07(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = totuple(x0)
        x2 = apply(color, x1)
        x3 = mostcommon(x2)
        x4 = ofcolor(I, x3)
        x5 = backdrop(x4)
        x6 = fill(I, x3, x5)
        return x6

    def verify_bb43febb(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = fork(equality, toindices, backdrop)
        x2 = rbind(greater, ONE)
        x3 = chain(x2, minimum, shape)
        x4 = fork(both, x1, x3)
        x5 = sfilter(x0, x4)
        x6 = compose(backdrop, inbox)
        x7 = mapply(x6, x5)
        x8 = fill(I, TWO, x7)
        return x8

    def verify_bbc9ae5d(I: Grid) -> Grid:
        x0 = index(I, ORIGIN)
        x1 = width(I)
        x2 = halve(x1)
        x3 = astuple(x2, x1)
        x4 = canvas(x0, x3)
        x5 = rbind(shoot, UNITY)
        x6 = compose(x5, last)
        x7 = fork(recolor, first, x6)
        x8 = asobject(I)
        x9 = mapply(x7, x8)
        x10 = paint(x4, x9)
        return x10

    def verify_bc1d5164(I: Grid) -> Grid:
        x0 = height(I)
        x1 = halve(x0)
        x2 = increment(x1)
        x3 = width(I)
        x4 = halve(x3)
        x5 = frontiers(I)
        x6 = merge(x5)
        x7 = mostcolor(x6)
        x8 = astuple(x2, x4)
        x9 = canvas(x7, x8)
        x10 = asindices(x9)
        x11 = toobject(x10, I)
        x12 = increment(x4)
        x13 = tojvec(x12)
        x14 = shift(x10, x13)
        x15 = toobject(x14, I)
        x16 = decrement(x2)
        x17 = toivec(x16)
        x18 = shift(x10, x17)
        x19 = toobject(x18, I)
        x20 = decrement(x2)
        x21 = increment(x4)
        x22 = astuple(x20, x21)
        x23 = shift(x10, x22)
        x24 = toobject(x23, I)
        x25 = palette(I)
        x26 = other(x25, x7)
        x27 = matcher(first, x26)
        x28 = rbind(sfilter, x27)
        x29 = chain(toindices, x28, normalize)
        x30 = x29(x11)
        x31 = x29(x15)
        x32 = x29(x19)
        x33 = x29(x24)
        x34 = combine(x30, x31)
        x35 = combine(x32, x33)
        x36 = combine(x34, x35)
        x37 = fill(x9, x26, x36)
        return x37

    def verify_bd4472b8(I: Grid) -> Grid:
        x0 = compose(positive, size)
        x1 = rbind(sfilter, hline)
        x2 = chain(x0, x1, frontiers)
        x3 = chain(size, dedupe, first)
        x4 = chain(size, dedupe, last)
        x5 = fork(greater, x3, x4)
        x6 = fork(both, x2, x5)
        x7 = astuple(identity, rot90)
        x8 = astuple(rot180, rot270)
        x9 = combine(x7, x8)
        x10 = astuple(identity, rot270)
        x11 = astuple(rot180, rot90)
        x12 = combine(x10, x11)
        x13 = pair(x9, x12)
        x14 = rbind(rapply, I)
        x15 = compose(initset, first)
        x16 = chain(first, x14, x15)
        x17 = compose(x6, x16)
        x18 = extract(x13, x17)
        x19 = first(x18)
        x20 = last(x18)
        x21 = x19(I)
        x22 = first(x21)
        x23 = repeat(x22, ONE)
        x24 = dmirror(x23)
        x25 = width(x21)
        x26 = hupscale(x24, x25)
        x27 = asobject(x26)
        x28 = height(x21)
        x29 = height(x27)
        x30 = interval(ZERO, x28, x29)
        x31 = lbind(shift, x27)
        x32 = apply(toivec, x30)
        x33 = mapply(x31, x32)
        x34 = shift(x33, TWO_BY_ZERO)
        x35 = paint(x21, x34)
        x36 = x20(x35)
        return x36

    def verify_bda2d7a6(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = compose(maximum, shape)
        x2 = order(x0, x1)
        x3 = first(x2)
        x4 = last(x2)
        x5 = color(x3)
        x6 = color(x4)
        x7 = equality(x5, x6)
        x8 = combine(x3, x4)
        x9 = repeat(x8, ONE)
        x10 = remove(x3, x2)
        x11 = remove(x4, x10)
        x12 = combine(x9, x11)
        x13 = branch(x7, x12, x2)
        x14 = apply(color, x13)
        x15 = last(x13)
        x16 = remove(x15, x13)
        x17 = repeat(x15, ONE)
        x18 = combine(x17, x16)
        x19 = mpapply(recolor, x14, x18)
        x20 = paint(I, x19)
        return x20

    def verify_bdad9b1f(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = sfilter(x0, hline)
        x2 = sfilter(x0, vline)
        x3 = compose(hfrontier, center)
        x4 = fork(recolor, color, x3)
        x5 = mapply(x4, x1)
        x6 = compose(vfrontier, center)
        x7 = fork(recolor, color, x6)
        x8 = mapply(x7, x2)
        x9 = combine(x5, x8)
        x10 = paint(I, x9)
        x11 = toindices(x5)
        x12 = toindices(x8)
        x13 = intersection(x11, x12)
        x14 = fill(x10, FOUR, x13)
        return x14

    def verify_be94b721(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = argmax(x0, size)
        x2 = color(x1)
        x3 = remove(x1, x0)
        x4 = argmax(x3, size)
        x5 = shape(x4)
        x6 = canvas(x2, x5)
        x7 = normalize(x4)
        x8 = paint(x6, x7)
        return x8

    def verify_beb8660c(I: Grid) -> Grid:
        x0 = astuple(identity, rot90)
        x1 = astuple(rot180, rot270)
        x2 = combine(x0, x1)
        x3 = astuple(identity, rot270)
        x4 = astuple(rot180, rot90)
        x5 = combine(x3, x4)
        x6 = pair(x2, x5)
        x7 = rbind(rapply, I)
        x8 = compose(initset, first)
        x9 = chain(first, x7, x8)
        x10 = rbind(ofcolor, EIGHT)
        x11 = chain(lowermost, x10, x9)
        x12 = matcher(x11, ZERO)
        x13 = extract(x6, x12)
        x14 = first(x13)
        x15 = last(x13)
        x16 = x14(I)
        x17 = rot180(x16)
        x18 = shape(x17)
        x19 = lbind(apply, first)
        x20 = lbind(ofcolor, x17)
        x21 = chain(size, x19, x20)
        x22 = palette(I)
        x23 = argmax(x22, x21)
        x24 = partition(x17)
        x25 = matcher(color, x23)
        x26 = compose(flip, x25)
        x27 = sfilter(x24, x26)
        x28 = compose(invert, size)
        x29 = order(x27, x28)
        x30 = apply(normalize, x29)
        x31 = size(x30)
        x32 = interval(ZERO, x31, ONE)
        x33 = apply(toivec, x32)
        x34 = mpapply(shift, x30, x33)
        x35 = canvas(x23, x18)
        x36 = paint(x35, x34)
        x37 = x15(x36)
        return x37

    def verify_c0f76784(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = mostcolor(I)
        x2 = colorfilter(x0, x1)
        x3 = sizefilter(x2, ONE)
        x4 = merge(x3)
        x5 = sizefilter(x2, FOUR)
        x6 = merge(x5)
        x7 = sizefilter(x2, NINE)
        x8 = merge(x7)
        x9 = fill(I, SIX, x4)
        x10 = fill(x9, SEVEN, x6)
        x11 = fill(x10, EIGHT, x8)
        return x11

    def verify_c1d99e64(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = fill(I, TWO, x1)
        return x2

    def verify_c3e719e8(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = multiply(x0, x0)
        x2 = canvas(ZERO, x1)
        x3 = mostcolor(I)
        x4 = ofcolor(I, x3)
        x5 = lbind(multiply, x0)
        x6 = apply(x5, x4)
        x7 = asobject(I)
        x8 = lbind(shift, x7)
        x9 = mapply(x8, x6)
        x10 = paint(x2, x9)
        return x10

    def verify_c3f564a4(I: Grid) -> Grid:
        x0 = height(I)
        x1 = vsplit(I, x0)
        x2 = apply(asobject, x1)
        x3 = apply(hperiod, x2)
        x4 = minimum(x3)
        x5 = width(I)
        x6 = hsplit(I, x5)
        x7 = apply(asobject, x6)
        x8 = apply(vperiod, x7)
        x9 = minimum(x8)
        x10 = matcher(hperiod, x4)
        x11 = sfilter(x2, x10)
        x12 = mapply(palette, x11)
        x13 = matcher(vperiod, x9)
        x14 = sfilter(x7, x13)
        x15 = mapply(palette, x14)
        x16 = palette(I)
        x17 = combine(x12, x15)
        x18 = rbind(contained, x17)
        x19 = argmin(x16, x18)
        x20 = asobject(I)
        x21 = matcher(first, x19)
        x22 = compose(flip, x21)
        x23 = sfilter(x20, x22)
        x24 = height(I)
        x25 = divide(x24, x9)
        x26 = increment(x25)
        x27 = width(I)
        x28 = divide(x27, x4)
        x29 = increment(x28)
        x30 = invert(x26)
        x31 = interval(x30, x26, ONE)
        x32 = invert(x29)
        x33 = interval(x32, x29, ONE)
        x34 = product(x31, x33)
        x35 = astuple(x9, x4)
        x36 = lbind(multiply, x35)
        x37 = apply(x36, x34)
        x38 = lbind(shift, x23)
        x39 = mapply(x38, x37)
        x40 = paint(I, x39)
        return x40

    def verify_c444b776(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = leastcolor(x1)
        x3 = shape(I)
        x4 = canvas(x2, x3)
        x5 = hconcat(I, x4)
        x6 = objects(x5, F, F, T)
        x7 = argmax(x6, numcolors)
        x8 = apply(ulcorner, x6)
        x9 = normalize(x7)
        x10 = lbind(shift, x9)
        x11 = mapply(x10, x8)
        x12 = paint(I, x11)
        return x12

    def verify_c59eb873(I: Grid) -> Grid:
        x0 = upscale(I, TWO)
        return x0

    def verify_c8cbb738(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = valmax(x0, height)
        x2 = valmax(x0, width)
        x3 = astuple(x1, x2)
        x4 = mostcolor(I)
        x5 = canvas(x4, x3)
        x6 = asindices(x5)
        x7 = apply(normalize, x0)
        x8 = box(x6)
        x9 = maximum(x3)
        x10 = double(x9)
        x11 = asindices(x5)
        x12 = center(x11)
        x13 = initset(x12)
        x14 = lbind(manhattan, x13)
        x15 = lbind(multiply, x10)
        x16 = lbind(intersection, x8)
        x17 = chain(x15, size, x16)
        x18 = lbind(fork, subtract)
        x19 = lbind(chain, x17)
        x20 = lbind(x19, toindices)
        x21 = lbind(lbind, shift)
        x22 = compose(x20, x21)
        x23 = lbind(chain, x14)
        x24 = compose(initset, center)
        x25 = lbind(x23, x24)
        x26 = lbind(lbind, shift)
        x27 = compose(x25, x26)
        x28 = lbind(argmax, x6)
        x29 = fork(x18, x22, x27)
        x30 = compose(x28, x29)
        x31 = fork(shift, identity, x30)
        x32 = mapply(x31, x7)
        x33 = paint(x5, x32)
        return x33

    def verify_c8f0f002(I: Grid) -> Grid:
        x0 = replace(I, SEVEN, FIVE)
        return x0

    def verify_c909285e(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = lbind(contained, ONE)
        x2 = chain(flip, x1, shape)
        x3 = sfilter(x0, x2)
        x4 = fork(equality, toindices, box)
        x5 = sfilter(x3, x4)
        x6 = fork(multiply, height, width)
        x7 = argmin(x5, x6)
        x8 = subgrid(x7, I)
        return x8

    def verify_c9e6f938(I: Grid) -> Grid:
        x0 = vmirror(I)
        x1 = hconcat(I, x0)
        return x1

    def verify_c9f8e694(I: Grid) -> Grid:
        x0 = astuple(identity, dmirror)
        x1 = astuple(cmirror, vmirror)
        x2 = combine(x0, x1)
        x3 = compose(first, dmirror)
        x4 = chain(size, dedupe, x3)
        x5 = rbind(rapply, I)
        x6 = compose(first, x5)
        x7 = chain(x4, x6, initset)
        x8 = argmax(x2, x7)
        x9 = x8(I)
        x10 = height(x9)
        x11 = width(x9)
        x12 = ofcolor(x9, ZERO)
        x13 = astuple(x10, ONE)
        x14 = crop(x9, ORIGIN, x13)
        x15 = hupscale(x14, x11)
        x16 = fill(x15, ZERO, x12)
        x17 = x8(x16)
        return x17

    def verify_caa06a1f(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = toobject(x1, I)
        x3 = mostcolor(x2)
        x4 = asobject(I)
        x5 = matcher(first, x3)
        x6 = compose(flip, x5)
        x7 = sfilter(x4, x6)
        x8 = hperiod(x7)
        x9 = vperiod(x7)
        x10 = width(I)
        x11 = width(x7)
        x12 = subtract(x10, x11)
        x13 = add(x12, TWO)
        x14 = height(I)
        x15 = height(x7)
        x16 = subtract(x14, x15)
        x17 = add(x16, TWO)
        x18 = rbind(multiply, x8)
        x19 = invert(x13)
        x20 = interval(x19, x13, ONE)
        x21 = apply(x18, x20)
        x22 = rbind(multiply, x9)
        x23 = invert(x17)
        x24 = interval(x23, x17, ONE)
        x25 = apply(x22, x24)
        x26 = product(x25, x21)
        x27 = lbind(shift, x7)
        x28 = mapply(x27, x26)
        x29 = index(I, ORIGIN)
        x30 = equality(x29, x3)
        x31 = flip(x30)
        x32 = asindices(I)
        x33 = urcorner(x32)
        x34 = index(I, x33)
        x35 = equality(x34, x3)
        x36 = flip(x35)
        x37 = asindices(I)
        x38 = lrcorner(x37)
        x39 = index(I, x38)
        x40 = equality(x39, x3)
        x41 = flip(x40)
        x42 = asindices(I)
        x43 = llcorner(x42)
        x44 = index(I, x43)
        x45 = equality(x44, x3)
        x46 = flip(x45)
        x47 = multiply(x31, LEFT)
        x48 = multiply(x36, UP)
        x49 = add(x47, x48)
        x50 = multiply(x41, RIGHT)
        x51 = multiply(x46, DOWN)
        x52 = add(x50, x51)
        x53 = add(x49, x52)
        x54 = shift(x28, x53)
        x55 = paint(I, x54)
        return x55

    def verify_cbded52d(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = color(x1)
        x3 = palette(I)
        x4 = remove(x2, x3)
        x5 = lbind(colorcount, I)
        x6 = argmax(x4, x5)
        x7 = remove(x6, x4)
        x8 = height(I)
        x9 = increment(x8)
        x10 = frontiers(I)
        x11 = sfilter(x10, hline)
        x12 = size(x11)
        x13 = increment(x12)
        x14 = divide(x9, x13)
        x15 = width(I)
        x16 = increment(x15)
        x17 = frontiers(I)
        x18 = sfilter(x17, vline)
        x19 = size(x18)
        x20 = increment(x19)
        x21 = divide(x16, x20)
        x22 = rbind(multiply, x14)
        x23 = rbind(divide, x14)
        x24 = compose(x22, x23)
        x25 = fork(equality, identity, x24)
        x26 = rbind(multiply, x21)
        x27 = rbind(divide, x21)
        x28 = compose(x26, x27)
        x29 = fork(equality, identity, x28)
        x30 = lbind(fork, both)
        x31 = rbind(compose, first)
        x32 = lbind(compose, x25)
        x33 = lbind(rbind, subtract)
        x34 = compose(x33, uppermost)
        x35 = chain(x31, x32, x34)
        x36 = rbind(compose, last)
        x37 = lbind(compose, x29)
        x38 = lbind(rbind, subtract)
        x39 = compose(x38, leftmost)
        x40 = chain(x36, x37, x39)
        x41 = fork(x30, x35, x40)
        x42 = fork(sfilter, identity, x41)
        x43 = fork(connect, first, last)
        x44 = lbind(apply, x43)
        x45 = lbind(ofcolor, I)
        x46 = fork(product, x45, x45)
        x47 = fork(either, vline, hline)
        x48 = rbind(sfilter, x47)
        x49 = chain(x48, x44, x46)
        x50 = lbind(mapply, x42)
        x51 = compose(x50, x49)
        x52 = fork(recolor, identity, x51)
        x53 = mapply(x52, x7)
        x54 = paint(I, x53)
        return x54

    def verify_cce03e0d(I: Grid) -> Grid:
        x0 = ofcolor(I, TWO)
        x1 = shape(I)
        x2 = multiply(x1, x1)
        x3 = canvas(ZERO, x2)
        x4 = rbind(multiply, x1)
        x5 = apply(x4, x0)
        x6 = asobject(I)
        x7 = lbind(shift, x6)
        x8 = mapply(x7, x5)
        x9 = paint(x3, x8)
        return x9

    def verify_cdecee7f(I: Grid) -> Grid:
        x0 = asobject(I)
        x1 = mostcolor(I)
        x2 = matcher(first, x1)
        x3 = compose(flip, x2)
        x4 = sfilter(x0, x3)
        x5 = apply(initset, x4)
        x6 = astuple(ONE, THREE)
        x7 = size(x5)
        x8 = order(x5, leftmost)
        x9 = apply(color, x8)
        x10 = rbind(canvas, UNITY)
        x11 = apply(x10, x9)
        x12 = merge(x11)
        x13 = dmirror(x12)
        x14 = subtract(NINE, x7)
        x15 = astuple(ONE, x14)
        x16 = mostcolor(I)
        x17 = canvas(x16, x15)
        x18 = hconcat(x13, x17)
        x19 = hsplit(x18, THREE)
        x20 = merge(x19)
        x21 = crop(x20, ORIGIN, x6)
        x22 = crop(x20, DOWN, x6)
        x23 = crop(x20, TWO_BY_ZERO, x6)
        x24 = vmirror(x22)
        x25 = vconcat(x21, x24)
        x26 = vconcat(x25, x23)
        return x26

    def verify_ce22a75a(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = apply(initset, x1)
        x3 = apply(outbox, x2)
        x4 = mapply(backdrop, x3)
        x5 = fill(I, ONE, x4)
        return x5

    def verify_ce4f8723(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = sfilter(x0, hline)
        x2 = size(x1)
        x3 = positive(x2)
        x4 = branch(x3, tophalf, lefthalf)
        x5 = branch(x3, bottomhalf, righthalf)
        x6 = x4(I)
        x7 = x5(I)
        x8 = palette(x6)
        x9 = palette(x7)
        x10 = intersection(x8, x9)
        x11 = first(x10)
        x12 = shape(x6)
        x13 = canvas(x11, x12)
        x14 = palette(x6)
        x15 = other(x14, x11)
        x16 = palette(x7)
        x17 = other(x16, x11)
        x18 = ofcolor(x6, x15)
        x19 = ofcolor(x7, x17)
        x20 = combine(x18, x19)
        x21 = fill(x13, THREE, x20)
        return x21

    def verify_ce602527(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = rbind(bordering, I)
        x2 = extract(x0, x1)
        x3 = remove(x2, x0)
        x4 = totuple(x3)
        x5 = first(x4)
        x6 = last(x4)
        x7 = color(x5)
        x8 = mostcolor(I)
        x9 = shape(x5)
        x10 = canvas(x8, x9)
        x11 = normalize(x5)
        x12 = paint(x10, x11)
        x13 = upscale(x12, TWO)
        x14 = shape(x6)
        x15 = canvas(x8, x14)
        x16 = normalize(x6)
        x17 = paint(x15, x16)
        x18 = upscale(x17, TWO)
        x19 = shape(x2)
        x20 = canvas(x8, x19)
        x21 = normalize(x2)
        x22 = paint(x20, x21)
        x23 = color(x2)
        x24 = replace(x22, x23, x7)
        x25 = asobject(x24)
        x26 = occurrences(x13, x25)
        x27 = size(x26)
        x28 = positive(x27)
        x29 = downscale(x13, TWO)
        x30 = downscale(x18, TWO)
        x31 = branch(x28, x29, x30)
        return x31

    def verify_ce9e57f2(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = asindices(I)
        x2 = outbox(x1)
        x3 = lbind(adjacent, x2)
        x4 = compose(x3, initset)
        x5 = rbind(extract, x4)
        x6 = compose(x5, toindices)
        x7 = rbind(compose, initset)
        x8 = lbind(rbind, manhattan)
        x9 = chain(x7, x8, initset)
        x10 = lbind(lbind, greater)
        x11 = chain(x10, halve, size)
        x12 = compose(x9, x6)
        x13 = fork(compose, x11, x12)
        x14 = fork(sfilter, toindices, x13)
        x15 = mapply(x14, x0)
        x16 = fill(I, EIGHT, x15)
        return x16

    def verify_cf98881b(I: Grid) -> Grid:
        x0 = width(I)
        x1 = increment(x0)
        x2 = divide(x1, THREE)
        x3 = decrement(x2)
        x4 = height(I)
        x5 = astuple(x4, x3)
        x6 = crop(I, ORIGIN, x5)
        x7 = add(x3, ONE)
        x8 = tojvec(x7)
        x9 = crop(I, x8, x5)
        x10 = double(x3)
        x11 = add(x10, TWO)
        x12 = tojvec(x11)
        x13 = crop(I, x12, x5)
        x14 = palette(x6)
        x15 = palette(x9)
        x16 = palette(x13)
        x17 = intersection(x14, x15)
        x18 = intersection(x17, x16)
        x19 = first(x18)
        x20 = other(x14, x19)
        x21 = other(x15, x19)
        x22 = other(x16, x19)
        x23 = canvas(x19, x5)
        x24 = ofcolor(x6, x20)
        x25 = ofcolor(x9, x21)
        x26 = ofcolor(x13, x22)
        x27 = fill(x23, x22, x26)
        x28 = fill(x27, x21, x25)
        x29 = fill(x28, x20, x24)
        return x29

    def verify_d037b0a7(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = rbind(shoot, DOWN)
        x3 = compose(x2, last)
        x4 = fork(recolor, first, x3)
        x5 = mapply(x4, x1)
        x6 = paint(I, x5)
        return x6

    def verify_d06dbe63(I: Grid) -> Grid:
        x0 = double(TEN)
        x1 = interval(ZERO, x0, ONE)
        x2 = connect(ORIGIN, DOWN)
        x3 = connect(ORIGIN, ZERO_BY_TWO)
        x4 = combine(x2, x3)
        x5 = astuple(NEG_TWO, TWO)
        x6 = lbind(multiply, x5)
        x7 = toivec(NEG_TWO)
        x8 = apply(x6, x1)
        x9 = rbind(subtract, TWO_BY_ZERO)
        x10 = fork(ofcolor, identity, leastcolor)
        x11 = chain(x9, center, x10)
        x12 = rbind(mapply, x8)
        x13 = lbind(lbind, shift)
        x14 = lbind(shift, x4)
        x15 = compose(x14, x11)
        x16 = chain(x12, x13, x15)
        x17 = lbind(recolor, FIVE)
        x18 = compose(x17, x16)
        x19 = fork(paint, identity, x18)
        x20 = compose(rot180, x19)
        x21 = fork(ofcolor, x20, leastcolor)
        x22 = compose(center, x21)
        x23 = fork(subtract, x22, x11)
        x24 = fork(shift, x16, x23)
        x25 = lbind(recolor, FIVE)
        x26 = rbind(shift, x7)
        x27 = chain(x25, x26, x24)
        x28 = fork(paint, x20, x27)
        x29 = compose(rot180, x28)
        x30 = rbind(ofcolor, FIVE)
        x31 = compose(x30, x29)
        x32 = leastcolor(I)
        x33 = ofcolor(I, x32)
        x34 = mostcolor(I)
        x35 = shape(I)
        x36 = canvas(x34, x35)
        x37 = lbind(paint, x36)
        x38 = lbind(recolor, x32)
        x39 = chain(x37, x38, initset)
        x40 = compose(x31, x39)
        x41 = mapply(x40, x33)
        x42 = fill(I, FIVE, x41)
        x43 = fill(x42, x32, x33)
        return x43

    def verify_d07ae81c(I: Grid) -> Grid:
        x0 = lbind(ofcolor, I)
        x1 = lbind(mapply, neighbors)
        x2 = compose(x1, x0)
        x3 = fork(intersection, x0, x2)
        x4 = compose(size, x3)
        x5 = palette(I)
        x6 = matcher(x4, ZERO)
        x7 = sfilter(x5, x6)
        x8 = totuple(x7)
        x9 = first(x8)
        x10 = last(x8)
        x11 = ofcolor(I, x9)
        x12 = mapply(neighbors, x11)
        x13 = toobject(x12, I)
        x14 = mostcolor(x13)
        x15 = ofcolor(I, x10)
        x16 = mapply(neighbors, x15)
        x17 = toobject(x16, I)
        x18 = mostcolor(x17)
        x19 = rbind(shoot, UNITY)
        x20 = rbind(shoot, NEG_UNITY)
        x21 = fork(combine, x19, x20)
        x22 = rbind(shoot, UP_RIGHT)
        x23 = rbind(shoot, DOWN_LEFT)
        x24 = fork(combine, x22, x23)
        x25 = fork(combine, x21, x24)
        x26 = ofcolor(I, x10)
        x27 = ofcolor(I, x9)
        x28 = combine(x26, x27)
        x29 = mapply(x25, x28)
        x30 = ofcolor(I, x14)
        x31 = intersection(x30, x29)
        x32 = ofcolor(I, x18)
        x33 = intersection(x32, x29)
        x34 = fill(I, x9, x31)
        x35 = fill(x34, x10, x33)
        return x35

    def verify_d0f5fe59(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = size(x0)
        x2 = astuple(x1, x1)
        x3 = mostcolor(I)
        x4 = canvas(x3, x2)
        x5 = shoot(ORIGIN, UNITY)
        x6 = leastcolor(I)
        x7 = fill(x4, x6, x5)
        return x7

    def verify_d10ecb37(I: Grid) -> Grid:
        x0 = crop(I, ORIGIN, TWO_BY_TWO)
        return x0

    def verify_d13f3404(I: Grid) -> Grid:
        x0 = asobject(I)
        x1 = mostcolor(I)
        x2 = matcher(first, x1)
        x3 = compose(flip, x2)
        x4 = sfilter(x0, x3)
        x5 = apply(initset, x4)
        x6 = rbind(shoot, UNITY)
        x7 = compose(x6, center)
        x8 = fork(recolor, color, x7)
        x9 = mapply(x8, x5)
        x10 = shape(I)
        x11 = double(x10)
        x12 = mostcolor(I)
        x13 = canvas(x12, x11)
        x14 = paint(x13, x9)
        return x14

    def verify_d22278a0(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = totuple(x0)
        x2 = apply(color, x1)
        x3 = repeat(NEG_ONE, ONE)
        x4 = combine(x2, x3)
        x5 = multiply(TEN, TEN)
        x6 = apply(center, x1)
        x7 = astuple(x5, x5)
        x8 = repeat(x7, ONE)
        x9 = combine(x6, x8)
        x10 = identity(I)
        x11 = asindices(I)
        x12 = shape(I)
        x13 = maximum(x12)
        x14 = halve(x13)
        x15 = add(TWO, x14)
        x16 = interval(ONE, x15, ONE)
        x17 = compose(outbox, outbox)
        x18 = lbind(power, x17)
        x19 = apply(x18, x16)
        x20 = lbind(rapply, x19)
        x21 = chain(merge, x20, initset)
        x22 = fork(combine, initset, x21)
        x23 = lbind(rbind, manhattan)
        x24 = rbind(chain, initset)
        x25 = rbind(x24, x23)
        x26 = lbind(rbind, apply)
        x27 = lbind(apply, initset)
        x28 = rbind(remove, x9)
        x29 = chain(x25, x26, x27)
        x30 = chain(x29, x28, last)
        x31 = lbind(sfilter, x11)
        x32 = rbind(compose, initset)
        x33 = lbind(compose, minimum)
        x34 = lbind(fork, greater)
        x35 = compose(x33, x30)
        x36 = compose(initset, last)
        x37 = chain(x32, x23, x36)
        x38 = fork(x34, x35, x37)
        x39 = compose(x31, x38)
        x40 = compose(x22, last)
        x41 = fork(intersection, x39, x40)
        x42 = fork(recolor, first, x41)
        x43 = pair(x4, x9)
        x44 = mapply(x42, x43)
        x45 = paint(x10, x44)
        return x45

    def verify_d23f8c26(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = matcher(first, x0)
        x2 = compose(flip, x1)
        x3 = width(I)
        x4 = halve(x3)
        x5 = compose(last, last)
        x6 = matcher(x5, x4)
        x7 = compose(flip, x6)
        x8 = asobject(I)
        x9 = fork(both, x2, x7)
        x10 = sfilter(x8, x9)
        x11 = fill(I, x0, x10)
        return x11

    def verify_d2abd087(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = matcher(size, SIX)
        x2 = compose(flip, x1)
        x3 = mfilter(x0, x1)
        x4 = mfilter(x0, x2)
        x5 = fill(I, TWO, x3)
        x6 = fill(x5, ONE, x4)
        return x6

    def verify_d364b489(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = toindices(x1)
        x3 = shift(x2, DOWN)
        x4 = fill(I, EIGHT, x3)
        x5 = shift(x2, UP)
        x6 = fill(x4, TWO, x5)
        x7 = shift(x2, RIGHT)
        x8 = fill(x6, SIX, x7)
        x9 = shift(x2, LEFT)
        x10 = fill(x8, SEVEN, x9)
        return x10

    def verify_d406998b(I: Grid) -> Grid:
        x0 = vmirror(I)
        x1 = fgpartition(x0)
        x2 = merge(x1)
        x3 = toindices(x2)
        x4 = compose(double, halve)
        x5 = fork(equality, identity, x4)
        x6 = compose(x5, last)
        x7 = sfilter(x3, x6)
        x8 = fill(x0, THREE, x7)
        x9 = vmirror(x8)
        return x9

    def verify_d43fd935(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = asobject(I)
        x2 = matcher(first, x0)
        x3 = compose(flip, x2)
        x4 = sfilter(x1, x3)
        x5 = partition(I)
        x6 = fork(multiply, height, width)
        x7 = fork(equality, size, x6)
        x8 = sfilter(x5, x7)
        x9 = argmax(x8, size)
        x10 = difference(x4, x9)
        x11 = apply(initset, x10)
        x12 = rbind(hmatching, x9)
        x13 = rbind(vmatching, x9)
        x14 = fork(either, x12, x13)
        x15 = sfilter(x11, x14)
        x16 = rbind(gravitate, x9)
        x17 = fork(add, center, x16)
        x18 = fork(connect, center, x17)
        x19 = fork(recolor, color, x18)
        x20 = mapply(x19, x15)
        x21 = paint(I, x20)
        return x21

    def verify_d4469b4b(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = contained(ONE, x0)
        x2 = contained(TWO, x0)
        x3 = branch(x1, UNITY, TWO_BY_TWO)
        x4 = branch(x2, RIGHT, x3)
        x5 = fork(combine, vfrontier, hfrontier)
        x6 = x5(x4)
        x7 = canvas(ZERO, THREE_BY_THREE)
        x8 = fill(x7, FIVE, x6)
        return x8

    def verify_d4a91cb9(I: Grid) -> Grid:
        x0 = ofcolor(I, EIGHT)
        x1 = ofcolor(I, TWO)
        x2 = first(x0)
        x3 = first(x1)
        x4 = last(x2)
        x5 = first(x3)
        x6 = astuple(x5, x4)
        x7 = connect(x6, x2)
        x8 = connect(x6, x3)
        x9 = combine(x7, x8)
        x10 = underfill(I, FOUR, x9)
        return x10

    def verify_d4f3cd78(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = toindices(x1)
        x3 = box(x2)
        x4 = difference(x3, x2)
        x5 = inbox(x2)
        x6 = backdrop(x5)
        x7 = lbind(position, x6)
        x8 = compose(x7, initset)
        x9 = lowermost(x6)
        x10 = rightmost(x6)
        x11 = uppermost(x6)
        x12 = leftmost(x6)
        x13 = rbind(greater, x9)
        x14 = compose(x13, first)
        x15 = lbind(greater, x11)
        x16 = compose(x15, first)
        x17 = rbind(greater, x10)
        x18 = compose(x17, last)
        x19 = lbind(greater, x12)
        x20 = compose(x19, last)
        x21 = compose(invert, x16)
        x22 = fork(add, x14, x21)
        x23 = compose(invert, x20)
        x24 = fork(add, x18, x23)
        x25 = fork(astuple, x22, x24)
        x26 = fork(shoot, identity, x25)
        x27 = mapply(x26, x4)
        x28 = combine(x27, x6)
        x29 = fill(I, EIGHT, x28)
        return x29

    def verify_d511f180(I: Grid) -> Grid:
        x0 = switch(I, FIVE, EIGHT)
        return x0

    def verify_d5d6de2d(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = merge(x0)
        x2 = cover(I, x1)
        x3 = mapply(delta, x0)
        x4 = fill(x2, THREE, x3)
        return x4

    def verify_d631b094(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = other(x0, ZERO)
        x2 = colorcount(I, x1)
        x3 = astuple(ONE, x2)
        x4 = canvas(x1, x3)
        return x4

    def verify_d687bc17(I: Grid) -> Grid:
        x0 = trim(I)
        x1 = asobject(x0)
        x2 = shift(x1, UNITY)
        x3 = apply(initset, x2)
        x4 = toindices(x2)
        x5 = asindices(I)
        x6 = corners(x5)
        x7 = combine(x4, x6)
        x8 = fill(I, NEG_ONE, x7)
        x9 = fgpartition(x8)
        x10 = asindices(I)
        x11 = corners(x10)
        x12 = toobject(x11, I)
        x13 = combine(x2, x12)
        x14 = mostcolor(x13)
        x15 = fill(x8, x14, x7)
        x16 = apply(color, x9)
        x17 = rbind(contained, x16)
        x18 = compose(x17, color)
        x19 = sfilter(x3, x18)
        x20 = lbind(colorfilter, x9)
        x21 = chain(first, x20, color)
        x22 = fork(gravitate, identity, x21)
        x23 = fork(shift, identity, x22)
        x24 = mapply(x23, x19)
        x25 = paint(x15, x24)
        return x25

    def verify_d6ad076f(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = product(x0, x0)
        x2 = fork(equality, first, last)
        x3 = compose(flip, x2)
        x4 = sfilter(x1, x3)
        x5 = fork(adjacent, first, last)
        x6 = compose(flip, x5)
        x7 = extract(x4, x6)
        x8 = totuple(x7)
        x9 = first(x8)
        x10 = last(x8)
        x11 = combine(x9, x10)
        x12 = leftmost(x11)
        x13 = increment(x12)
        x14 = rightmost(x11)
        x15 = decrement(x14)
        x16 = apply(uppermost, x8)
        x17 = maximum(x16)
        x18 = increment(x17)
        x19 = apply(lowermost, x8)
        x20 = minimum(x19)
        x21 = decrement(x20)
        x22 = apply(leftmost, x8)
        x23 = maximum(x22)
        x24 = increment(x23)
        x25 = apply(rightmost, x8)
        x26 = minimum(x25)
        x27 = decrement(x26)
        x28 = uppermost(x11)
        x29 = increment(x28)
        x30 = lowermost(x11)
        x31 = decrement(x30)
        x32 = hmatching(x9, x10)
        x33 = branch(x32, x13, x24)
        x34 = branch(x32, x15, x27)
        x35 = branch(x32, x21, x31)
        x36 = branch(x32, x18, x29)
        x37 = astuple(x35, x34)
        x38 = astuple(x36, x33)
        x39 = initset(x38)
        x40 = insert(x37, x39)
        x41 = backdrop(x40)
        x42 = merge(x7)
        x43 = toindices(x42)
        x44 = rbind(contained, x43)
        x45 = compose(flip, x44)
        x46 = sfilter(x41, x45)
        x47 = fill(I, EIGHT, x46)
        return x47

    def verify_d89b689b(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = sfilter(x0, square)
        x2 = argmax(x1, size)
        x3 = toindices(x2)
        x4 = sizefilter(x1, ONE)
        x5 = apply(initset, x3)
        x6 = lbind(argmin, x5)
        x7 = lbind(rbind, manhattan)
        x8 = compose(x6, x7)
        x9 = fork(recolor, color, x8)
        x10 = mapply(x9, x4)
        x11 = merge(x4)
        x12 = cover(I, x11)
        x13 = paint(x12, x10)
        return x13

    def verify_d8c310e9(I: Grid) -> Grid:
        x0 = astuple(identity, rot90)
        x1 = astuple(rot180, rot270)
        x2 = combine(x0, x1)
        x3 = astuple(identity, rot270)
        x4 = astuple(rot180, rot90)
        x5 = combine(x3, x4)
        x6 = pair(x2, x5)
        x7 = chain(size, dedupe, first)
        x8 = matcher(x7, ONE)
        x9 = compose(first, cmirror)
        x10 = chain(size, dedupe, x9)
        x11 = matcher(x10, ONE)
        x12 = fork(both, x8, x11)
        x13 = rbind(rapply, I)
        x14 = compose(initset, first)
        x15 = chain(first, x13, x14)
        x16 = compose(x12, x15)
        x17 = extract(x6, x16)
        x18 = first(x17)
        x19 = last(x17)
        x20 = x18(I)
        x21 = width(x20)
        x22 = decrement(x21)
        x23 = tojvec(x22)
        x24 = index(x20, x23)
        x25 = asobject(x20)
        x26 = matcher(first, x24)
        x27 = compose(flip, x26)
        x28 = sfilter(x25, x27)
        x29 = hperiod(x28)
        x30 = width(x20)
        x31 = increment(x30)
        x32 = interval(ZERO, x31, x29)
        x33 = apply(tojvec, x32)
        x34 = lbind(shift, x28)
        x35 = mapply(x34, x33)
        x36 = paint(x20, x35)
        x37 = x19(x36)
        return x37

    def verify_d90796e8(I: Grid) -> Grid:
        x0 = ofcolor(I, TWO)
        x1 = ofcolor(I, THREE)
        x2 = compose(positive, size)
        x3 = lbind(intersection, x1)
        x4 = chain(x2, x3, dneighbors)
        x5 = compose(positive, size)
        x6 = lbind(intersection, x0)
        x7 = chain(x5, x6, dneighbors)
        x8 = sfilter(x0, x4)
        x9 = sfilter(x1, x7)
        x10 = cover(I, x8)
        x11 = fill(x10, EIGHT, x9)
        return x11

    def verify_d9f24cd1(I: Grid) -> Grid:
        x0 = astuple(identity, identity)
        x1 = astuple(rot90, rot270)
        x2 = astuple(x0, x1)
        x3 = astuple(rot180, rot180)
        x4 = astuple(rot270, rot90)
        x5 = astuple(x3, x4)
        x6 = combine(x2, x5)
        x7 = rbind(greater, ONE)
        x8 = chain(size, dedupe, last)
        x9 = compose(x7, x8)
        x10 = rbind(rapply, I)
        x11 = compose(initset, first)
        x12 = chain(first, x10, x11)
        x13 = compose(x9, x12)
        x14 = extract(x6, x13)
        x15 = first(x14)
        x16 = last(x14)
        x17 = x15(I)
        x18 = mostcolor(I)
        x19 = trim(I)
        x20 = palette(x19)
        x21 = other(x20, x18)
        x22 = asindices(I)
        x23 = box(x22)
        x24 = toobject(x23, I)
        x25 = palette(x24)
        x26 = other(x25, x18)
        x27 = ofcolor(x17, x26)
        x28 = ofcolor(x17, x21)
        x29 = prapply(connect, x27, x28)
        x30 = mfilter(x29, vline)
        x31 = underfill(x17, x26, x30)
        x32 = matcher(numcolors, TWO)
        x33 = objects(x31, F, F, T)
        x34 = sfilter(x33, x32)
        x35 = difference(x33, x34)
        x36 = colorfilter(x35, x26)
        x37 = mapply(toindices, x36)
        x38 = apply(urcorner, x34)
        x39 = shift(x38, UNITY)
        x40 = rbind(shoot, UP)
        x41 = mapply(x40, x39)
        x42 = fill(x31, x26, x41)
        x43 = mapply(vfrontier, x37)
        x44 = fill(x42, x26, x43)
        x45 = x16(x44)
        return x45

    def verify_d9fac9be(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = palette(I)
        x2 = remove(x0, x1)
        x3 = totuple(x2)
        x4 = first(x3)
        x5 = last(x3)
        x6 = neighbors(UNITY)
        x7 = initset(UNITY)
        x8 = recolor(x4, x6)
        x9 = recolor(x5, x7)
        x10 = combine(x8, x9)
        x11 = occurrences(I, x10)
        x12 = size(x11)
        x13 = positive(x12)
        x14 = branch(x13, x5, x4)
        x15 = canvas(x14, UNITY)
        return x15

    def verify_dae9d2b5(I: Grid) -> Grid:
        x0 = hsplit(I, TWO)
        x1 = apply(numcolors, x0)
        x2 = equality(x1, TWO_BY_TWO)
        x3 = branch(x2, hsplit, vsplit)
        x4 = x3(I, TWO)
        x5 = first(x4)
        x6 = last(x4)
        x7 = palette(x5)
        x8 = palette(x6)
        x9 = intersection(x7, x8)
        x10 = first(x9)
        x11 = palette(x5)
        x12 = other(x11, x10)
        x13 = palette(x6)
        x14 = other(x13, x10)
        x15 = shape(x5)
        x16 = canvas(x10, x15)
        x17 = ofcolor(x5, x12)
        x18 = ofcolor(x6, x14)
        x19 = combine(x17, x18)
        x20 = fill(x16, SIX, x19)
        return x20

    def verify_db3e9e38(I: Grid) -> Grid:
        x0 = astuple(identity, dmirror)
        x1 = astuple(cmirror, hmirror)
        x2 = combine(x0, x1)
        x3 = chain(uppermost, merge, fgpartition)
        x4 = rbind(rapply, I)
        x5 = chain(first, x4, initset)
        x6 = compose(x3, x5)
        x7 = matcher(x6, ZERO)
        x8 = extract(x2, x7)
        x9 = x8(I)
        x10 = fgpartition(x9)
        x11 = merge(x10)
        x12 = width(x11)
        x13 = astuple(NEG_ONE, x12)
        x14 = invert(x12)
        x15 = astuple(NEG_ONE, x14)
        x16 = double(x12)
        x17 = astuple(NEG_TWO, x16)
        x18 = double(x12)
        x19 = invert(x18)
        x20 = astuple(NEG_TWO, x19)
        x21 = multiply(THREE, TEN)
        x22 = interval(ZERO, x21, ONE)
        x23 = lbind(multiply, x13)
        x24 = apply(x23, x22)
        x25 = lbind(multiply, x15)
        x26 = apply(x25, x22)
        x27 = lbind(multiply, x17)
        x28 = apply(x27, x22)
        x29 = lbind(multiply, x20)
        x30 = apply(x29, x22)
        x31 = lbind(shift, x11)
        x32 = mapply(x31, x24)
        x33 = lbind(shift, x11)
        x34 = mapply(x33, x26)
        x35 = lbind(shift, x11)
        x36 = mapply(x35, x28)
        x37 = lbind(shift, x11)
        x38 = mapply(x37, x30)
        x39 = combine(x32, x34)
        x40 = fill(x9, EIGHT, x39)
        x41 = combine(x36, x38)
        x42 = paint(x40, x41)
        x43 = x8(x42)
        return x43

    def verify_db93a21d(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = merge(x0)
        x2 = toindices(x1)
        x3 = rbind(shoot, DOWN)
        x4 = mapply(x3, x2)
        x5 = underfill(I, ONE, x4)
        x6 = lbind(power, outbox)
        x7 = chain(x6, halve, width)
        x8 = initset(x7)
        x9 = lbind(rapply, x8)
        x10 = fork(rapply, x9, identity)
        x11 = compose(first, x10)
        x12 = compose(backdrop, x11)
        x13 = fork(difference, x12, toindices)
        x14 = mapply(x13, x0)
        x15 = mostcolor(I)
        x16 = ofcolor(I, x15)
        x17 = intersection(x14, x16)
        x18 = fill(x5, THREE, x17)
        return x18

    def verify_dbc1a6ce(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = lbind(recolor, EIGHT)
        x3 = rbind(ofcolor, x0)
        x4 = chain(x2, backdrop, x3)
        x5 = fork(paint, identity, x4)
        x6 = height(I)
        x7 = vsplit(I, x6)
        x8 = mapply(x5, x7)
        x9 = ofcolor(x8, EIGHT)
        x10 = dmirror(I)
        x11 = width(I)
        x12 = vsplit(x10, x11)
        x13 = mapply(x5, x12)
        x14 = dmirror(x13)
        x15 = ofcolor(x14, EIGHT)
        x16 = combine(x9, x15)
        x17 = difference(x16, x1)
        x18 = fill(I, EIGHT, x17)
        return x18

    def verify_dc0a314f(I: Grid) -> Grid:
        x0 = replace(I, THREE, NEG_ONE)
        x1 = dmirror(x0)
        x2 = papply(pair, x0, x1)
        x3 = lbind(apply, maximum)
        x4 = apply(x3, x2)
        x5 = cmirror(x4)
        x6 = papply(pair, x4, x5)
        x7 = apply(x3, x6)
        x8 = hmirror(x7)
        x9 = papply(pair, x7, x8)
        x10 = apply(x3, x9)
        x11 = vmirror(x10)
        x12 = papply(pair, x11, x10)
        x13 = apply(x3, x12)
        x14 = ofcolor(I, THREE)
        x15 = subgrid(x14, x13)
        return x15

    def verify_dc1df850(I: Grid) -> Grid:
        x0 = ofcolor(I, TWO)
        x1 = mapply(neighbors, x0)
        x2 = underfill(I, ONE, x1)
        return x2

    def verify_dc433765(I: Grid) -> Grid:
        x0 = mostcolor(I)
        x1 = palette(I)
        x2 = remove(x0, x1)
        x3 = other(x2, FOUR)
        x4 = ofcolor(I, x3)
        x5 = ofcolor(I, FOUR)
        x6 = center(x4)
        x7 = center(x5)
        x8 = subtract(x7, x6)
        x9 = sign(x8)
        x10 = recolor(x3, x4)
        x11 = move(I, x10, x9)
        return x11

    def verify_ddf7fa4f(I: Grid) -> Grid:
        x0 = width(I)
        x1 = decrement(x0)
        x2 = tojvec(x1)
        x3 = connect(ORIGIN, x2)
        x4 = height(I)
        x5 = decrement(x4)
        x6 = toivec(x5)
        x7 = connect(ORIGIN, x6)
        x8 = width(I)
        x9 = decrement(x8)
        x10 = tojvec(x9)
        x11 = shape(I)
        x12 = decrement(x11)
        x13 = connect(x10, x12)
        x14 = height(I)
        x15 = decrement(x14)
        x16 = toivec(x15)
        x17 = shape(I)
        x18 = decrement(x17)
        x19 = connect(x16, x18)
        x20 = asindices(I)
        x21 = box(x20)
        x22 = toobject(x21, I)
        x23 = mostcolor(x22)
        x24 = matcher(color, x23)
        x25 = compose(flip, x24)
        x26 = rbind(sfilter, x25)
        x27 = rbind(sizefilter, ONE)
        x28 = rbind(objects, F)
        x29 = rbind(x28, F)
        x30 = rbind(x29, T)
        x31 = rbind(subgrid, I)
        x32 = chain(x26, x30, x31)
        x33 = chain(size, x27, x32)
        x34 = astuple(x3, x7)
        x35 = astuple(x13, x19)
        x36 = combine(x34, x35)
        x37 = argmax(x36, x33)
        x38 = rbind(toobject, I)
        x39 = compose(x38, initset)
        x40 = ofcolor(I, x23)
        x41 = difference(x37, x40)
        x42 = apply(x39, x41)
        x43 = rbind(intersection, x37)
        x44 = chain(size, x43, toindices)
        x45 = matcher(x44, ZERO)
        x46 = objects(I, T, F, T)
        x47 = sfilter(x46, x45)
        x48 = lbind(fork, either)
        x49 = lbind(lbind, hmatching)
        x50 = lbind(lbind, vmatching)
        x51 = fork(x48, x49, x50)
        x52 = lbind(chain, size)
        x53 = rbind(x52, x51)
        x54 = lbind(lbind, sfilter)
        x55 = compose(last, last)
        x56 = chain(x53, x54, x55)
        x57 = rbind(compose, x51)
        x58 = lbind(lbind, extract)
        x59 = compose(last, last)
        x60 = chain(x57, x58, x59)
        x61 = compose(first, last)
        x62 = rbind(matcher, ONE)
        x63 = compose(x62, x56)
        x64 = fork(sfilter, x61, x63)
        x65 = lbind(fork, recolor)
        x66 = lbind(x65, color)
        x67 = compose(x66, x60)
        x68 = fork(mapply, x67, x64)
        x69 = fork(combine, first, x68)
        x70 = compose(first, last)
        x71 = fork(difference, x70, x64)
        x72 = compose(last, last)
        x73 = fork(apply, x60, x64)
        x74 = fork(difference, x72, x73)
        x75 = fork(astuple, x71, x74)
        x76 = fork(astuple, x69, x75)
        x77 = difference(x42, x42)
        x78 = power(x76, TEN)
        x79 = astuple(x42, x47)
        x80 = astuple(x77, x79)
        x81 = x78(x80)
        x82 = first(x81)
        x83 = paint(I, x82)
        return x83

    def verify_de1cd16c(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = totuple(x0)
        x2 = apply(color, x1)
        x3 = size(x2)
        x4 = dedupe(x2)
        x5 = size(x4)
        x6 = equality(x3, x5)
        x7 = compose(leastcolor, merge)
        x8 = lbind(apply, color)
        x9 = chain(mostcommon, x8, totuple)
        x10 = branch(x6, x7, x9)
        x11 = x10(x0)
        x12 = objects(I, T, F, F)
        x13 = colorfilter(x12, x11)
        x14 = difference(x12, x13)
        x15 = rbind(subgrid, I)
        x16 = apply(x15, x14)
        x17 = rbind(colorcount, x11)
        x18 = argmax(x16, x17)
        x19 = mostcolor(x18)
        x20 = canvas(x19, UNITY)
        return x20

    def verify_ded97339(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = lbind(recolor, NEG_ONE)
        x2 = rbind(ofcolor, x0)
        x3 = chain(x1, backdrop, x2)
        x4 = fork(paint, identity, x3)
        x5 = height(I)
        x6 = vsplit(I, x5)
        x7 = mapply(x4, x6)
        x8 = ofcolor(x7, NEG_ONE)
        x9 = dmirror(I)
        x10 = width(I)
        x11 = vsplit(x9, x10)
        x12 = mapply(x4, x11)
        x13 = dmirror(x12)
        x14 = ofcolor(x13, NEG_ONE)
        x15 = combine(x8, x14)
        x16 = fill(I, x0, x15)
        return x16

    def verify_e179c5f4(I: Grid) -> Grid:
        x0 = portrait(I)
        x1 = branch(x0, identity, dmirror)
        x2 = x1(I)
        x3 = asindices(x2)
        x4 = shoot(ORIGIN, UNITY)
        x5 = intersection(x4, x3)
        x6 = lrcorner(x5)
        x7 = shoot(x6, DOWN_LEFT)
        x8 = intersection(x7, x3)
        x9 = combine(x5, x8)
        x10 = llcorner(x9)
        x11 = remove(x10, x9)
        x12 = lbind(shift, x11)
        x13 = height(x11)
        x14 = lbind(multiply, x13)
        x15 = chain(x12, toivec, x14)
        x16 = height(x2)
        x17 = height(x11)
        x18 = divide(x16, x17)
        x19 = increment(x18)
        x20 = interval(ZERO, x19, ONE)
        x21 = mapply(x15, x20)
        x22 = rbind(contained, x21)
        x23 = sfilter(x3, x22)
        x24 = asindices(I)
        x25 = corners(x24)
        x26 = difference(x24, x25)
        x27 = toobject(x26, I)
        x28 = mostcolor(x27)
        x29 = palette(I)
        x30 = other(x29, x28)
        x31 = ulcorner(x3)
        x32 = index(x2, x31)
        x33 = equality(x32, x30)
        x34 = urcorner(x3)
        x35 = index(x2, x34)
        x36 = equality(x35, x30)
        x37 = llcorner(x3)
        x38 = index(x2, x37)
        x39 = equality(x38, x30)
        x40 = lrcorner(x3)
        x41 = index(x2, x40)
        x42 = equality(x41, x30)
        x43 = astuple(x33, x36)
        x44 = astuple(x39, x42)
        x45 = combine(x43, x44)
        x46 = vmirror(x23)
        x47 = astuple(x23, x46)
        x48 = hmirror(x23)
        x49 = hmirror(x46)
        x50 = astuple(x48, x49)
        x51 = combine(x47, x50)
        x52 = pair(x45, x51)
        x53 = sfilter(x52, first)
        x54 = mapply(last, x53)
        x55 = fill(x2, x30, x54)
        x56 = x1(x55)
        x57 = replace(x56, x28, EIGHT)
        return x57

    def verify_e21d9049(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = compose(first, last)
        x3 = totuple(x1)
        x4 = apply(x2, x3)
        x5 = mostcommon(x4)
        x6 = compose(last, last)
        x7 = totuple(x1)
        x8 = apply(x6, x7)
        x9 = mostcommon(x8)
        x10 = compose(first, last)
        x11 = matcher(x10, x5)
        x12 = sfilter(x1, x11)
        x13 = compose(last, last)
        x14 = matcher(x13, x9)
        x15 = sfilter(x1, x14)
        x16 = objects(I, F, T, T)
        x17 = size(x16)
        x18 = equality(x17, TWO)
        x19 = mfilter(x16, hline)
        x20 = mfilter(x16, vline)
        x21 = branch(x18, x19, x12)
        x22 = branch(x18, x20, x15)
        x23 = width(x21)
        x24 = lbind(multiply, x23)
        x25 = width(I)
        x26 = divide(x25, x23)
        x27 = increment(x26)
        x28 = interval(ZERO, x27, ONE)
        x29 = apply(x24, x28)
        x30 = apply(invert, x29)
        x31 = combine(x29, x30)
        x32 = apply(tojvec, x31)
        x33 = lbind(shift, x21)
        x34 = mapply(x33, x32)
        x35 = height(x22)
        x36 = lbind(multiply, x35)
        x37 = height(I)
        x38 = height(x21)
        x39 = divide(x37, x38)
        x40 = increment(x39)
        x41 = interval(ZERO, x40, ONE)
        x42 = apply(x36, x41)
        x43 = apply(invert, x42)
        x44 = combine(x42, x43)
        x45 = apply(toivec, x44)
        x46 = lbind(shift, x22)
        x47 = mapply(x46, x45)
        x48 = combine(x34, x47)
        x49 = paint(I, x48)
        return x49

    def verify_e26a3af2(I: Grid) -> Grid:
        x0 = rot90(I)
        x1 = apply(mostcommon, I)
        x2 = apply(mostcommon, x0)
        x3 = repeat(x1, ONE)
        x4 = repeat(x2, ONE)
        x5 = compose(size, dedupe)
        x6 = x5(x1)
        x7 = x5(x2)
        x8 = greater(x7, x6)
        x9 = branch(x8, height, width)
        x10 = x9(I)
        x11 = rot90(x3)
        x12 = branch(x8, x4, x11)
        x13 = branch(x8, vupscale, hupscale)
        x14 = x13(x12, x10)
        return x14

    def verify_e3497940(I: Grid) -> Grid:
        x0 = lefthalf(I)
        x1 = righthalf(I)
        x2 = vmirror(x1)
        x3 = width(I)
        x4 = hsplit(I, x3)
        x5 = first(x4)
        x6 = mostcolor(x5)
        x7 = objects(x2, T, F, F)
        x8 = matcher(color, x6)
        x9 = compose(flip, x8)
        x10 = sfilter(x7, x9)
        x11 = merge(x10)
        x12 = paint(x0, x11)
        return x12

    def verify_e40b9e2f(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = mostcolor(I)
        x3 = uppermost(x1)
        x4 = leftmost(x1)
        x5 = height(x1)
        x6 = width(x1)
        x7 = interval(SEVEN, ONE, NEG_ONE)
        x8 = add(x3, x5)
        x9 = increment(x8)
        x10 = lbind(subtract, x9)
        x11 = add(x4, x6)
        x12 = increment(x11)
        x13 = lbind(subtract, x12)
        x14 = lbind(interval, x3)
        x15 = rbind(x14, ONE)
        x16 = compose(x15, x10)
        x17 = lbind(interval, x4)
        x18 = rbind(x17, ONE)
        x19 = compose(x18, x13)
        x20 = fork(product, x16, x19)
        x21 = fork(equality, identity, rot90)
        x22 = fork(equality, identity, rot180)
        x23 = fork(equality, identity, rot270)
        x24 = fork(both, x22, x23)
        x25 = fork(both, x21, x24)
        x26 = fork(astuple, identity, identity)
        x27 = fork(multiply, identity, identity)
        x28 = compose(decrement, x27)
        x29 = initset(ORIGIN)
        x30 = difference(x29, x29)
        x31 = rbind(branch, x30)
        x32 = rbind(colorcount, x2)
        x33 = rbind(subgrid, I)
        x34 = lbind(compose, backdrop)
        x35 = lbind(fork, insert)
        x36 = lbind(x35, identity)
        x37 = lbind(compose, initset)
        x38 = chain(x34, x36, x37)
        x39 = lbind(rbind, add)
        x40 = chain(x38, x39, decrement)
        x41 = lbind(fork, x31)
        x42 = lbind(fork, both)
        x43 = lbind(x42, x25)
        x44 = rbind(compose, shape)
        x45 = compose(x43, x44)
        x46 = rbind(compose, x32)
        x47 = lbind(lbind, greater)
        x48 = chain(x46, x47, x28)
        x49 = lbind(rbind, equality)
        x50 = chain(x45, x49, x26)
        x51 = fork(x42, x48, x50)
        x52 = lbind(compose, x33)
        x53 = compose(x52, x40)
        x54 = fork(compose, x51, x53)
        x55 = lbind(compose, initset)
        x56 = lbind(rbind, astuple)
        x57 = compose(x55, x56)
        x58 = fork(x41, x54, x57)
        x59 = fork(mapply, x58, x20)
        x60 = center(x1)
        x61 = astuple(x60, ONE)
        x62 = repeat(x61, ONE)
        x63 = mapply(x59, x7)
        x64 = combine(x62, x63)
        x65 = valmax(x64, last)
        x66 = matcher(last, x65)
        x67 = sfilter(x64, x66)
        x68 = center(x1)
        x69 = initset(x68)
        x70 = rbind(manhattan, x69)
        x71 = compose(halve, last)
        x72 = fork(add, first, x71)
        x73 = compose(initset, x72)
        x74 = compose(x70, x73)
        x75 = argmin(x67, x74)
        x76 = first(x75)
        x77 = last(x75)
        x78 = decrement(x77)
        x79 = add(x76, x78)
        x80 = initset(x79)
        x81 = insert(x76, x80)
        x82 = backdrop(x81)
        x83 = subgrid(x82, I)
        x84 = asobject(x83)
        x85 = rot90(I)
        x86 = fgpartition(x85)
        x87 = merge(x86)
        x88 = rot180(I)
        x89 = fgpartition(x88)
        x90 = merge(x89)
        x91 = rot270(I)
        x92 = fgpartition(x91)
        x93 = merge(x92)
        x94 = rot90(I)
        x95 = occurrences(x94, x84)
        x96 = first(x95)
        x97 = invert(x96)
        x98 = shift(x87, x97)
        x99 = shift(x98, x76)
        x100 = rot180(I)
        x101 = occurrences(x100, x84)
        x102 = first(x101)
        x103 = invert(x102)
        x104 = shift(x90, x103)
        x105 = shift(x104, x76)
        x106 = rot270(I)
        x107 = occurrences(x106, x84)
        x108 = first(x107)
        x109 = invert(x108)
        x110 = shift(x93, x109)
        x111 = shift(x110, x76)
        x112 = combine(x99, x105)
        x113 = combine(x112, x111)
        x114 = paint(I, x113)
        return x114

    def verify_e48d4e1a(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = merge(x0)
        x2 = color(x1)
        x3 = asobject(I)
        x4 = difference(x3, x1)
        x5 = leastcolor(x4)
        x6 = colorcount(I, x5)
        x7 = mostcolor(x4)
        x8 = ofcolor(I, x5)
        x9 = toindices(x1)
        x10 = combine(x9, x8)
        x11 = fill(I, x7, x10)
        x12 = argmax(x0, width)
        x13 = uppermost(x12)
        x14 = argmax(x0, height)
        x15 = leftmost(x14)
        x16 = astuple(x13, x15)
        x17 = initset(x16)
        x18 = position(x8, x17)
        x19 = multiply(x18, x6)
        x20 = add(x16, x19)
        x21 = hfrontier(x20)
        x22 = vfrontier(x20)
        x23 = combine(x21, x22)
        x24 = fill(x11, x2, x23)
        return x24

    def verify_e5062a87(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = ofcolor(I, x0)
        x2 = recolor(ZERO, x1)
        x3 = normalize(x2)
        x4 = occurrences(I, x3)
        x5 = toindices(x3)
        x6 = lbind(shift, x5)
        x7 = mapply(x6, x4)
        x8 = fill(I, x0, x7)
        return x8

    def verify_e509e548(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = fork(add, height, width)
        x2 = compose(decrement, x1)
        x3 = fork(equality, size, x2)
        x4 = fork(difference, toindices, box)
        x5 = compose(size, x4)
        x6 = matcher(x5, ZERO)
        x7 = sfilter(x0, x3)
        x8 = difference(x0, x7)
        x9 = sfilter(x8, x6)
        x10 = merge(x0)
        x11 = fill(I, TWO, x10)
        x12 = merge(x7)
        x13 = fill(x11, ONE, x12)
        x14 = merge(x9)
        x15 = fill(x13, SIX, x14)
        return x15

    def verify_e50d258f(I: Grid) -> Grid:
        x0 = asindices(I)
        x1 = box(x0)
        x2 = toobject(x1, I)
        x3 = mostcolor(x2)
        x4 = shape(I)
        x5 = canvas(x3, x4)
        x6 = hconcat(I, x5)
        x7 = objects(x6, F, F, T)
        x8 = rbind(colorcount, TWO)
        x9 = argmax(x7, x8)
        x10 = subgrid(x9, I)
        return x10

    def verify_e6721834(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = sfilter(x0, hline)
        x2 = size(x1)
        x3 = sfilter(x0, vline)
        x4 = size(x3)
        x5 = greater(x2, x4)
        x6 = branch(x5, vsplit, hsplit)
        x7 = x6(I, TWO)
        x8 = order(x7, numcolors)
        x9 = first(x8)
        x10 = last(x8)
        x11 = objects(x10, F, F, T)
        x12 = merge(x11)
        x13 = mostcolor(x12)
        x14 = matcher(first, x13)
        x15 = compose(flip, x14)
        x16 = rbind(sfilter, x15)
        x17 = mostcolor(x9)
        x18 = lbind(recolor, x17)
        x19 = rbind(sfilter, x14)
        x20 = compose(toindices, x19)
        x21 = fork(combine, x20, outbox)
        x22 = compose(x18, x21)
        x23 = fork(combine, x16, x22)
        x24 = shape(x9)
        x25 = add(TWO, x24)
        x26 = canvas(x17, x25)
        x27 = asobject(x9)
        x28 = shift(x27, UNITY)
        x29 = paint(x26, x28)
        x30 = rbind(shift, NEG_UNITY)
        x31 = lbind(occurrences, x29)
        x32 = compose(x30, x31)
        x33 = compose(x32, x23)
        x34 = chain(positive, size, x33)
        x35 = sfilter(x11, x34)
        x36 = chain(first, x32, x23)
        x37 = compose(ulcorner, x23)
        x38 = fork(subtract, x36, x37)
        x39 = fork(shift, identity, x38)
        x40 = mapply(x39, x35)
        x41 = paint(x9, x40)
        return x41

    def verify_e73095fd(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = mostcolor(I)
        x2 = colorfilter(x0, x1)
        x3 = fork(equality, toindices, backdrop)
        x4 = sfilter(x2, x3)
        x5 = lbind(mapply, dneighbors)
        x6 = chain(x5, corners, outbox)
        x7 = fork(difference, x6, outbox)
        x8 = leastcolor(I)
        x9 = ofcolor(I, x8)
        x10 = rbind(intersection, x9)
        x11 = matcher(size, ZERO)
        x12 = chain(x11, x10, x7)
        x13 = mfilter(x4, x12)
        x14 = fill(I, FOUR, x13)
        return x14

    def verify_e76a88a6(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = argmax(x0, numcolors)
        x2 = normalize(x1)
        x3 = remove(x1, x0)
        x4 = apply(ulcorner, x3)
        x5 = lbind(shift, x2)
        x6 = mapply(x5, x4)
        x7 = paint(I, x6)
        return x7

    def verify_e8593010(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = sizefilter(x0, ONE)
        x2 = sizefilter(x0, TWO)
        x3 = sizefilter(x0, THREE)
        x4 = merge(x1)
        x5 = fill(I, THREE, x4)
        x6 = merge(x2)
        x7 = fill(x5, TWO, x6)
        x8 = merge(x3)
        x9 = fill(x7, ONE, x8)
        return x9

    def verify_e8dc4411(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = argmax(x0, size)
        x2 = other(x0, x1)
        x3 = ineighbors(ORIGIN)
        x4 = height(x1)
        x5 = increment(x4)
        x6 = interval(ZERO, x5, ONE)
        x7 = lbind(intersection, x1)
        x8 = chain(positive, size, x7)
        x9 = lbind(shift, x1)
        x10 = rbind(multiply, UNITY)
        x11 = chain(x8, x9, x10)
        x12 = sfilter(x6, x11)
        x13 = maximum(x12)
        x14 = increment(x13)
        x15 = toindices(x2)
        x16 = lbind(intersection, x15)
        x17 = lbind(shift, x1)
        x18 = rbind(multiply, x14)
        x19 = chain(toindices, x17, x18)
        x20 = chain(size, x16, x19)
        x21 = argmax(x3, x20)
        x22 = shape(I)
        x23 = maximum(x22)
        x24 = increment(x23)
        x25 = interval(ONE, x24, ONE)
        x26 = lbind(shift, x1)
        x27 = multiply(x14, x21)
        x28 = lbind(multiply, x27)
        x29 = pair(x25, x25)
        x30 = apply(x28, x29)
        x31 = mapply(x26, x30)
        x32 = color(x2)
        x33 = recolor(x32, x31)
        x34 = paint(I, x33)
        return x34

    def verify_e9614598(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = merge(x0)
        x2 = center(x1)
        x3 = dneighbors(x2)
        x4 = insert(x2, x3)
        x5 = fill(I, THREE, x4)
        return x5

    def verify_e98196ab(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = sfilter(x0, hline)
        x2 = size(x1)
        x3 = positive(x2)
        x4 = branch(x3, vsplit, hsplit)
        x5 = x4(I, TWO)
        x6 = first(x5)
        x7 = last(x5)
        x8 = fgpartition(x7)
        x9 = merge(x8)
        x10 = paint(x6, x9)
        return x10

    def verify_e9afcf9a(I: Grid) -> Grid:
        x0 = asobject(I)
        x1 = height(I)
        x2 = decrement(x1)
        x3 = lbind(subtract, x2)
        x4 = compose(double, halve)
        x5 = fork(equality, identity, x4)
        x6 = compose(last, last)
        x7 = chain(flip, x5, x6)
        x8 = sfilter(x0, x7)
        x9 = chain(x3, first, last)
        x10 = compose(last, last)
        x11 = fork(astuple, x9, x10)
        x12 = fork(astuple, first, x11)
        x13 = apply(x12, x8)
        x14 = paint(I, x13)
        return x14

    def verify_ea32f347(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = merge(x0)
        x2 = fill(I, FOUR, x1)
        x3 = argmin(x0, size)
        x4 = argmax(x0, size)
        x5 = fill(x2, ONE, x4)
        x6 = fill(x5, TWO, x3)
        return x6

    def verify_ea786f4a(I: Grid) -> Grid:
        x0 = shape(I)
        x1 = halve(x0)
        x2 = rbind(shoot, UP_RIGHT)
        x3 = rbind(shoot, DOWN_LEFT)
        x4 = fork(combine, x2, x3)
        x5 = rbind(shoot, UNITY)
        x6 = rbind(shoot, NEG_UNITY)
        x7 = fork(combine, x5, x6)
        x8 = fork(combine, x4, x7)
        x9 = index(I, x1)
        x10 = x8(x1)
        x11 = fill(I, x9, x10)
        return x11

    def verify_eb281b96(I: Grid) -> Grid:
        x0 = height(I)
        x1 = width(I)
        x2 = decrement(x0)
        x3 = astuple(x2, x1)
        x4 = crop(I, ORIGIN, x3)
        x5 = hmirror(x4)
        x6 = vconcat(I, x5)
        x7 = double(x2)
        x8 = astuple(x7, x1)
        x9 = crop(x6, DOWN, x8)
        x10 = vconcat(x6, x9)
        return x10

    def verify_eb5a1d5d(I: Grid) -> Grid:
        x0 = compose(dmirror, dedupe)
        x1 = x0(I)
        x2 = x0(x1)
        x3 = fork(remove, last, identity)
        x4 = compose(hmirror, x3)
        x5 = fork(vconcat, identity, x4)
        x6 = x5(x2)
        x7 = dmirror(x6)
        x8 = x5(x7)
        return x8

    def verify_ec883f72(I: Grid) -> Grid:
        x0 = fork(multiply, height, width)
        x1 = partition(I)
        x2 = argmax(x1, x0)
        x3 = remove(x2, x1)
        x4 = argmax(x3, x0)
        x5 = other(x3, x4)
        x6 = palette(I)
        x7 = lrcorner(x4)
        x8 = add(x7, UNITY)
        x9 = llcorner(x4)
        x10 = add(x9, DOWN_LEFT)
        x11 = urcorner(x4)
        x12 = add(x11, UP_RIGHT)
        x13 = ulcorner(x4)
        x14 = add(x13, NEG_UNITY)
        x15 = shoot(x8, UNITY)
        x16 = shoot(x10, DOWN_LEFT)
        x17 = shoot(x12, UP_RIGHT)
        x18 = shoot(x14, NEG_UNITY)
        x19 = combine(x15, x16)
        x20 = combine(x17, x18)
        x21 = combine(x19, x20)
        x22 = color(x5)
        x23 = fill(I, x22, x21)
        return x23

    def verify_ecdecbb3(I: Grid) -> Grid:
        x0 = leastcolor(I)
        x1 = objects(I, T, F, T)
        x2 = merge(x1)
        x3 = palette(x2)
        x4 = other(x3, x0)
        x5 = ofcolor(I, x0)
        x6 = frontiers(I)
        x7 = colorfilter(x6, x4)
        x8 = sfilter(x7, hline)
        x9 = size(x8)
        x10 = positive(x9)
        x11 = height(I)
        x12 = toivec(x11)
        x13 = hfrontier(x12)
        x14 = toivec(NEG_ONE)
        x15 = hfrontier(x14)
        x16 = insert(x15, x7)
        x17 = insert(x13, x16)
        x18 = width(I)
        x19 = tojvec(x18)
        x20 = vfrontier(x19)
        x21 = tojvec(NEG_ONE)
        x22 = vfrontier(x21)
        x23 = insert(x22, x7)
        x24 = insert(x20, x23)
        x25 = branch(x10, x17, x24)
        x26 = lbind(argmin, x25)
        x27 = lbind(rbind, manhattan)
        x28 = compose(x27, initset)
        x29 = compose(x26, x28)
        x30 = rbind(remove, x25)
        x31 = compose(x30, x29)
        x32 = fork(argmin, x31, x28)
        x33 = fork(gravitate, initset, x29)
        x34 = compose(crement, x33)
        x35 = fork(add, identity, x34)
        x36 = fork(gravitate, initset, x32)
        x37 = compose(crement, x36)
        x38 = fork(add, identity, x37)
        x39 = ofcolor(I, x4)
        x40 = backdrop(x39)
        x41 = fork(connect, x35, x38)
        x42 = rbind(contained, x40)
        x43 = rbind(extract, x42)
        x44 = fork(astuple, x35, x38)
        x45 = compose(x43, x44)
        x46 = fork(connect, identity, x45)
        x47 = rbind(branch, x46)
        x48 = rbind(x47, x41)
        x49 = rbind(contained, x40)
        x50 = compose(x48, x49)
        x51 = compose(initset, x50)
        x52 = fork(rapply, x51, identity)
        x53 = compose(first, x52)
        x54 = mapply(x53, x5)
        x55 = fill(I, x0, x54)
        x56 = intersection(x39, x54)
        x57 = mapply(neighbors, x56)
        x58 = fill(x55, x4, x57)
        return x58

    def verify_ed36ccf7(I: Grid) -> Grid:
        x0 = rot270(I)
        return x0

    def verify_ef135b50(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = fork(multiply, height, width)
        x2 = fork(equality, size, x1)
        x3 = compose(flip, x2)
        x4 = sfilter(x0, x3)
        x5 = argmax(x4, x1)
        x6 = color(x5)
        x7 = ofcolor(I, x6)
        x8 = asindices(I)
        x9 = difference(x8, x7)
        x10 = fill(I, NEG_ONE, x9)
        x11 = lbind(recolor, NEG_ONE)
        x12 = rbind(ofcolor, NEG_ONE)
        x13 = chain(x11, backdrop, x12)
        x14 = fork(paint, identity, x13)
        x15 = height(x10)
        x16 = vsplit(x10, x15)
        x17 = mapply(x14, x16)
        x18 = ofcolor(x17, NEG_ONE)
        x19 = asindices(I)
        x20 = box(x19)
        x21 = difference(x18, x20)
        x22 = intersection(x21, x7)
        x23 = fill(I, NINE, x22)
        return x23

    def verify_f15e1fac(I: Grid) -> Grid:
        x0 = rbind(ofcolor, TWO)
        x1 = compose(lowermost, x0)
        x2 = matcher(x1, ZERO)
        x3 = astuple(identity, dmirror)
        x4 = astuple(cmirror, hmirror)
        x5 = combine(x3, x4)
        x6 = rbind(rapply, I)
        x7 = compose(first, x6)
        x8 = chain(x2, x7, initset)
        x9 = extract(x5, x8)
        x10 = x9(I)
        x11 = mostcolor(I)
        x12 = palette(I)
        x13 = remove(x11, x12)
        x14 = other(x13, TWO)
        x15 = ofcolor(x10, x14)
        x16 = rightmost(x15)
        x17 = equality(x16, ZERO)
        x18 = branch(x17, identity, vmirror)
        x19 = x18(x10)
        x20 = ofcolor(x19, x14)
        x21 = ofcolor(x19, TWO)
        x22 = apply(last, x21)
        x23 = insert(ZERO, x22)
        x24 = width(x19)
        x25 = insert(x24, x23)
        x26 = order(x25, identity)
        x27 = last(x26)
        x28 = remove(x27, x26)
        x29 = first(x26)
        x30 = remove(x29, x26)
        x31 = pair(x28, x30)
        x32 = size(x28)
        x33 = interval(ZERO, x32, ONE)
        x34 = pair(x33, x31)
        x35 = lbind(fork, connect)
        x36 = compose(first, last)
        x37 = chain(decrement, last, last)
        x38 = lbind(lbind, add)
        x39 = compose(x38, first)
        x40 = lbind(rbind, astuple)
        x41 = rbind(chain, first)
        x42 = compose(x40, x36)
        x43 = compose(x40, x37)
        x44 = fork(x41, x42, x39)
        x45 = fork(x41, x43, x39)
        x46 = fork(x35, x44, x45)
        x47 = rbind(mapply, x20)
        x48 = compose(x47, x46)
        x49 = mapply(x48, x34)
        x50 = fill(x19, x14, x49)
        x51 = x18(x50)
        x52 = x9(x51)
        return x52

    def verify_f1cefba8(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = argmax(x0, x1)
        x3 = argmin(x0, x1)
        x4 = remove(x2, x0)
        x5 = other(x4, x3)
        x6 = color(x3)
        x7 = color(x5)
        x8 = toindices(x3)
        x9 = inbox(x5)
        x10 = intersection(x8, x9)
        x11 = fork(combine, hfrontier, vfrontier)
        x12 = mapply(x11, x10)
        x13 = corners(x5)
        x14 = inbox(x5)
        x15 = corners(x14)
        x16 = combine(x13, x15)
        x17 = mapply(x11, x16)
        x18 = difference(x12, x17)
        x19 = toindices(x2)
        x20 = intersection(x18, x19)
        x21 = fill(I, x6, x20)
        x22 = difference(x18, x20)
        x23 = fill(x21, x7, x22)
        x24 = inbox(x5)
        x25 = fill(x23, x7, x24)
        return x25

    def verify_f25fbde4(I: Grid) -> Grid:
        x0 = compress(I)
        x1 = upscale(x0, TWO)
        return x1

    def verify_f25ffba3(I: Grid) -> Grid:
        x0 = tophalf(I)
        x1 = numcolors(x0)
        x2 = equality(x1, ONE)
        x3 = bottomhalf(I)
        x4 = numcolors(x3)
        x5 = equality(x4, ONE)
        x6 = either(x2, x5)
        x7 = branch(x6, identity, dmirror)
        x8 = x7(I)
        x9 = asobject(x8)
        x10 = hmirror(x9)
        x11 = mostcolor(I)
        x12 = matcher(first, x11)
        x13 = compose(flip, x12)
        x14 = sfilter(x10, x13)
        x15 = paint(x8, x14)
        x16 = x7(x15)
        return x16

    def verify_f2829549(I: Grid) -> Grid:
        x0 = frontiers(I)
        x1 = sfilter(x0, hline)
        x2 = size(x1)
        x3 = positive(x2)
        x4 = branch(x3, vsplit, hsplit)
        x5 = x4(I, TWO)
        x6 = first(x5)
        x7 = last(x5)
        x8 = palette(x6)
        x9 = palette(x7)
        x10 = intersection(x8, x9)
        x11 = first(x10)
        x12 = shape(x6)
        x13 = canvas(x11, x12)
        x14 = ofcolor(x6, x11)
        x15 = ofcolor(x7, x11)
        x16 = intersection(x14, x15)
        x17 = fill(x13, THREE, x16)
        return x17

    def verify_f35d900a(I: Grid) -> Grid:
        x0 = objects(I, T, F, T)
        x1 = palette(I)
        x2 = mostcolor(I)
        x3 = remove(x2, x1)
        x4 = lbind(other, x3)
        x5 = compose(x4, color)
        x6 = fork(recolor, x5, outbox)
        x7 = mapply(x6, x0)
        x8 = mapply(toindices, x0)
        x9 = box(x8)
        x10 = difference(x9, x8)
        x11 = lbind(argmin, x8)
        x12 = rbind(compose, initset)
        x13 = lbind(rbind, manhattan)
        x14 = chain(x12, x13, initset)
        x15 = chain(initset, x11, x14)
        x16 = fork(manhattan, initset, x15)
        x17 = compose(even, x16)
        x18 = sfilter(x10, x17)
        x19 = paint(I, x7)
        x20 = fill(x19, FIVE, x18)
        return x20

    def verify_f5b8619d(I: Grid) -> Grid:
        x0 = fgpartition(I)
        x1 = mapply(toindices, x0)
        x2 = mapply(vfrontier, x1)
        x3 = underfill(I, EIGHT, x2)
        x4 = hconcat(x3, x3)
        x5 = vconcat(x4, x4)
        return x5

    def verify_f76d97a5(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = remove(FIVE, x0)
        x2 = first(x1)
        x3 = ofcolor(I, x2)
        x4 = fill(I, ZERO, x3)
        x5 = ofcolor(I, FIVE)
        x6 = fill(x4, x2, x5)
        return x6

    def verify_f8a8fe49(I: Grid) -> Grid:
        x0 = partition(I)
        x1 = fork(multiply, height, width)
        x2 = argmin(x0, x1)
        x3 = argmax(x0, x1)
        x4 = remove(x2, x0)
        x5 = other(x4, x3)
        x6 = subgrid(x5, I)
        x7 = frontiers(x6)
        x8 = sfilter(x7, hline)
        x9 = size(x8)
        x10 = positive(x9)
        x11 = branch(x10, dmirror, identity)
        x12 = x11(I)
        x13 = color(x5)
        x14 = ofcolor(x12, x13)
        x15 = subgrid(x14, x12)
        x16 = trim(x15)
        x17 = lefthalf(x16)
        x18 = vmirror(x17)
        x19 = asobject(x18)
        x20 = righthalf(x16)
        x21 = vmirror(x20)
        x22 = asobject(x21)
        x23 = color(x3)
        x24 = inbox(x14)
        x25 = backdrop(x24)
        x26 = fill(x12, x23, x25)
        x27 = urcorner(x14)
        x28 = add(x27, UNITY)
        x29 = shift(x22, x28)
        x30 = ulcorner(x14)
        x31 = width(x19)
        x32 = invert(x31)
        x33 = tojvec(x32)
        x34 = add(DOWN, x33)
        x35 = add(x30, x34)
        x36 = shift(x19, x35)
        x37 = combine(x29, x36)
        x38 = paint(x26, x37)
        x39 = x11(x38)
        return x39

    def verify_f8b3ba0a(I: Grid) -> Grid:
        x0 = compress(I)
        x1 = astuple(THREE, ONE)
        x2 = palette(x0)
        x3 = lbind(colorcount, x0)
        x4 = compose(invert, x3)
        x5 = order(x2, x4)
        x6 = rbind(canvas, UNITY)
        x7 = apply(x6, x5)
        x8 = merge(x7)
        x9 = size(x2)
        x10 = decrement(x9)
        x11 = astuple(x10, ONE)
        x12 = crop(x8, DOWN, x11)
        return x12

    def verify_f8c80d96(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = compose(maximum, shape)
        x2 = argmin(x0, x1)
        x3 = color(x2)
        x4 = palette(I)
        x5 = other(x4, x3)
        x6 = colorfilter(x0, x5)
        x7 = argmin(x6, x1)
        x8 = remove(x7, x6)
        x9 = rbind(manhattan, x7)
        x10 = argmin(x8, x9)
        x11 = rightmost(x10)
        x12 = rightmost(x7)
        x13 = subtract(x11, x12)
        x14 = leftmost(x7)
        x15 = leftmost(x10)
        x16 = subtract(x14, x15)
        x17 = astuple(x13, x16)
        x18 = maximum(x17)
        x19 = lowermost(x10)
        x20 = lowermost(x7)
        x21 = subtract(x19, x20)
        x22 = uppermost(x7)
        x23 = uppermost(x10)
        x24 = subtract(x22, x23)
        x25 = astuple(x21, x24)
        x26 = maximum(x25)
        x27 = ulcorner(x7)
        x28 = lrcorner(x7)
        x29 = astuple(x26, x18)
        x30 = double(EIGHT)
        x31 = interval(ONE, x30, ONE)
        x32 = lbind(subtract, x27)
        x33 = rbind(multiply, x29)
        x34 = compose(x32, x33)
        x35 = lbind(add, x28)
        x36 = rbind(multiply, x29)
        x37 = chain(initset, x35, x36)
        x38 = fork(insert, x34, x37)
        x39 = compose(box, x38)
        x40 = mapply(x39, x31)
        x41 = fill(I, x5, x40)
        x42 = replace(x41, x3, FIVE)
        return x42

    def verify_f8ff0b80(I: Grid) -> Grid:
        x0 = objects(I, T, T, T)
        x1 = order(x0, size)
        x2 = apply(color, x1)
        x3 = rbind(canvas, UNITY)
        x4 = apply(x3, x2)
        x5 = merge(x4)
        x6 = hmirror(x5)
        return x6

    def verify_f9012d9b(I: Grid) -> Grid:
        x0 = lbind(contained, ZERO)
        x1 = compose(flip, x0)
        x2 = sfilter(I, x1)
        x3 = dmirror(I)
        x4 = lbind(contained, ZERO)
        x5 = compose(flip, x4)
        x6 = sfilter(x3, x5)
        x7 = compose(hperiod, asobject)
        x8 = height(x2)
        x9 = vsplit(x2, x8)
        x10 = apply(x7, x9)
        x11 = maximum(x10)
        x12 = compose(hperiod, asobject)
        x13 = height(x6)
        x14 = vsplit(x6, x13)
        x15 = apply(x12, x14)
        x16 = maximum(x15)
        x17 = ofcolor(I, ZERO)
        x18 = asobject(I)
        x19 = matcher(first, ZERO)
        x20 = compose(flip, x19)
        x21 = sfilter(x18, x20)
        x22 = lbind(shift, x21)
        x23 = height(I)
        x24 = divide(x23, x16)
        x25 = increment(x24)
        x26 = width(I)
        x27 = divide(x26, x11)
        x28 = increment(x27)
        x29 = invert(x25)
        x30 = increment(x25)
        x31 = interval(x29, x30, ONE)
        x32 = invert(x28)
        x33 = increment(x28)
        x34 = interval(x32, x33, ONE)
        x35 = product(x31, x34)
        x36 = astuple(x16, x11)
        x37 = lbind(multiply, x36)
        x38 = apply(x37, x35)
        x39 = mapply(x22, x38)
        x40 = paint(I, x39)
        x41 = subgrid(x17, x40)
        return x41

    def verify_fafffa47(I: Grid) -> Grid:
        x0 = tophalf(I)
        x1 = numcolors(x0)
        x2 = equality(x1, TWO)
        x3 = bottomhalf(I)
        x4 = numcolors(x3)
        x5 = equality(x4, TWO)
        x6 = both(x2, x5)
        x7 = lefthalf(I)
        x8 = numcolors(x7)
        x9 = equality(x8, TWO)
        x10 = righthalf(I)
        x11 = numcolors(x10)
        x12 = equality(x11, TWO)
        x13 = both(x9, x12)
        x14 = flip(x13)
        x15 = both(x6, x14)
        x16 = branch(x15, vsplit, hsplit)
        x17 = x16(I, TWO)
        x18 = first(x17)
        x19 = last(x17)
        x20 = palette(x18)
        x21 = palette(x19)
        x22 = intersection(x20, x21)
        x23 = first(x22)
        x24 = shape(x18)
        x25 = canvas(x23, x24)
        x26 = ofcolor(x18, x23)
        x27 = ofcolor(x19, x23)
        x28 = intersection(x26, x27)
        x29 = fill(x25, TWO, x28)
        return x29

    def verify_fcb5c309(I: Grid) -> Grid:
        x0 = objects(I, T, F, F)
        x1 = lbind(contained, F)
        x2 = compose(flip, x1)
        x3 = fork(equality, toindices, box)
        x4 = lbind(apply, x3)
        x5 = lbind(colorfilter, x0)
        x6 = chain(x2, x4, x5)
        x7 = rbind(greater, TWO)
        x8 = compose(minimum, shape)
        x9 = lbind(apply, x8)
        x10 = chain(x7, minimum, x9)
        x11 = lbind(colorfilter, x0)
        x12 = compose(x10, x11)
        x13 = fork(both, x6, x12)
        x14 = palette(I)
        x15 = extract(x14, x13)
        x16 = palette(I)
        x17 = remove(x15, x16)
        x18 = lbind(colorcount, I)
        x19 = argmin(x17, x18)
        x20 = rbind(colorcount, x19)
        x21 = rbind(toobject, I)
        x22 = chain(x20, x21, backdrop)
        x23 = colorfilter(x0, x15)
        x24 = argmax(x23, x22)
        x25 = subgrid(x24, I)
        x26 = replace(x25, x15, x19)
        return x26

    def verify_fcc82909(I: Grid) -> Grid:
        x0 = objects(I, F, F, T)
        x1 = lbind(add, DOWN)
        x2 = compose(x1, llcorner)
        x3 = rbind(add, RIGHT)
        x4 = compose(x3, x2)
        x5 = chain(toivec, decrement, numcolors)
        x6 = fork(add, x4, x5)
        x7 = compose(initset, x6)
        x8 = fork(insert, x2, x7)
        x9 = compose(backdrop, x8)
        x10 = mapply(x9, x0)
        x11 = fill(I, THREE, x10)
        return x11

    def verify_feca6190(I: Grid) -> Grid:
        x0 = asobject(I)
        x1 = matcher(first, ZERO)
        x2 = compose(flip, x1)
        x3 = sfilter(x0, x2)
        x4 = size(x3)
        x5 = width(I)
        x6 = multiply(x5, x4)
        x7 = multiply(UNITY, x6)
        x8 = canvas(ZERO, x7)
        x9 = multiply(x5, x4)
        x10 = decrement(x9)
        x11 = lbind(astuple, x10)
        x12 = rbind(shoot, UP_RIGHT)
        x13 = compose(last, last)
        x14 = chain(x12, x11, x13)
        x15 = fork(recolor, first, x14)
        x16 = mapply(x15, x3)
        x17 = paint(x8, x16)
        return x17

    def verify_ff28f65a(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = remove(TWO, x0)
        x2 = lbind(colorcount, I)
        x3 = argmax(x1, x2)
        x4 = shape(I)
        x5 = canvas(x3, x4)
        x6 = hconcat(I, x5)
        x7 = objects(x6, T, F, T)
        x8 = colorfilter(x7, TWO)
        x9 = size(x8)
        x10 = double(x9)
        x11 = interval(ZERO, x10, TWO)
        x12 = apply(tojvec, x11)
        x13 = astuple(ONE, NINE)
        x14 = canvas(x3, x13)
        x15 = fill(x14, ONE, x12)
        x16 = hsplit(x15, THREE)
        x17 = merge(x16)
        return x17

    def verify_ff805c23(I: Grid) -> Grid:
        x0 = palette(I)
        x1 = lbind(rbind, sfilter)
        x2 = lbind(compose, flip)
        x3 = lbind(matcher, first)
        x4 = chain(x1, x2, x3)
        x5 = lbind(paint, I)
        x6 = rbind(compose, asobject)
        x7 = dmirror(I)
        x8 = rbind(rapply, x7)
        x9 = chain(first, x8, initset)
        x10 = chain(x9, x6, x4)
        x11 = compose(x5, x10)
        x12 = compose(x6, x4)
        x13 = compose(cmirror, x11)
        x14 = compose(initset, x12)
        x15 = fork(rapply, x14, x13)
        x16 = compose(first, x15)
        x17 = fork(paint, x11, x16)
        x18 = chain(initset, x6, x4)
        x19 = compose(hmirror, x17)
        x20 = fork(rapply, x18, x19)
        x21 = compose(first, x20)
        x22 = fork(paint, x17, x21)
        x23 = chain(initset, x6, x4)
        x24 = compose(vmirror, x22)
        x25 = fork(rapply, x23, x24)
        x26 = compose(first, x25)
        x27 = fork(paint, x22, x26)
        x28 = fork(equality, identity, hmirror)
        x29 = fork(equality, identity, vmirror)
        x30 = fork(equality, identity, cmirror)
        x31 = fork(equality, identity, dmirror)
        x32 = fork(both, x28, x29)
        x33 = fork(both, x30, x31)
        x34 = fork(both, x32, x33)
        x35 = compose(x34, x27)
        x36 = sfilter(x0, x35)
        x37 = lbind(colorcount, I)
        x38 = argmin(x36, x37)
        x39 = x27(x38)
        x40 = ofcolor(I, x38)
        x41 = subgrid(x40, x39)
        return x41

class Rander:
    import random
    choice = random.choice
    randint = random.randint
    sample = random.sample
    shuffle = random.shuffle
    uniform = random.uniform
    def unifint(diff_lb: float, diff_ub: float, bounds: Tuple[int, int]) -> int:  #diff_lb: lower bound for difficulty, must be in range [0, diff_ub];  diff_ub: upper bound for difficulty, must be in range [diff_lb, 1];  bounds: interval [a, b] determining the integer values that can be sampled
        import random
        d = random.uniform(diff_lb, diff_ub)
        a, b = bounds
        return min(max(a, round(a + (b - a) * d)), b)

class Joiner:
    def generate_dbc1a6ce(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (3, 30)
        colopts = remove(8, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, dim_bounds)
        w = unifint(diff_lb, diff_ub, dim_bounds)
        bgc = choice(colopts)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        card_bounds = (0, max(1, (h * w) // 4))
        num = unifint(diff_lb, diff_ub, card_bounds)
        s = sample(inds, num)
        fgcol = choice(remove(bgc, colopts))
        gi = fill(c, fgcol, s)
        resh = frozenset()
        for x, r in enumerate(gi):
            if r.count(fgcol) > 1:
                resh = combine(resh, connect((x, r.index(fgcol)), (x, -1 + w - r[::-1].index(fgcol))))
        go = fill(c, 8, resh)
        resv = frozenset()
        for x, r in enumerate(dmirror(gi)):
            if r.count(fgcol) > 1:
                resv = combine(resv, connect((x, r.index(fgcol)), (x, -1 + h - r[::-1].index(fgcol))))
        go = dmirror(fill(dmirror(go), 8, resv))
        go = fill(go, fgcol, s)
        return {'input': gi, 'output': go}

    def generate_2281f1f4(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (3, 30)
        colopts = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, dim_bounds)
        w = unifint(diff_lb, diff_ub, dim_bounds)
        card_h_bounds = (1, h // 2 + 1)
        card_w_bounds = (1, w // 2 + 1)
        numtop = unifint(diff_lb, diff_ub, card_w_bounds)
        numright = unifint(diff_lb, diff_ub, card_h_bounds)
        if numtop == numright == 1:
            numtop, numright = sample([1, 2], 2)
        tp = sample(interval(0, w - 1, 1), numtop)
        rp = sample(interval(1, h, 1), numright)
        res = combine(apply(lbind(astuple, 0), tp), apply(rbind(astuple, w - 1), rp))
        bgc = choice(colopts)
        dc = choice(remove(bgc, colopts))
        gi = fill(canvas(bgc, (h, w)), dc, res)
        go = fill(gi, 2, product(rp, tp))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_c1d99e64(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (4, 30)
        colopts = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, dim_bounds)
        w = unifint(diff_lb, diff_ub, dim_bounds)
        nofrontcol = choice(colopts)
        noisefrontcol = choice(remove(nofrontcol, colopts))
        gi = canvas(nofrontcol, (h, w))
        cands = totuple(asindices(gi))
        horifront_bounds = (1, h//4)
        vertifront_bounds = (1, w//4)
        nhf = unifint(diff_lb, diff_ub, horifront_bounds)
        nvf = unifint(diff_lb, diff_ub, vertifront_bounds)
        vfs = mapply(compose(vfrontier, tojvec), sample(interval(0, w, 1), nvf))
        hfs = mapply(compose(hfrontier, toivec), sample(interval(0, h, 1), nhf))
        gi = fill(gi, noisefrontcol, combine(vfs, hfs))
        cands = totuple(ofcolor(gi, nofrontcol))
        kk = size(cands)
        midp = (h * w) // 2
        noise_bounds = (0, max(0, kk - midp - 1))
        num_noise = unifint(diff_lb, diff_ub, noise_bounds)
        noise = sample(cands, num_noise)
        gi = fill(gi, noisefrontcol, noise)
        go = fill(gi, 2, merge(colorfilter(frontiers(gi), noisefrontcol)))
        return {'input': gi, 'output': go}

    def generate_623ea044(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (3, 30)
        colopts = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, dim_bounds)
        w = unifint(diff_lb, diff_ub, dim_bounds)
        bgc = choice(colopts)
        g = canvas(bgc, (h, w))
        fullinds = asindices(g)
        inds = totuple(asindices(g))
        card_bounds = (0, max(int(h * w * 0.1), 1))
        numdots = unifint(diff_lb, diff_ub, card_bounds)
        dots = sample(inds, numdots)
        gi = canvas(bgc, (h, w))
        fgc = choice(remove(bgc, colopts))
        gi = fill(gi, fgc, dots)
        go = fill(gi, fgc, mapply(rbind(shoot, UP_RIGHT), dots))
        go = fill(go, fgc, mapply(rbind(shoot, DOWN_LEFT), dots))
        go = fill(go, fgc, mapply(rbind(shoot, UNITY), dots))
        go = fill(go, fgc, mapply(rbind(shoot, NEG_UNITY), dots))
        return {'input': gi, 'output': go}

    def generate_1190e5a7(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (3, 30)
        colopts = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, dim_bounds)
        w = unifint(diff_lb, diff_ub, dim_bounds)
        bgc = choice(colopts)
        c = canvas(bgc, (h, w))
        nhf_bounds = (1, h // 3)
        nvf_bounds = (1, w // 3)
        nhf = unifint(diff_lb, diff_ub, nhf_bounds)
        nvf = unifint(diff_lb, diff_ub, nvf_bounds)
        hf_options = interval(1, h - 1, 1)
        vf_options = interval(1, w - 1, 1)
        hf_selection = []
        for k in range(nhf):
            hf = choice(hf_options)
            hf_selection.append(hf)
            hf_options = difference(hf_options, (hf - 1, hf, hf + 1))
        vf_selection = []
        for k in range(nvf):
            vf = choice(vf_options)
            vf_selection.append(vf)
            vf_options = difference(vf_options, (vf - 1, vf, vf + 1))
        remcols = remove(bgc, colopts)
        rcf = lambda x: recolor(choice(remcols), x)
        hfs = mapply(chain(rcf, hfrontier, toivec), tuple(hf_selection))
        vfs = mapply(chain(rcf, vfrontier, tojvec), tuple(vf_selection))
        gi = paint(c, combine(hfs, vfs))
        go = canvas(bgc, (nhf + 1, nvf + 1))
        return {'input': gi, 'output': go}

    def generate_5614dbcf(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (2, 10)
        col_card_bounds = (1, 8)
        noise_card_bounds = (0, 8)
        colopts = remove(5, interval(1, 10, 1))
        noisedindscands = totuple(asindices(canvas(0, (3, 3))))
        d = unifint(diff_lb, diff_ub, dim_bounds)
        cells_card_bounds = (1, d * d)
        go = canvas(0, (d, d))
        inds = totuple(asindices(go))
        numocc = unifint(diff_lb, diff_ub, cells_card_bounds)
        numcol = unifint(diff_lb, diff_ub, col_card_bounds)
        occs = sample(inds, numocc)
        colset = sample(colopts, numcol)
        gi = upscale(go, THREE)
        for occ in inds:
            offset = multiply(3, occ)
            numnoise = unifint(diff_lb, diff_ub, noise_card_bounds)
            noise = sample(noisedindscands, numnoise)
            if occ in occs:
                col = choice(colset)
                go = fill(go, col, initset(occ))
                gi = fill(gi, col, shift(noisedindscands, offset))
            gi = fill(gi, 5, shift(noise, offset))
        return {'input': gi, 'output': go}

    def generate_05269061(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (2, 30)
        colopts = interval(1, 10, 1)
        d = unifint(diff_lb, diff_ub, dim_bounds)
        go = canvas(0, (d, d))
        gi = canvas(0, (d, d))
        if choice((True, False)):
            period_bounds = (2, min(2*d-2, 9))
            num = unifint(diff_lb, diff_ub, period_bounds)
            cols = tuple(choice(colopts) for k in range(num))
            keeps = [choice(interval(j, 2*d-1, num)) for j in range(num)]
            for k, col in enumerate((cols * 30)[:2*d-1]):
                lin = shoot(toivec(k), UP_RIGHT)
                go = fill(go, col, lin)
                if keeps[k % num] == k:
                    gi = fill(gi, col, lin)
        else:
            period_bounds = (2, min(d, 9))
            num = unifint(diff_lb, diff_ub, period_bounds)
            cols = tuple(choice(colopts) for k in range(num))
            keeps = [choice(interval(j, d, num)) for j in range(num)]
            for k, col in enumerate((cols * 30)[:d]):
                lin = hfrontier(toivec(k))
                go = fill(go, col, lin)
                if keeps[k % num] == k:
                    gi = fill(gi, col, lin)
        if choice((True, False)):
            gi = vmirror(gi)
            go = vmirror(go)
        return {'input': gi, 'output': go}

    def generate_1c786137(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (3, 30)
        num_cols_card_bounds = (1, 8)
        colopts = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, dim_bounds)
        w = unifint(diff_lb, diff_ub, dim_bounds)
        noise_card_bounds = (0, h * w)
        c = canvas(0, (h, w))
        inds = totuple(asindices(c))
        num_noise = unifint(diff_lb, diff_ub, noise_card_bounds)
        num_cols = unifint(diff_lb, diff_ub, num_cols_card_bounds)
        noiseinds = sample(inds, num_noise)
        colset = sample(colopts, num_cols)
        trgcol = choice(difference(colopts, colset))
        noise = frozenset((choice(colset), ij) for ij in noiseinds)
        gi = paint(c, noise)
        boxhrng = (3, max(3, h//2))
        boxwrng = (3, max(3, w//2))
        boxh = unifint(diff_lb, diff_ub, boxhrng)
        boxw = unifint(diff_lb, diff_ub, boxwrng)
        boxi = choice(interval(0, h - boxh + 1, 1))
        boxj = choice(interval(0, w - boxw + 1, 1))
        loc = (boxi, boxj)
        llc = add(loc, toivec(boxh - 1))
        urc = add(loc, tojvec(boxw - 1))
        lrc = add(loc, (boxh - 1, boxw - 1))
        l1 = connect(loc, llc)
        l2 = connect(loc, urc)
        l3 = connect(urc, lrc)
        l4 = connect(llc, lrc)
        l = l1 | l2 | l3 | l4
        gi = fill(gi, trgcol, l)
        go = crop(gi, increment(loc), (boxh - 2, boxw - 2))
        return {'input': gi, 'output': go}

    def generate_2204b7a8(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (4, 30)
        colopts = interval(0, 10, 1)
        while True:
            h = unifint(diff_lb, diff_ub, dim_bounds)
            w = unifint(diff_lb, diff_ub, dim_bounds)
            bgc = choice(colopts)
            remcols = remove(bgc, colopts)
            c = canvas(bgc, (h, w))
            inds = totuple(shift(asindices(canvas(0, (h, w - 2))), RIGHT))
            ccol = choice(remcols)
            remcols2 = remove(ccol, remcols)
            c1 = choice(remcols2)
            c2 = choice(remove(c1, remcols2))
            nc_bounds = (1, (h * (w - 2)) // 2 - 1)
            nc = unifint(diff_lb, diff_ub, nc_bounds)
            locs = sample(inds, nc)
            if w % 2 == 1:
                locs = difference(locs, vfrontier(tojvec(w // 2)))
            gi = fill(c, c1, vfrontier(ORIGIN))
            gi = fill(gi, c2, vfrontier(tojvec(w - 1)))
            gi = fill(gi, ccol, locs)
            a = sfilter(locs, lambda ij: last(ij) < w // 2)
            b = difference(locs, a)
            go = fill(gi, c1, a)
            go = fill(go, c2, b)
            if len(palette(gi)) == 4:
                break
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_23581191(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (3, 30)
        colopts = remove(2, interval(0, 10, 1))
        f = fork(combine, hfrontier, vfrontier)
        h = unifint(diff_lb, diff_ub, dim_bounds)
        w = unifint(diff_lb, diff_ub, dim_bounds)
        bgcol = choice(colopts)
        remcols = remove(bgcol, colopts)
        c = canvas(bgcol, (h, w))
        inds = totuple(asindices(c))
        acol = choice(remcols)
        bcol = choice(remove(acol, remcols))
        card_bounds = (1, (h * w) // 4)
        na = unifint(diff_lb, diff_ub, card_bounds)
        nb = unifint(diff_lb, diff_ub, card_bounds)
        a = sample(inds, na)
        b = sample(difference(inds, a), nb)
        gi = fill(c, acol, a)
        gi = fill(gi, bcol, b)
        fa = apply(first, a)
        la = apply(last, a)
        fb = apply(first, b)
        lb = apply(last, b)
        alins = sfilter(inds, lambda ij: first(ij) in fa or last(ij) in la)
        blins = sfilter(inds, lambda ij: first(ij) in fb or last(ij) in lb)
        go = fill(c, acol, alins)
        go = fill(go, bcol, blins)
        go = fill(go, 2, intersection(set(alins), set(blins)))
        go = fill(go, acol, a)
        go = fill(go, bcol, b)
        return {'input': gi, 'output': go}

    def generate_8be77c9e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 15))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(cols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = vconcat(gi, hmirror(gi))
        return {'input': gi, 'output': go}

    def generate_6d0aefbc(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (1, 30)
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 15))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = hconcat(gi, vmirror(gi))
        return {'input': gi, 'output': go}

    def generate_74dd1130(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = dmirror(gi)
        return {'input': gi, 'output': go}

    def generate_62c24649(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 15))
        w = unifint(diff_lb, diff_ub, (1, 15))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = vconcat(
            hconcat(gi, vmirror(gi)),
            hconcat(hmirror(gi), hmirror(vmirror(gi)))
        )
        return {'input': gi, 'output': go}

    def generate_6150a2bd(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = rot180(gi)
        return {'input': gi, 'output': go}

    def generate_6fa7a44f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 15))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = vconcat(gi, hmirror(gi))
        return {'input': gi, 'output': go}

    def generate_8d5021e8(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 10))
        w = unifint(diff_lb, diff_ub, (1, 15))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go1 = hconcat(vmirror(gi), gi)
        go2 = vconcat(go1, hmirror(go1))
        go = vconcat(hmirror(go1), go2)
        return {'input': gi, 'output': go}

    def generate_0520fde7(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc = 0
        remcols = remove(bgc, cols)
        barcol = choice(remcols)
        remcols = remove(barcol, remcols)
        cola = choice(remcols)
        colb = choice(remcols)
        canv = canvas(bgc, (h, w))
        inds = totuple(asindices(canv))
        gbar = canvas(barcol, (h, 1))
        mp = (h * w) // 2
        devrng = (0, mp)
        deva = unifint(diff_lb, diff_ub, devrng)
        devb = unifint(diff_lb, diff_ub, devrng)
        sgna = choice((+1, -1))
        sgnb = choice((+1, -1))
        deva = sgna * deva
        devb = sgnb * devb
        numa = mp + deva
        numb = mp + devb
        numa = max(min(h * w - 1, numa), 1)
        numb = max(min(h * w - 1, numb), 1)
        a = sample(inds, numa)
        b = sample(inds, numb)
        gia = fill(canv, cola, a)
        gib = fill(canv, colb, b)
        gi = hconcat(hconcat(gia, gbar), gib)
        go = fill(canv, 2, set(a) & set(b))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_46442a0e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 15))
        w = h
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go1 = hconcat(gi, rot90(gi))
        go2 = hconcat(rot270(gi), rot180(gi))
        go = vconcat(go1, go2)
        return {'input': gi, 'output': go}

    def generate_1b2d62fb(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc = 0
        remcols = remove(bgc, cols)
        barcol = choice(remcols)
        remcols = remove(barcol, remcols)
        cola = choice(remcols)
        colb = choice(remcols)
        canv = canvas(0, (h, w))
        inds = totuple(asindices(canv))
        gbar = canvas(barcol, (h, 1))
        mp = (h * w) // 2
        devrng = (0, mp)
        deva = unifint(diff_lb, diff_ub, devrng)
        devb = unifint(diff_lb, diff_ub, devrng)
        sgna = choice((+1, -1))
        sgnb = choice((+1, -1))
        deva = sgna * deva
        devb = sgnb * devb
        numa = mp + deva
        numb = mp + devb
        numa = max(min(h * w - 1, numa), 1)
        numb = max(min(h * w - 1, numb), 1)
        a = sample(inds, numa)
        b = sample(inds, numb)
        gia = fill(canv, cola, a)
        gib = fill(canv, colb, b)
        gi = hconcat(hconcat(gia, gbar), gib)
        go = fill(canv, 8, ofcolor(gia, 0) & ofcolor(gib, 0))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_3428a4f5(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 14))
        bgc = 0
        remcols = remove(bgc, cols)
        barcol = choice(remcols)
        remcols = remove(barcol, remcols)
        cola = choice(remcols)
        colb = choice(remcols)
        canv = canvas(bgc, (h, w))
        inds = totuple(asindices(canv))
        gbar = canvas(barcol, (h, 1))
        mp = (h * w) // 2
        devrng = (0, mp)
        deva = unifint(diff_lb, diff_ub, devrng)
        devb = unifint(diff_lb, diff_ub, devrng)
        sgna = choice((+1, -1))
        sgnb = choice((+1, -1))
        deva = sgna * deva
        devb = sgnb * devb
        numa = mp + deva
        numb = mp + devb
        numa = max(min(h * w - 1, numa), 1)
        numb = max(min(h * w - 1, numb), 1)
        a = sample(inds, numa)
        b = sample(inds, numb)
        gia = fill(canv, cola, a)
        gib = fill(canv, colb, b)
        gi = hconcat(hconcat(gia, gbar), gib)
        go = fill(canv, 3, (set(a) | set(b)) - (set(a) & set(b)))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_42a50994(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(colopts)
        remcols = remove(bgc, colopts)
        c = canvas(bgc, (h, w))
        card_bounds = (0, max(0, (h * w) // 2 - 1))
        num = unifint(diff_lb, diff_ub, card_bounds)
        numcols = unifint(diff_lb, diff_ub, (0, min(9, num)))
        inds = totuple(asindices(c))
        chosinds = sample(inds, num)
        choscols = sample(remcols, numcols)
        locs = interval(0, len(chosinds), 1)
        choslocs = sample(locs, numcols)
        gi = canvas(bgc, (h, w))
        for col, endidx in zip(choscols, sorted(choslocs)[::-1]):
            gi = fill(gi, col, chosinds[:endidx])
        objs = objects(gi, F, T, T)
        res = merge(sizefilter(objs, 1))
        go = fill(gi, bgc, res)
        return {'input': gi, 'output': go}

    def generate_08ed6ac7(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc = choice(difference(colopts, (1, 2, 3, 4)))
        remcols = remove(bgc, colopts)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        barrange = (4, w)
        locopts = interval(0, w, 1)
        nbars = unifint(diff_lb, diff_ub, barrange)
        barlocs = sample(locopts, nbars)
        barhopts = interval(0, h, 1)
        barhs = sample(barhopts, 4)
        barcols = [choice(remcols) for j in range(nbars)]
        barhsfx = [choice(barhs) for j in range(nbars - 4)] + list(barhs)
        shuffle(barhsfx)
        ordered = sorted(barhs)
        colord = interval(1, 5, 1)
        for col, (loci, locj) in zip(barcols, list(zip(barhsfx, barlocs))):
            bar = connect((loci, locj), (h - 1, locj))
            gi = fill(gi, col, bar)
            go = fill(go, colord[ordered.index(loci)], bar)
        return {'input': gi, 'output': go}

    def generate_8f2ea7aa(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        d = unifint(diff_lb, diff_ub, (2, 5))
        bgc = choice(colopts)
        remcols = remove(bgc, colopts)
        d2 = d ** 2
        gi = canvas(bgc, (d2, d2))
        go = canvas(bgc, (d2, d2))
        minig = canvas(bgc, (d, d))
        inds = totuple(asindices(minig))
        mp = d2 // 2
        devrng = (0, mp)
        dev = unifint(diff_lb, diff_ub, devrng)
        devs = choice((+1, -1))
        num = mp + devs * dev
        num = max(min(num, d2), 0)
        locs = set(sample(inds, num))
        while shape(locs) != (d, d):
            locs.add(choice(totuple(set(inds) - locs)))
        ncols = unifint(diff_lb, diff_ub, (1, 9))
        cols = sample(remcols, ncols)
        for ij in locs:
            minig = fill(minig, choice(cols), {ij})
        itv = interval(0, d2, d)
        plcopts = totuple(product(itv, itv))
        plc = choice(plcopts)
        minigo = asobject(minig)
        gi = paint(gi, shift(minigo, plc))
        for ij in locs:
            go = paint(go, shift(minigo, multiply(ij, d)))
        return {'input': gi, 'output': go}

    def generate_7fe24cdd(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 15))
        w = h
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go1 = hconcat(gi, rot90(gi))
        go2 = hconcat(rot270(gi), rot180(gi))
        go = vconcat(go1, go2)
        return {'input': gi, 'output': go}

    def generate_85c4e7cd(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 15))
        w = unifint(diff_lb, diff_ub, (1, 15))
        ncols = unifint(diff_lb, diff_ub, (1, 10))
        cols = sample(colopts, ncols)
        colord = [choice(cols) for j in range(min(h, w))]
        shp = (h*2, w*2)
        gi = canvas(0, shp)
        go = canvas(0, shp)
        for idx, (ci, co) in enumerate(zip(colord, colord[::-1])):
            ulc = (idx, idx)
            lrc = (h*2 - 1 - idx, w*2 - 1 - idx)
            bx = box(frozenset({ulc, lrc}))
            gi = fill(gi, ci, bx)
            go = fill(go, co, bx)
        return {'input': gi, 'output': go}

    def generate_8e5a5113(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        d = unifint(diff_lb, diff_ub, (2, 9))
        bgc = choice(colopts)
        remcols = remove(bgc, colopts)
        k = 4 if d < 7 else 3
        nbound = (2, k)
        num = unifint(diff_lb, diff_ub, nbound)
        rotfs = (identity, rot90, rot180, rot270)
        barc = choice(remcols)
        remcols = remove(barc, remcols)
        colbnds = (1, 8)
        ncols = unifint(diff_lb, diff_ub, colbnds)
        patcols = sample(remcols, ncols)
        bgcanv = canvas(bgc, (d, d))
        c = canvas(bgc, (d, d))
        inds = totuple(asindices(c))
        ncolbnds = (1, d ** 2 - 1)
        ncells = unifint(diff_lb, diff_ub, ncolbnds)
        indsss = sample(inds, ncells)
        for ij in indsss:
            c = fill(c, choice(patcols), {ij})
        barr = canvas(barc, (d, 1))
        fillinidx = choice(interval(0, num, 1))
        gi = rot90(rot270(c if fillinidx == 0 else bgcanv))
        go = rot90(rot270(c))
        for j in range(num - 1):
            c = rot90(c)
            gi = hconcat(hconcat(gi, barr), c if j + 1 == fillinidx else bgcanv)
            go = hconcat(hconcat(go, barr), c)
        if choice((True, False)):
            gi = rot90(gi)
            go = rot90(go)
        return {'input': gi, 'output': go}

    def generate_4c4377d9(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 15))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(cols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = vconcat(hmirror(gi), gi)
        return {'input': gi, 'output': go}

    def generate_a65b410d(diff_lb: float, diff_ub: float) -> dict:
        colopts = difference(interval(0, 10, 1), (1, 3))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        mpi = h // 2
        mpj = w // 2
        devi = unifint(diff_lb, diff_ub, (0, mpi))
        devj = unifint(diff_lb, diff_ub, (0, mpj))
        if choice((True, False)):
            locj = devj
            loci = devi
        else:
            loci = h - devi
            locj = w - devj
        loci = max(min(h - 2, loci), 1)
        locj = max(min(w - 2, locj), 1)
        loc = (loci, locj)
        bgc = choice(colopts)
        linc = choice(remove(bgc, colopts))
        gi = canvas(bgc, (h, w))
        gi = fill(gi, linc, connect((loci, 0), (loci, locj)))
        blues = shoot((loci + 1, locj - 1), (1, -1))
        f = lambda ij: connect(ij, (ij[0], 0)) if ij[1] >= 0 else frozenset({})
        blues = mapply(f, blues)
        greens = shoot((loci - 1, locj + 1), (-1, 1))
        greens = mapply(f, greens)
        go = fill(gi, 1, blues)
        go = fill(go, 3, greens)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_5168d44c(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (7, 30))
        doth = unifint(diff_lb, diff_ub, (1, h//3))
        dotw = unifint(diff_lb, diff_ub, (1, w//3))
        borderh = unifint(diff_lb, diff_ub, (1, h//4))
        borderw = unifint(diff_lb, diff_ub, (1, w//4))
        direc = choice((DOWN, RIGHT, UNITY))
        dotloci = randint(0, h - doth - 1 if direc == RIGHT else h - doth - borderh - 1)
        dotlocj = randint(0, w - dotw - 1 if direc == DOWN else w - dotw - borderw - 1)
        dotloc = (dotloci, dotlocj)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        dotcol = choice(remcols)
        remcols = remove(dotcol, remcols)
        boxcol = choice(remcols)
        gi = canvas(bgc, (h, w))
        dotshap = (doth, dotw)
        starterdot = backdrop(frozenset({dotloc, add(dotloc, decrement(dotshap))}))
        bordershap = (borderh, borderw)
        offset = add(multiply(direc, dotshap), multiply(direc, bordershap))
        itv = interval(-15, 16, 1)
        itv = apply(lbind(multiply, offset), itv)
        dots = mapply(lbind(shift, starterdot), itv)
        gi = fill(gi, dotcol, dots)
        protobx = backdrop(frozenset({
            (dotloci - borderh, dotlocj - borderw),
            (dotloci + doth + borderh - 1, dotlocj + dotw + borderw - 1),
        }))
        bx = protobx - starterdot
        bxshifted = shift(bx, offset)
        go = fill(gi, boxcol, bxshifted)
        gi = fill(gi, boxcol, bx)
        return {'input': gi, 'output': go}

    def generate_a9f96cdd(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (3, 6, 7, 8))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        fgc = choice(remove(bgc, cols))
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        locs = asindices(gi)
        noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 10)))
        for k in range(noccs):
            if len(locs) == 0:
                break
            loc = choice(totuple(locs))
            locs = locs - mapply(neighbors, neighbors(loc))
            plcd = {loc}
            gi = fill(gi, fgc, plcd)
            go = fill(go, 3, shift(plcd, (-1, -1)))
            go = fill(go, 7, shift(plcd, (1, 1)))
            go = fill(go, 8, shift(plcd, (1, -1)))
            go = fill(go, 6, shift(plcd, (-1, 1)))
        return {'input': gi, 'output': go}

    def generate_9172f3a0(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 10))
        w = unifint(diff_lb, diff_ub, (1, 10))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = upscale(gi, 3)
        return {'input': gi, 'output': go}

    def generate_67a423a3(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        lineh = unifint(diff_lb, diff_ub, (1, h // 3))
        linew = unifint(diff_lb, diff_ub, (1, w // 3))
        loci = randint(1, h - lineh - 1)
        locj = randint(1, w - linew - 1)
        acol = choice(remcols)
        bcol = choice(remove(acol, remcols))
        for a in range(lineh):
            gi = fill(gi, acol, connect((loci+a, 0), (loci+a, w-1)))
        for b in range(linew):
            gi = fill(gi, bcol, connect((0, locj+b), (h-1, locj+b)))
        bx = outbox(frozenset({(loci, locj), (loci + lineh - 1, locj + linew - 1)}))
        go = fill(gi, 4, bx)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_db3e9e38(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        barth = unifint(diff_lb, diff_ub, (1, max(1, w // 5)))
        loci = unifint(diff_lb, diff_ub, (1, h - 2))
        locj = randint(1, w - barth - 1)
        bar = backdrop(frozenset({(loci, locj), (0, locj + barth - 1)}))
        gi = canvas(bgc, (h, w))
        gi = fill(gi, fgc, bar)
        go = canvas(bgc, (h, w))
        for k in range(16):
            rsh = multiply(2 * k, (-1, barth))
            go = fill(go, fgc, shift(bar, rsh))
            lsh = multiply(2 * k, (-1, -barth))
            go = fill(go, fgc, shift(bar, lsh))
            rsh = multiply(2 * k + 1, (-1, barth))
            go = fill(go, 8, shift(bar, rsh))
            lsh = multiply(2 * k + 1, (-1, -barth))
            go = fill(go, 8, shift(bar, lsh))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_9dfd6313(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        dh = unifint(diff_lb, diff_ub, (1, 14))
        d = 2 * dh + 1
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        remcols = remove(linc, remcols)
        gi = canvas(bgc, (d, d))
        inds = asindices(gi)
        lni = randint(1, 4)
        if lni == 1:
            ln = connect((dh, 0), (dh, d - 1))
            mirrf = hmirror
            cands = sfilter(inds, lambda ij: ij[0] > dh)
        elif lni == 2:
            ln = connect((0, dh), (d - 1, dh))
            mirrf = vmirror
            cands = sfilter(inds, lambda ij: ij[1] > dh)
        elif lni == 3:
            ln = connect((0, 0), (d - 1, d - 1))
            mirrf = dmirror
            cands = sfilter(inds, lambda ij: ij[0] > ij[1])
        elif lni == 4:
            ln = connect((d - 1, 0), (0, d - 1))
            mirrf = cmirror
            cands = sfilter(inds, lambda ij: (ij[0] + ij[1]) > d)
        gi = fill(gi, linc, ln)
        mp = (d * (d - 1)) // 2
        numcols = unifint(diff_lb, diff_ub, (1, min(7, mp)))
        colsch = sample(remcols, numcols)
        numpix = unifint(diff_lb, diff_ub, (1, len(cands)))
        pixs = sample(totuple(cands), numpix)
        for pix in pixs:
            gi = fill(gi, choice(colsch), {pix})
        go = mirrf(gi)
        if choice((True, False)):
            gi, go = go, gi
        return {'input': gi, 'output': go}

    def generate_746b3537(diff_lb: float, diff_ub: float) -> dict:
        fullcols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 15))
        w = unifint(diff_lb, diff_ub, (1, 30))
        cols = []
        lastc = -1
        for k in range(h):
            c = choice(remove(lastc, fullcols))
            cols.append(c)
            lastc = c
        go = tuple((c,) for c in cols)
        gi = tuple(repeat(c, w) for c in cols)
        numinserts = unifint(diff_lb, diff_ub, (1, 30 - h))
        for k in range(numinserts):
            loc = randint(0, len(gi) - 1)
            gi = gi[:loc+1] + gi[loc:]
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_75b8110e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 15))
        w = unifint(diff_lb, diff_ub, (2, 15))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        c1, c2, c3, c4 = sample(remcols, 4)
        canv = canvas(bgc, (h, w))
        cels = totuple(asindices(canv))
        mp = (h * w) // 2
        nums = []
        for k in range(4):
            dev = unifint(diff_lb, diff_ub, (0, mp))
            if choice((True, False)):
                num = h * w - dev
            else:
                num = dev
            num = min(max(0, num), h * w - 1)
            nums.append(num)
        s1, s2, s3, s4 = [sample(cels, num) for num in nums]
        gi1 = fill(canv, c1, s1)
        gi2 = fill(canv, c2, s2)
        gi3 = fill(canv, c3, s3)
        gi4 = fill(canv, c4, s4)
        gi = vconcat(hconcat(gi1, gi2), hconcat(gi3, gi4))
        go = fill(gi1, c4, s4)
        go = fill(go, c3, s3)
        go = fill(go, c2, s2)
        return {'input': gi, 'output': go}

    def generate_1cf80156(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(colopts)
        fgc = choice(remove(bgc, colopts))
        gi = canvas(bgc, (h, w))
        hb = unifint(diff_lb, diff_ub, (1, min(15, h - 1)))
        wb = unifint(diff_lb, diff_ub, (1, min(15, w - 1)))
        bounds = asindices(canvas(0, (hb, wb)))
        shp = {choice(totuple(corners(bounds)))}
        mp = (hb * wb) // 2
        dev = unifint(diff_lb, diff_ub, (0, mp))
        nc = choice((dev, hb * wb - dev))
        nc = max(0, min(hb * wb - 1, nc))
        for j in range(nc):
            shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))
        shp = normalize(shp)
        di = randint(0, h - height(shp))
        dj = randint(0, w - width(shp))
        shpp = shift(shp, (di, dj))
        gi = fill(gi, fgc, shpp)
        go = fill(canvas(bgc, shape(shp)), fgc, shp)
        return {'input': gi, 'output': go}

    def generate_28bf18c6(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(colopts)
        fgc = choice(remove(bgc, colopts))
        gi = canvas(bgc, (h, w))
        hb = unifint(diff_lb, diff_ub, (1, min(14, h - 1)))
        wb = unifint(diff_lb, diff_ub, (1, min(14, w - 1)))
        bounds = asindices(canvas(0, (hb, wb)))
        shp = {choice(totuple(corners(bounds)))}
        mp = (hb * wb) // 2
        dev = unifint(diff_lb, diff_ub, (0, mp))
        nc = choice((dev, hb * wb - dev))
        nc = max(0, min(hb * wb - 1, nc))
        for j in range(nc):
            shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))
        shp = normalize(shp)
        di = randint(0, h - height(shp))
        dj = randint(0, w - width(shp))
        shpp = shift(shp, (di, dj))
        gi = fill(gi, fgc, shpp)
        go = fill(canvas(bgc, shape(shp)), fgc, shp)
        go = hconcat(go, go)
        return {'input': gi, 'output': go}

    def generate_22eb0ac0(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        gi = canvas(0, (1, 1))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc = choice(colopts)
        remcols = remove(bgc, colopts)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        nlocs = unifint(diff_lb, diff_ub, (1, h))
        locs = sample(interval(0, h, 1), nlocs)
        while set(locs).issubset({0, h - 1}):
            locs = sample(interval(0, h, 1), nlocs)
        mp = nlocs // 2
        nbarsdev = unifint(diff_lb, diff_ub, (0, mp))
        nbars = choice((nbarsdev, h - nbarsdev))
        nbars = max(0, min(nbars, nlocs))
        barlocs = sample(locs, nbars)
        nonbarlocs = difference(locs, barlocs)
        barcols = [choice(remcols) for j in range(nbars)]
        acols = [choice(remcols) for j in range(len(nonbarlocs))]
        bcols = [choice(remove(acols[j], remcols)) for j in range(len(nonbarlocs))]
        for bc, bl in zip(barcols, barlocs):
            gi = fill(gi, bc, ((bl, 0), (bl, w - 1)))
            go = fill(go, bc, connect((bl, 0), (bl, w - 1)))
        for (a, b), loc in zip(zip(acols, bcols), nonbarlocs):
            gi = fill(gi, a, {(loc, 0)})
            go = fill(go, a, {(loc, 0)})
            gi = fill(gi, b, {(loc, w - 1)})
            go = fill(go, b, {(loc, w - 1)})
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_4258a5f9(diff_lb: float, diff_ub: float) -> dict:
        colopts = remove(1, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        bgc = choice(colopts)
        remcols = remove(bgc, colopts)
        fgc = choice(remcols)
        gi = canvas(bgc, (h, w))
        mp = ((h * w) // 2) if (h * w) % 2 == 1 else ((h * w) // 2 - 1)
        ndots = unifint(diff_lb, diff_ub, (1, mp))
        inds = totuple(asindices(gi))
        dots = sample(inds, ndots)
        go = fill(gi, 1, mapply(neighbors, frozenset(dots)))
        go = fill(go, fgc, dots)
        gi = fill(gi, fgc, dots)
        return {'input': gi, 'output': go}

    def generate_1e0a9b12(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        ff = chain(dmirror, lbind(apply, rbind(order, identity)), dmirror)
        while True:
            h = unifint(diff_lb, diff_ub, (3, 30))
            w = unifint(diff_lb, diff_ub, (3, 30))
            nc = unifint(diff_lb, diff_ub, (1, w))
            bgc = choice(cols)
            gi = canvas(bgc, (h, w))
            remcols = remove(bgc, cols)
            scols = [choice(remcols) for j in range(nc)]
            slocs = sample(interval(0, w, 1), nc)
            inds = totuple(connect(ORIGIN, (h - 1, 0)))
            for c, l in zip(scols, slocs):
                nc2 = randint(1, h - 1)
                sel = sample(inds, nc2)
                gi = fill(gi, c, shift(sel, tojvec(l)))
            go = replace(ff(replace(gi, bgc, -1)), -1, bgc)
            if colorcount(gi, bgc) > argmax(remove(bgc, palette(gi)), lbind(colorcount, gi)):
                break
        return {'input': gi, 'output': go}

    def generate_9565186b(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(5, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        wg = canvas(5, (h, w))
        numcols = unifint(diff_lb, diff_ub, (2, min(h * w - 1, 8)))
        mostcol = choice(cols)
        nummostcol_lb = (h * w) // numcols + 1
        nummostcol_ub = h * w - numcols + 1
        ubmlb = nummostcol_ub - nummostcol_lb
        nmcdev = unifint(diff_lb, diff_ub, (0, ubmlb))
        nummostcol = nummostcol_ub - nmcdev
        nummostcol = min(max(nummostcol, nummostcol_lb), nummostcol_ub)
        inds = totuple(asindices(wg))
        mostcollocs = sample(inds, nummostcol)
        gi = fill(wg, mostcol, mostcollocs)
        go = fill(wg, mostcol, mostcollocs)
        remcols = remove(mostcol, cols)
        othcols = sample(remcols, numcols - 1)
        reminds = difference(inds, mostcollocs)
        bufferlocs = sample(reminds, numcols - 1)
        for c, l in zip(othcols, bufferlocs):
            gi = fill(gi, c, {l})
        reminds = difference(reminds, bufferlocs)
        colcounts = {c: 1 for c in othcols}
        for ij in reminds:
            if len(othcols) == 0:
                gi = fill(gi, mostcol, {ij})
                go = fill(go, mostcol, {ij})
            else:
                chc = choice(othcols)
                gi = fill(gi, chc, {ij})
                colcounts[chc] += 1
                if colcounts[chc] == nummostcol - 1:
                    othcols = remove(chc, othcols)
        return {'input': gi, 'output': go}

    def generate_6e02f1e3(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        d = unifint(diff_lb, diff_ub, (3, 30))
        c = canvas(0, (d, d))
        inds = list(asindices(c))
        shuffle(inds)
        num = d ** 2
        numcols = choice((1, 2, 3))
        chcols = sample(cols, numcols)
        if len(chcols) == 1:
            gi = canvas(chcols[0], (d, d))
            go = canvas(0, (d, d))
            go = fill(go, 5, connect((0, 0), (0, d - 1)))
        elif len(chcols) == 2:
            c1, c2 = chcols
            mp = (d ** 2) // 2
            nc1 = unifint(diff_lb, diff_ub, (1, mp))
            a = inds[:nc1]
            b = inds[nc1:]
            gi = fill(c, c1, a)
            gi = fill(gi, c2, b)
            go = fill(canvas(0, (d, d)), 5, connect((0, 0), (d - 1, d - 1)))
        elif len(chcols) == 3:
            c1, c2, c3 = chcols
            kk = d ** 2
            a = int(1/3 * kk)
            b = int(2/3 * kk)
            adev = unifint(diff_lb, diff_ub, (0, a - 1))
            bdev = unifint(diff_lb, diff_ub, (0, kk - b - 1))
            a -= adev
            b -= bdev
            x1, x2, x3 = inds[:a], inds[a:b], inds[b:]
            gi = fill(c, c1, x1)
            gi = fill(gi, c2, x2)
            gi = fill(gi, c3, x3)
            go = fill(canvas(0, (d, d)), 5, connect((d - 1, 0), (0, d - 1)))
        return {'input': gi, 'output': go}

    def generate_2dc579da(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        remcols = remove(linc, remcols)
        dotc = choice(remcols)
        hdev = unifint(diff_lb, diff_ub, (0, (h - 2) // 2))
        lineh = choice((hdev, h - 2 - hdev))
        lineh = max(min(h - 2, lineh), 1)
        wdev = unifint(diff_lb, diff_ub, (0, (w - 2) // 2))
        linew = choice((wdev, w - 2 - wdev))
        linew = max(min(w - 2, linew), 1)
        locidev = unifint(diff_lb, diff_ub, (1, h // 2))
        loci = choice((h // 2 - locidev, h // 2 + locidev))
        loci = min(max(1, loci), h - lineh - 1)
        locjdev = unifint(diff_lb, diff_ub, (1, w // 2))
        locj = choice((w // 2 - locjdev, w // 2 + locjdev))
        locj = min(max(1, locj), w - linew - 1)
        gi = canvas(bgc, (h, w))
        for a in range(loci, loci + lineh):
            gi = fill(gi, linc, connect((a, 0), (a, w - 1)))
        for b in range(locj, locj + linew):
            gi = fill(gi, linc, connect((0, b), (h - 1, b)))
        doth = randint(1, loci)
        dotw = randint(1, locj)
        dotloci = randint(0, loci - doth)
        dotlocj = randint(0, locj - dotw)
        dot = backdrop(frozenset({(dotloci, dotlocj), (dotloci + doth - 1, dotlocj + dotw - 1)}))
        gi = fill(gi, dotc, dot)
        go = crop(gi, (0, 0), (loci, locj))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_2dee498d(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (1, 30)
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 10))
        bgc = choice(cols)
        go = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(go))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            go = fill(go, col, chos)
            inds = difference(inds, chos)
        gi = hconcat(go, hconcat(go, go))
        return {'input': gi, 'output': go}

    def generate_508bd3b6(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (h, 30))
        barh = unifint(diff_lb, diff_ub, (1, h // 2))
        barloci = unifint(diff_lb, diff_ub, (2, h - barh))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        barc = choice(remcols)
        remcols = remove(barc, remcols)
        linc = choice(remcols)
        gi = canvas(bgc, (h, w))
        for j in range(barloci, barloci + barh):
            gi = fill(gi, barc, connect((j, 0), (j, w - 1)))
        dotlociinv = unifint(diff_lb, diff_ub, (0, barloci - 1))
        dotloci = min(max(0, barloci - 2 - dotlociinv), barloci - 1)
        ln1 = shoot((dotloci, 0), (1, 1))
        ofbgc = ofcolor(gi, bgc)
        ln1 = sfilter(ln1 & ofbgc, lambda ij: ij[0] < barloci)
        ln1 = order(ln1, first)
        ln2 = shoot(ln1[-1], (-1, 1))
        ln2 = sfilter(ln2 & ofbgc, lambda ij: ij[0] < barloci)
        ln2 = order(ln2, last)[1:]
        ln = ln1 + ln2
        k = len(ln1)
        lineleninv = unifint(diff_lb, diff_ub, (0, k - 2))
        linelen = k - lineleninv
        givenl = ln[:linelen]
        reml = ln[linelen:]
        gi = fill(gi, linc, givenl)
        go = fill(gi, 3, reml)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_88a62173(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (1, 30)
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 14))
        w = unifint(diff_lb, diff_ub, (1, 14))
        bgc = choice(cols)
        gib = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gib))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gib = fill(gib, col, chos)
            inds = difference(inds, chos)
        numchinv = unifint(diff_lb, diff_ub, (0, h * w - 1))
        numch = h * w - numchinv
        inds2 = totuple(asindices(gib))
        subs = sample(inds2, numch)
        go = hmirror(hmirror(gib))
        for x, y in subs:
            go = fill(go, choice(remove(go[x][y], colsch + [bgc])), {(x, y)})
        gi = canvas(bgc, (h*2+1, w*2+1))
        idxes = ((0, 0), (h+1, w+1), (h+1, 0), (0, w+1))
        trgloc = choice(idxes)
        remidxes = remove(trgloc, idxes)
        trgobj = asobject(go)
        otherobj = asobject(gib)
        gi = paint(gi, shift(trgobj, trgloc))
        for ij in remidxes:
            gi = paint(gi, shift(otherobj, ij))
        return {'input': gi, 'output': go}

    def generate_3aa6fb7a(diff_lb: float, diff_ub: float) -> dict:
        base = (ORIGIN, RIGHT, DOWN, UNITY)
        cols = remove(1, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        gi = canvas(bgc, (h, w))
        inds = totuple(asindices(gi))
        maxnum = ((h * w) // 2) // 3
        num = unifint(diff_lb, diff_ub, (1, maxnum))
        kk, tr = 0, 0
        maxtrials = num * 2
        binds = set()
        while kk < num and tr < maxtrials:
            loc = choice(inds)
            ooo = choice(base)
            oo = remove(ooo, base)
            oop = shift(oo, loc)
            if set(oop).issubset(inds):
                inds = difference(inds, totuple(combine(oop, totuple(mapply(dneighbors, oop)))))
                gi = fill(gi, fgc, oop)
                binds.add(add(ooo, loc))
                kk += 1
            tr += 1
        go = fill(gi, 1, binds)
        return {'input': gi, 'output': go}

    def generate_3ac3eb23(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        nlocs = unifint(diff_lb, diff_ub, (1, max(1, (w - 2) // 3)))
        locopts = interval(1, w - 1, 1)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        for k in range(nlocs):
            if len(locopts) == 0:
                break
            locj = choice(locopts)
            locopts = difference(locopts, interval(locj - 2, locj + 3, 1))
            col = choice(remcols)
            gi = fill(gi, col, {(0, locj)})
            go = fill(go, col, {(p, locj) for p in interval(0, h, 2)})
            go = fill(go, col, {(p, locj - 1) for p in interval(1, h, 2)})
            go = fill(go, col, {(p, locj + 1) for p in interval(1, h, 2)})
        mf = choice((identity, rot90, rot180, rot270))
        gi = mf(gi)
        go = mf(go)
        return {'input': gi, 'output': go}

    def generate_c3e719e8(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(0, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        gob = canvas(-1, (h**2, w**2))
        wg = canvas(-1, (h, w))
        ncols = unifint(diff_lb, diff_ub, (1, min(h * w - 1, 8)))
        nmc = randint(max(1, (h * w) // (ncols + 1) + 1), h * w)
        inds = totuple(asindices(wg))
        mc = choice(cols)
        remcols = remove(mc, cols)
        mcc = sample(inds, nmc)
        inds = difference(inds, mcc)
        gi = fill(wg, mc, mcc)
        ocols = sample(remcols, ncols)
        k = len(inds) // ncols + 1
        for ocol in ocols:
            if len(inds) == 0:
                break
            ub = min(nmc - 1, len(inds))
            ub = min(ub, k)
            ub = max(ub, 1)
            locs = sample(inds, unifint(diff_lb, diff_ub, (1, ub)))
            inds = difference(inds, locs)
            gi = fill(gi, ocol, locs)
        gi = replace(gi, -1, mc)
        o = asobject(gi)
        gob = replace(gob, -1, 0)
        go = paint(gob, mapply(lbind(shift, o), apply(rbind(multiply, (h, w)), ofcolor(gi, mc))))
        return {'input': gi, 'output': go}

    def generate_29c11459(diff_lb: float, diff_ub: float) -> dict:
        colopts = remove(5, interval(0, 10, 1))
        gi = canvas(0, (1, 1))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 29))
        if w % 2 == 0:
            w = choice((max(5, w - 1), min(29, w + 1)))
        bgc = choice(colopts)
        remcols = remove(bgc, colopts)
        ncols = unifint(diff_lb, diff_ub, (2, len(remcols)))
        ccols = sample(remcols, ncols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        nlocs = unifint(diff_lb, diff_ub, (1, h))
        locs = sample(interval(0, h, 1), nlocs)
        while set(locs).issubset({0, h - 1}):
            locs = sample(interval(0, h, 1), nlocs)
        acols = []
        bcols = []
        aforb = -1
        bforb = -1
        for k in range(nlocs):
            ac = choice(remove(aforb, ccols))
            acols.append(ac)
            aforb = ac
            bc = choice(remove(bforb, ccols))
            bcols.append(bc)
            bforb = bc
        for (a, b), loc in zip(zip(acols, bcols), sorted(locs)):
            gi = fill(gi, a, {(loc, 0)})
            gi = fill(gi, b, {(loc, w - 1)})
            go = fill(go, a, connect((loc, 0), (loc, w // 2 - 1)))
            go = fill(go, b, connect((loc, w // 2 + 1), (loc, w - 1)))
            go = fill(go, 5, {(loc, w // 2)})
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_23b5c85d(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        colopts = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        oh = unifint(diff_lb, diff_ub, (2, h - 1))
        ow = unifint(diff_lb, diff_ub, (2, w - 1))
        num = unifint(diff_lb, diff_ub, (1, 8))
        cnt = 0
        while cnt < num:
            loci = randint(0, h - oh)
            locj = randint(0, w - ow)
            col = choice(colopts)
            colopts = remove(col, colopts)
            obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            gi2 = fill(gi, col, obj)
            if color(argmin(sfilter(partition(gi2), fork(equality, size, fork(multiply, height, width))), fork(multiply, height, width))) != col:
                break
            else:
                gi = gi2
                go = canvas(col, shape(obj))
            oh = unifint(diff_lb, diff_ub, (max(0, oh - 4), oh - 1))
            ow = unifint(diff_lb, diff_ub, (max(0, ow - 4), ow - 1))
            if oh < 1 or ow < 1:
                break
            cnt += 1
        return {'input': gi, 'output': go}

    def generate_1bfc4729(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        if h % 2 == 1:
            h = choice((max(4, h - 1), min(30, h + 1)))
        alocj = unifint(diff_lb, diff_ub, (w // 2, w - 1))
        if choice((True, False)):
            alocj = max(min(w // 2, alocj - w // 2), 1)
        aloci = randint(1, h // 2 - 1)
        blocj = unifint(diff_lb, diff_ub, (w // 2, w - 1))
        if choice((True, False)):
            blocj = max(min(w // 2, blocj - w // 2), 1)
        bloci = randint(h // 2, h - 2)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        acol = choice(remcols)
        remcols = remove(acol, remcols)
        bcol = choice(remcols)
        gi = canvas(bgc, (h, w))
        aloc = (aloci, alocj)
        bloc = (bloci, blocj)
        gi = fill(gi, acol, {aloc})
        gi = fill(gi, bcol, {bloc})
        go = fill(gi, acol, hfrontier(aloc))
        go = fill(go, bcol, hfrontier(bloc))
        go = fill(go, acol, connect((0, 0), (0, w - 1)))
        go = fill(go, bcol, connect((h - 1, 0), (h - 1, w - 1)))
        go = fill(go, acol, connect((0, 0), (h // 2 - 1, 0)))
        go = fill(go, acol, connect((0, w - 1), (h // 2 - 1, w - 1)))
        go = fill(go, bcol, connect((h // 2, 0), (h - 1, 0)))
        go = fill(go, bcol, connect((h // 2, w - 1), (h - 1, w - 1)))
        return {'input': gi, 'output': go}

    def generate_47c1f68c(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 14))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc, linc = sample(cols, 2)
        remcols = difference(cols, (bgc, linc))
        objc = choice(remcols)
        canv = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (1, h * w - 1))
        bx = asindices(canv)
        obj = {choice(totuple(bx))}
        for kk in range(nc - 1):
            dns = mapply(neighbors, obj)
            ch = choice(totuple(bx & dns))
            obj.add(ch)
            bx = bx - {ch}
        obj = recolor(objc, obj)
        gi = paint(canv, obj)
        gi1 = hconcat(hconcat(gi, canvas(linc, (h, 1))), canv)
        gi2 = hconcat(hconcat(canv, canvas(linc, (h, 1))), canv)
        gi = vconcat(vconcat(gi1, canvas(linc, (1, 2*w+1))), gi2)
        go = paint(canv, obj)
        go = hconcat(go, vmirror(go))
        go = vconcat(go, hmirror(go))
        go = replace(go, objc, linc)
        scf = choice((identity, hmirror, vmirror, compose(hmirror, vmirror)))
        gi = scf(gi)
        go = scf(go)
        return {'input': gi, 'output': go}

    def generate_178fcbfb(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 3))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = totuple(asindices(gi))
        iforb = set()
        jforb = set()
        mp = (h * w) // 3
        for col in (2, 1, 3):
            bnd = unifint(diff_lb, diff_ub, (1, w if col == 2 else h // 2))
            for ndots in range(bnd):
                if col == 2:
                    ij = choice(sfilter(inds, lambda ij: last(ij) not in jforb))
                    jforb.add(last(ij))
                if col == 1 or col == 3:
                    ij = choice(sfilter(inds, lambda ij: first(ij) not in iforb))
                    iforb.add(first(ij))
                gi = fill(gi, col, initset(ij))
                go = fill(go, col, (vfrontier if col == 2 else hfrontier)(ij))
                inds = remove(ij, inds)
        return {'input': gi, 'output': go}

    def generate_ae4f1146(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(1, interval(0, 10, 1))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        dh = unifint(diff_lb, diff_ub, (2, h // 3))
        dw = unifint(diff_lb, diff_ub, (2, w // 3))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // (2 * dh * dw)))
        cards = interval(0, dh * dw, 1)
        ccards = sorted(sample(cards, min(num, len(cards))))
        sgs = []
        c1 = canvas(fgc, (dh, dw))
        inds = totuple(asindices(c1))
        for card in ccards:
            x = sample(inds, card)
            x1 = fill(c1, 1, x)
            sgs.append(asobject(x1))
        go = paint(c1, sgs[-1])
        gi = canvas(bgc, (h, w))
        inds2 = asindices(canvas(bgc, (h - dh, w - dw)))
        maxtr = 10
        for sg in sgs[::-1]:
            if len(inds2) == 0:
                break
            loc = choice(totuple(inds2))
            plcd = shift(sg, loc)
            tr = 0    
            while (not toindices(plcd).issubset(inds2)) and tr < maxtr:
                loc = choice(totuple(inds2))
                plcd = shift(sg, loc)
                tr += 1
            if tr < maxtr:
                inds2 = difference(inds2, toindices(plcd) | outbox(plcd))
                gi = paint(gi, plcd)
        return {'input': gi, 'output': go}

    def generate_3de23699(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        c = canvas(bgc, (h, w))
        hi = unifint(diff_lb, diff_ub, (4, h))
        wi = unifint(diff_lb, diff_ub, (4, w))
        loci = randint(0, h - hi)
        locj = randint(0, w - wi)
        remcols = remove(bgc, cols)
        ccol = choice(remcols)
        remcols = remove(ccol, remcols)
        ncol = choice(remcols)
        tmpo = frozenset({(loci, locj), (loci + hi - 1, locj + wi - 1)})
        cnds = totuple(backdrop(inbox(tmpo)))
        mp = len(cnds) // 2
        dev = unifint(diff_lb, diff_ub, (0, mp))
        ncnds = choice((dev, len(cnds) - dev))
        ncnds = min(max(0, ncnds), len(cnds))
        ss = sample(cnds, ncnds)
        gi = fill(c, ccol, corners(tmpo))
        gi = fill(gi, ncol, ss)
        go = trim(crop(switch(gi, ccol, ncol), (loci, locj), (hi, wi)))
        return {'input': gi, 'output': go}

    def generate_7ddcd7ec(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        crns = (((0, 0), (-1, -1)), ((0, 1), (-1, 1)), ((1, 0), (1, -1)), ((1, 1), (1, 1)))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (0, 4))
        chos = sample(crns, num)
        loci = randint(0, h - 2)
        locj = randint(0, w - 2)
        loc = (loci, locj)
        remcols = remove(bgc, cols)
        for sp, dr in crns:
            sp2 = add(loc, sp)
            col = choice(remcols)
            gi = fill(gi, col, {sp2})
            go = fill(go, col, {sp2})
            if (sp, dr) in chos:
                gi = fill(gi, col, {add(sp2, dr)})
                go = fill(go, col, shoot(sp2, dr))
        return {'input': gi, 'output': go}

    def generate_5c2c9af4(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        boxhd = unifint(diff_lb, diff_ub, (0, h // 2))
        boxwd = unifint(diff_lb, diff_ub, (0, w // 2))
        boxh = choice((boxhd, h - boxhd))
        boxw = choice((boxwd, w - boxwd))
        if boxh % 2 == 0:
            boxh = choice((boxh - 1, boxh + 1))
        if boxw % 2 == 0:
            boxw = choice((boxw - 1, boxw + 1))
        boxh = min(max(1, boxh), h if h % 2 == 1 else h - 1)
        boxw = min(max(1, boxw), w if w % 2 == 1 else w - 1)
        boxshap = (boxh, boxw)
        loci = randint(0, h - boxh)
        locj = randint(0, w - boxw)
        loc = (loci, locj)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        c = canvas(bgc, (h, w))
        cpi = loci + boxh // 2
        cpj = locj + boxw // 2
        cp = (cpi, cpj)
        A = (loci, locj)
        B = (loci + boxh - 1, locj + boxw - 1)
        gi = fill(c, fgc, {A, B, cp})
        go = fill(c, fgc, {A, B, cp})
        cond = True
        ooo = {A, B, cp}
        if hline(ooo) and len(ooo) == 3:
            go = fill(go, fgc, hfrontier(cp))
            cond = False
        if vline(ooo) and len(ooo) == 3:
            go = fill(go, fgc, vfrontier(cp))
            cond = False
        k = 1
        while cond:
            f1 = k * (boxh // 2)
            f2 = k * (boxw // 2)
            ulci = cpi - f1
            ulcj = cpj - f2
            lrci = cpi + f1
            lrcj = cpj + f2
            ulc = (ulci, ulcj)
            lrc = (lrci, lrcj)
            bx = box(frozenset({ulc, lrc}))
            go2 = fill(go, fgc, bx)
            cond = go != go2
            go = go2
            k += 1
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_0b148d64(diff_lb: float, diff_ub: float) -> dict:
        itv = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (7, 30))
        bgc = choice(itv)
        remitv = remove(bgc, itv)
        g = canvas(bgc, (h, w))
        x = randint(3, h - 3)
        y = randint(3, w - 3)
        di = randint(2, h - x - 1)
        dj = randint(2, w - y - 1)
        A = backdrop(frozenset({(0, 0), (x, y)}))
        B = backdrop(frozenset({(x + di, 0), (h - 1, y)}))
        C = backdrop(frozenset({(0, y + dj), (x, w - 1)}))
        D = backdrop(frozenset({(x + di, y + dj), (h - 1, w - 1)}))
        cola = choice(remitv)
        colb = choice(remove(cola, remitv))
        trg = choice((A, B, C, D))
        rem = remove(trg, (A, B, C, D))
        subf = lambda bx: {
            choice(totuple(connect(ulcorner(bx), urcorner(bx)))),
            choice(totuple(connect(ulcorner(bx), llcorner(bx)))),
            choice(totuple(connect(urcorner(bx), lrcorner(bx)))),
            choice(totuple(connect(llcorner(bx), lrcorner(bx)))),
        }
        sampler = lambda bx: set(sample(
            totuple(bx),
            len(bx) - unifint(diff_lb, diff_ub, (0, len(bx) - 1))
        ))
        gi = fill(g, cola, sampler(trg) | subf(trg))
        for r in rem:
            gi = fill(gi, colb, sampler(r) | subf(r))
        go = subgrid(frozenset(trg), gi)
        return {'input': gi, 'output': go}

    def generate_beb8660c(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        w = unifint(diff_lb, diff_ub, (3, 30))
        h = unifint(diff_lb, diff_ub, (w, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        k = min(8, w - 1)
        k = unifint(diff_lb, diff_ub, (1, k))
        co = sample(remcols, k)
        wds = sorted(sample(interval(1, w, 1), k))
        for j, (c, l) in enumerate(zip(co, wds)):
            j = h - k - 1 + j
            gi = fill(gi, c, connect((j, 0), (j, l - 1)))
        gi = fill(gi, 8, connect((h - 1, 0), (h - 1, w - 1)))
        go = vmirror(gi)
        gi = list(list(r) for r in gi[:-1])
        shuffle(gi)
        gi = tuple(tuple(r) for r in gi)
        gi = gi + go[-1:]
        gif = tuple()
        for r in gi:
            nbc = r.count(bgc)
            ofs = randint(0, nbc)
            gif = gif + (r[-ofs:] + r[:-ofs],)
        gi = vmirror(gif)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_8d510a79(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        barloci = randint(2, h - 3)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        barcol = choice(remcols)
        gi = canvas(bgc, (h, w))
        bar = connect((barloci, 0), (barloci, w - 1))
        gi = fill(gi, barcol, bar)
        go = tuple(e for e in gi)
        jinds = interval(0, w, 1)
        numtop = unifint(diff_lb, diff_ub, (1, w - 1))
        numbot = unifint(diff_lb, diff_ub, (1, w - 1))
        tops = sample(jinds, numtop)
        bots = sample(jinds, numbot)
        for t in tops:
            loci = randint(0, barloci - 2)
            col = choice((1, 2))
            loc = (loci, t)
            gi = fill(gi, col, {loc})
            if col == 1:
                go = fill(go, col, connect(loc, (0, t)))
            else:
                go = fill(go, col, connect(loc, (barloci - 1, t)))
        for t in bots:
            loci = randint(barloci + 2, h - 1)
            col = choice((1, 2))
            loc = (loci, t)
            gi = fill(gi, col, {loc})
            if col == 1:
                go = fill(go, col, connect(loc, (h - 1, t)))
            else:
                go = fill(go, col, connect(loc, (barloci + 1, t)))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_7468f01a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        sgc, fgc = sample(remcols, 2)
        oh = unifint(diff_lb, diff_ub, (2, max(2, int(h * (2/3)))))
        ow = unifint(diff_lb, diff_ub, (2, max(2, int(w * (2/3)))))
        gi = canvas(bgc, (h, w))
        go = canvas(sgc, (oh, ow))
        bounds = asindices(go)
        shp = {ORIGIN}
        nc = unifint(diff_lb, diff_ub, (0, max(1, (oh * ow) // 2)))
        for j in range(nc):
            shp.add(choice(totuple((bounds - shp) & mapply(dneighbors, shp))))
        go = fill(go, fgc, shp)
        objx = asobject(vmirror(go))
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        gi = paint(gi, shift(objx, (loci, locj)))
        return {'input': gi, 'output': go}

    def generate_09629e4f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        nrows, ncolumns = h, w
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        barcol = choice(remcols)
        remcols = remove(barcol, remcols)
        ncols = unifint(diff_lb, diff_ub, (2, min(7, (h * w) - 2)))
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        fullh, fullw = h * nrows + nrows - 1, w * ncolumns + ncolumns - 1
        gi = canvas(barcol, (fullh, fullw))
        locs = totuple(product(interval(0, fullh, h + 1), interval(0, fullw, w + 1)))
        trgloc = choice(locs)
        remlocs = remove(trgloc, locs)
        colssf = sample(remcols, ncols)
        colsss = remove(choice(colssf), colssf)
        trgssf = sample(inds, ncols - 1)
        gi = fill(gi, bgc, shift(inds, trgloc))
        for ij, cl in zip(trgssf, colsss):
            gi = fill(gi, cl, {add(trgloc, ij)})
        for rl in remlocs:
            trgss = sample(inds, ncols)
            tmpg = tuple(e for e in c)
            for ij, cl in zip(trgss, colssf):
                tmpg = fill(tmpg, cl, {ij})
            gi = paint(gi, shift(asobject(tmpg), rl))
        go = canvas(bgc, (fullh, fullw))
        go = fill(go, barcol, ofcolor(gi, barcol))
        for ij, cl in zip(trgssf, colsss):
            go = fill(go, cl, shift(inds, multiply(ij, (h+1, w+1))))
        return {'input': gi, 'output': go}

    def generate_4347f46a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 9))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(3, 7)
            ow = randint(3, 7)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                remcols = remove(col, remcols)
                gi = fill(gi, col, bd)
                go = fill(go, col, box(obj))
                succ += 1
                indss = indss - bd
            tr += 1
        return {'input': gi, 'output': go}

    def generate_6d58a25d(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        shp = normalize(frozenset({
        (0, 0), (1, 0), (1, 1), (1, -1), (2, -1), (2, -2), (2, 1), (2, 2), (3, 3), (3, -3)
        }))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        c1 = choice(remcols)
        c2 = choice(remove(c1, remcols))
        loci = randint(0, h - 4)
        locj = randint(0, w - 7)
        plcd = shift(shp, (loci, locj))
        rem = difference(inds, plcd)
        nnoise = unifint(diff_lb, diff_ub, (1, max(1, len(rem) // 2 - 1)))
        nois = sample(rem, nnoise)
        gi = fill(c, c2, nois)
        gi = fill(gi, c1, plcd)
        ff = lambda ij: len(intersection(shoot(ij, (-1, 0)), plcd)) > 0
        trg = sfilter(nois, ff)
        gg = lambda ij: valmax(sfilter(plcd, lambda kl: kl[1] == ij[1]), first) + 1
        kk = lambda ij: connect((gg(ij), ij[1]), (h - 1, ij[1]))
        fullres = mapply(kk, trg)
        go = fill(gi, c2, fullres)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_363442ee(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 3))
        w = unifint(diff_lb, diff_ub, (1, 3))
        h = h * 2 + 1
        w = w * 2 + 1
        nremh = unifint(diff_lb, diff_ub, (2, 30 // h))
        nremw = unifint(diff_lb, diff_ub, (2, (30 - w - 1) // w))
        rsh = nremh * h
        rsw = nremw * w
        rss = (rsh, rsw)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        barcol = choice(remcols)
        remcols = remove(barcol, remcols)
        rsi = canvas(bgc, rss)
        rso = canvas(bgc, rss)
        ls = canvas(bgc, ((nremh - 1) * h, w))
        ulc = canvas(bgc, (h, w))
        bar = canvas(barcol, (nremh * h, 1))
        dotcands = totuple(product(interval(0, rsh, h), interval(0, rsw, w)))
        dotcol = choice(remcols)
        dev = unifint(diff_lb, diff_ub, (1, len(dotcands) // 2))
        ndots = choice((dev, len(dotcands) - dev))
        ndots = min(max(1, ndots), len(dotcands))
        dots = sample(dotcands, ndots)
        nfullremcols = unifint(diff_lb, diff_ub, (1, 8))
        fullremcols = sample(remcols, nfullremcols)
        for ij in asindices(ulc):
            ulc = fill(ulc, choice(fullremcols), {ij})
        ulco = asobject(ulc)
        osf = (h//2, w//2)
        for d in dots:
            rsi = fill(rsi, dotcol, {add(osf, d)})
            rso = paint(rso, shift(ulco, d))
        gi = hconcat(hconcat(vconcat(ulc, ls), bar), rsi)
        go = hconcat(hconcat(vconcat(ulc, ls), bar), rso)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_855e0971(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        nbarsd = unifint(diff_lb, diff_ub, (1, 4))
        nbars = choice((nbarsd, 11 - nbarsd))
        nbars = max(3, nbars)
        h = unifint(diff_lb, diff_ub, (nbars, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        barsizes = [2] * nbars
        while sum(barsizes) < h:
            j = randint(0, nbars - 1)
            barsizes[j] += 1
        gi = tuple()
        go = tuple()
        locs = interval(0, w, 1)
        dotc = choice(cols)
        remcols = remove(dotc, cols)
        lastcol = -1
        nloclbs = [choice((0, 1)) for k in range(len(barsizes))]
        if sum(nloclbs) < 2:
            loc1, loc2 = sample(interval(0, len(nloclbs), 1), 2)
            nloclbs[loc1] = 1
            nloclbs[loc2] = 1
        for bs, nloclb in zip(barsizes, nloclbs):
            col = choice(remove(lastcol, remcols))
            gim = canvas(col, (bs, w))
            gom = canvas(col, (bs, w))
            nl = unifint(diff_lb, diff_ub, (nloclb, w // 2))
            chlocs = sample(locs, nl)
            for jj in chlocs:
                idx = (randint(0, bs - 1), jj)
                gim = fill(gim, dotc, {idx})
                gom = fill(gom, dotc, vfrontier(idx))
            lastcol = col
            gi = gi + gim
            go = go + gom
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_137eaa0f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 4))
        w = unifint(diff_lb, diff_ub, (2, 4))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        dotc = choice(remcols)
        remcols = remove(dotc, remcols)
        go = canvas(dotc, (h, w))
        inds = totuple(asindices(go))
        loc = choice(inds)
        reminds = remove(loc, inds)
        nc = unifint(diff_lb, diff_ub, (1, min(h * w - 1, 8)))
        choscols = sample(remcols, nc)
        cd = {c: set() for c in choscols}
        for c in choscols:
            ij = choice(reminds)
            cd[c].add(ij)
            reminds = remove(ij, reminds)
        for ri in reminds:
            cd[choice(choscols)].add(ri)
        for c, idxes in cd.items():
            go = fill(go, c, idxes)
        gih = unifint(diff_lb, diff_ub, (min(h, w) * 2, 30))
        giw = unifint(diff_lb, diff_ub, (min(h, w) * 2, 30))
        objs = tuple(
            normalize(insert((dotc, loc), frozenset({(c, ij) for ij in cd[c]}))) \
                for c in choscols
        )
        maxtr = min(h, w) * 2
        maxtrtot = 1000
        while True:
            succ = True
            gi = canvas(bgc, (gih, giw))
            inds = asindices(gi)
            for obj in objs:
                oh, ow = shape(obj)
                succ2 = False
                tr = 0
                while tr < maxtr and not succ2:
                    loci = randint(0, gih - oh)
                    locj = randint(0, giw - ow)
                    plcd = shift(obj, (loci, locj))
                    tr += 1
                    if toindices(plcd).issubset(inds):
                        succ2 = True
                if succ2:
                    gi = paint(gi, plcd)
                    inds = difference(inds, toindices(plcd))
                    inds = difference(inds, mapply(neighbors, toindices(plcd)))
                else:
                    succ = False
                    break
            if succ:
                break
            maxtrtot += 1
            if maxtrtot < 1000:
                break
            maxtr = int(maxtr * 1.5)
            gih = randint(gih, 30)
            giw = randint(giw, 30)
        return {'input': gi, 'output': go}

    def generate_31aa019c(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        while True:
            h = unifint(diff_lb, diff_ub, (5, 30))
            w = unifint(diff_lb, diff_ub, (5, 30))
            bgc = choice(cols)
            remcols = remove(bgc, cols)
            canv = canvas(bgc, (h, w))
            inds = totuple(asindices(canv))
            mp = (h * w) // 2 - 1
            ncols = unifint(diff_lb, diff_ub, (2, min(9, mp // 2 - 1)))
            chcols = sample(cols, ncols)
            trgcol = chcols[0]
            chcols = chcols[1:]
            dic = {c: set() for c in chcols}
            nnoise = unifint(diff_lb, diff_ub, (2 * (ncols - 1), mp))
            locc = choice(inds)
            inds = remove(locc, inds)
            noise = sample(inds, nnoise)
            for c in chcols:
                ij = choice(inds)
                dic[c].add(ij)
                inds = remove(ij, inds)
            for c in chcols:
                ij = choice(inds)
                dic[c].add(ij)
                inds = remove(ij, inds)
            for ij in noise:
                c = choice(chcols)
                dic[c].add(ij)
                inds = remove(ij, inds)
            gi = fill(canv, trgcol, {locc})
            for c, ss in dic.items():
                gi = fill(gi, c, ss)
            gi = fill(gi, trgcol, {locc})
            if len(sfilter(palette(gi), lambda c: colorcount(gi, c) == 1)) == 1:
                break
        lc = leastcolor(gi)
        locc = ofcolor(gi, lc)
        go = fill(canv, lc, locc)
        go = fill(go, 2, neighbors(first(locc)))
        return {'input': gi, 'output': go}

    def generate_2bee17df(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (7, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        c = canvas(bgc, (h, w))
        indord1 = apply(tojvec, interval(0, w, 1))
        indord2 = apply(rbind(astuple, w - 1), interval(1, h - 1, 1))
        indord3 = apply(lbind(astuple, h - 1), interval(w - 1, 0, -1))
        indord4 = apply(toivec, interval(h - 1, 0, -1))
        indord = indord1 + indord2 + indord3 + indord4
        k = len(indord)
        sp = randint(0, k)
        arr = indord[sp:] + indord[:sp]
        ep = randint(k // 2 - 3, k // 2 + 1)
        a = arr[:ep]
        b = arr[ep:]
        cola = choice(remcols)
        remcols = remove(cola, remcols)
        colb = choice(remcols)
        gi = fill(c, cola, a)
        gi = fill(gi, colb, b)
        nr = unifint(diff_lb, diff_ub, (1, min(4, min(h, w) // 2)))
        for kk in range(nr):
            ring = box(frozenset({(1 + kk, 1 + kk), (h - 1 - kk, w - 1 - kk)}))
            for br in (cola, colb):
                blacks = ofcolor(gi, br)
                bcands = totuple(ring & ofcolor(gi, bgc) & mapply(dneighbors, ofcolor(gi, br)))
                jj = len(bcands)
                jj2 = randint(max(0, jj // 2 - 2), min(jj, jj // 2 + 1))
                ss = sample(bcands, jj2)
                gi = fill(gi, br, ss)
        res = shift(merge(frontiers(trim(gi))), (1, 1))
        go = fill(gi, 3, res)
        return {'input': gi, 'output': go}

    def generate_50cb2852(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 8))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(3, 7)
            ow = randint(3, 7)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                remcols = remove(col, remcols)
                gi = fill(gi, col, bd)
                go = fill(go, 8, bd)
                go = fill(go, col, box(obj))
                box(obj)
                succ += 1
                indss = indss - bd
            tr += 1
        return {'input': gi, 'output': go}

    def generate_662c240a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        d = unifint(diff_lb, diff_ub, (2, 7))
        ng = unifint(diff_lb, diff_ub, (2, 30 // d))
        nc = unifint(diff_lb, diff_ub, (2, min(9, d ** 2)))
        c = canvas(-1, (d, d))
        inds = totuple(asindices(c))
        tria = sfilter(inds, lambda ij: ij[1] >= ij[0])
        tcolset = sample(cols, nc)
        triaf = frozenset((choice(tcolset), ij) for ij in tria)
        triaf = triaf | dmirror(triaf)
        gik = paint(c, triaf)
        ndistinv = unifint(diff_lb, diff_ub, (0, (d * (d - 1) // 2 - 1)))
        ndist = d * (d - 1) // 2 - ndistinv
        distinds = sample(difference(inds, sfilter(inds, lambda ij: ij[0] == ij[1])), ndist)
        
        for ij in distinds:
            if gik[ij[0]][ij[1]] == gik[ij[1]][ij[0]]:
                gik = fill(gik, choice(remove(gik[ij[0]][ij[1]], tcolset)), {ij})
            else:
                gik = fill(gik, gik[ij[1]][ij[0]], {ij})
        gi = gik
        go = tuple(e for e in gik)
        concatf = choice((hconcat, vconcat))
        for k in range(ng - 1):
            tria = sfilter(inds, lambda ij: ij[1] >= ij[0])
            tcolset = sample(cols, nc)
            triaf = frozenset((choice(tcolset), ij) for ij in tria)
            triaf = triaf | dmirror(triaf)
            gik = paint(c, triaf)
            if choice((True, False)):
                gi = concatf(gi, gik)
            else:
                gi = concatf(gik, gi)
        return {'input': gi, 'output': go}

    def generate_e8593010(diff_lb: float, diff_ub: float) -> dict:
        a = frozenset({frozenset({ORIGIN})})
        b = frozenset({frozenset({ORIGIN, RIGHT}), frozenset({ORIGIN, DOWN})})
        c = frozenset({
        frozenset({ORIGIN, DOWN, UNITY}),
        frozenset({ORIGIN, DOWN, RIGHT}),
        frozenset({UNITY, DOWN, RIGHT}),
        frozenset({UNITY, ORIGIN, RIGHT}),
        shift(frozenset({ORIGIN, UP, DOWN}), DOWN),
        shift(frozenset({ORIGIN, LEFT, RIGHT}), RIGHT)
        })
        a, b, c = totuple(a), totuple(b), totuple(c)
        prs = [(a, 3), (b, 2), (c, 1)]
        cols = difference(interval(0, 10, 1), (1, 2, 3))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        reminds = asindices(gi)
        nobjs = unifint(diff_lb, diff_ub, (1, ((h * w) // 2) // 2))
        maxtr = 10
        for k in range(nobjs):
            ntr = 0
            objs, col = choice(prs)
            obj = choice(objs)
            while ntr < maxtr:
                if len(reminds) == 0:
                    break
                loc = choice(totuple(reminds))
                olcd = shift(obj, loc)
                if olcd.issubset(reminds):
                    gi = fill(gi, fgc, olcd)
                    go = fill(go, col, olcd)
                    reminds = (reminds - olcd) - mapply(dneighbors, olcd)
                    break
                ntr += 1
        return {'input': gi, 'output': go}

    def generate_d9f24cd1(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        remcols = remove(linc, remcols)
        dotc = choice(remcols)
        locopts = interval(1, w - 1, 1)
        maxnloc = (w - 2) // 2
        nlins = unifint(diff_lb, diff_ub, (1, maxnloc))
        locs = []
        for k in range(nlins):
            if len(locopts) == 0:
                break
            loc = choice(locopts)
            locopts = remove(loc, locopts)
            locopts = remove(loc - 1, locopts)
            locopts = remove(loc + 1, locopts)
            locs.append(loc)
        ndots = unifint(diff_lb, diff_ub, (1, maxnloc))
        locopts = interval(1, w - 1, 1)
        dotlocs = []
        for k in range(ndots):
            if len(locopts) == 0:
                break
            loc = choice(locopts)
            locopts = remove(loc, locopts)
            locopts = remove(loc - 1, locopts)
            locopts = remove(loc + 1, locopts)
            dotlocs.append(loc)
        gi = canvas(bgc, (h, w))
        for l in locs:
            gi = fill(gi, linc, {(h - 1, l)})
        dotlocs2 = []
        for l in dotlocs:
            jj = randint(1, h - 2)
            gi = fill(gi, dotc, {(jj, l)})
            dotlocs2.append(jj)
        go = tuple(e for e in gi)
        for linloc in locs:
            if linloc in dotlocs:
                jj = dotlocs2[dotlocs.index(linloc)]
                go = fill(go, linc, connect((h - 1, linloc), (jj + 1, linloc)))
                go = fill(go, linc, connect((jj + 1, linloc + 1), (0, linloc + 1)))
            else:
                go = fill(go, linc, connect((h - 1, linloc), (0, linloc)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_90c28cc7(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 10))
        w = unifint(diff_lb, diff_ub, (2, 10))
        nc = unifint(diff_lb, diff_ub, (2, 9))
        gi = canvas(-1, (h, w))
        inds = totuple(asindices(gi))
        colss = sample(cols, nc)
        for ij in inds:
            gi = fill(gi, choice(colss), {ij})
        gi = dmirror(dedupe(dmirror(dedupe(gi))))
        go = tuple(e for e in gi)
        h, w = shape(gi)
        fullh = unifint(diff_lb, diff_ub, (h, 30))
        fullw = unifint(diff_lb, diff_ub, (w, 30))
        inh = unifint(diff_lb, diff_ub, (h, fullh))
        inw = unifint(diff_lb, diff_ub, (w, fullw))
        while h < inh or w < inw:
            opts = []
            if h < inh:
                opts.append((h, identity))
            elif w < inw:
                opts.append((w, dmirror))
            dim, mirrf = choice(opts)
            idx = randint(0, dim - 1)
            gi = mirrf(gi)
            gi = gi[:idx+1] + gi[idx:]
            gi = mirrf(gi)
            h, w = shape(gi)
        while h < fullh or w < fullw:
            opts = []
            if h < fullh:
                opts.append(identity)
            elif w < fullw:
                opts.append(dmirror)
            mirrf = choice(opts)
            gi = mirrf(gi)
            gi = merge(tuple(sample((((0,) * width(gi),), gi), 2)))
            gi = mirrf(gi)
            h, w = shape(gi)
        return {'input': gi, 'output': go}

    def generate_321b1fc6(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        objh = unifint(diff_lb, diff_ub, (2, 5))
        objw = unifint(diff_lb, diff_ub, (2, 5))
        bounds = asindices(canvas(0, (objh, objw)))
        shp = {choice(totuple(bounds))}
        nc = unifint(diff_lb, diff_ub, (2, len(bounds) - 2))
        for j in range(nc):
            ij = choice(totuple((bounds - shp) & mapply(dneighbors, shp)))
            shp.add(ij)
        shp = normalize(shp)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        dmyc = choice(remcols)
        remcols = remove(dmyc, remcols)
        oh, ow = shape(shp)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        shpp = shift(shp, (loci, locj))
        numco = unifint(diff_lb, diff_ub, (2, 8))
        colll = sample(remcols, numco)
        shppc = frozenset({(choice(colll), ij) for ij in shpp})
        while numcolors(shppc) == 1:
            shppc = frozenset({(choice(colll), ij) for ij in shpp})
        shppcn = normalize(shppc)
        gi = canvas(bgc, (h, w))
        gi = paint(gi, shppc)
        go = tuple(e for e in gi)
        ub = ((h * w) / (oh * ow)) // 2
        ub = max(1, ub)
        numlocs = unifint(diff_lb, diff_ub, (1, ub))
        cnt = 0
        fails = 0
        maxfails = 5 * numlocs
        idns = (asindices(gi) - shpp) - mapply(dneighbors, shpp)
        idns = sfilter(idns, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
        while cnt < numlocs and fails < maxfails:
            if len(idns) == 0:
                break
            loc = choice(totuple(idns))
            plcd = shift(shppcn, loc)
            plcdi = toindices(plcd)
            if plcdi.issubset(idns):
                go = paint(go, plcd)
                gi = fill(gi, dmyc, plcdi)
                cnt += 1
                idns = (idns - plcdi) - mapply(dneighbors, plcdi)
            else:
                fails += 1
        go = fill(go, bgc, shpp)
        return {'input': gi, 'output': go}

    def generate_6455b5f5(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 8))
        while True:
            h = unifint(diff_lb, diff_ub, (6, 30))
            w = unifint(diff_lb, diff_ub, (6, 30))
            bgc = choice(cols)
            fgc = choice(remove(bgc, cols))
            gi = canvas(bgc, (h, w))
            ub = int((h * w) ** 0.5 * 1.5)
            num = unifint(diff_lb, diff_ub, (1, ub))
            for k in range(num):
                objs = colorfilter(objects(gi, T, T, F), bgc)
                eligobjs = sfilter(objs, lambda o: height(o) > 2 or width(o) > 2)
                if len(eligobjs) == 0:
                    break
                if choice((True, False)):
                    ro = argmax(eligobjs, size)
                else:
                    ro = choice(totuple(eligobjs))
                if choice((True, False)):
                    vfr = height(ro) < width(ro)
                else:
                    vfr = choice((True, False))
                if vfr and width(ro) < 3:
                    vfr = False
                if (not vfr) and height(ro) < 3:
                    vfr = True
                if vfr:
                    j = randint(leftmost(ro)+1, rightmost(ro)-1)
                    ln = connect((uppermost(ro), j), (lowermost(ro), j))
                else:
                    j = randint(uppermost(ro)+1, lowermost(ro)-1)
                    ln = connect((j, leftmost(ro)), (j, rightmost(ro)))
                gi = fill(gi, fgc, ln)
            objs = colorfilter(objects(gi, T, T, F), bgc)
            if valmin(objs, size) != valmax(objs, size):
                break
        lblues = mfilter(objs, matcher(size, valmin(objs, size)))
        dblues = mfilter(objs, matcher(size, valmax(objs, size)))
        go = fill(gi, 8, lblues)
        go = fill(go, 1, dblues)
        return {'input': gi, 'output': go}

    def generate_4c5c2cf0(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        oh = unifint(diff_lb, diff_ub, (2, (h - 3) // 2))
        ow = unifint(diff_lb, diff_ub, (2, (w - 3) // 2))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        cc = choice(remcols)
        remcols = remove(cc, remcols)
        objc = choice(remcols)
        sg = canvas(bgc, (oh, ow))
        locc = (oh - 1, ow - 1)
        sg = fill(sg, cc, {locc})
        reminds = totuple(remove(locc, asindices(sg)))
        ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))
        cells = sample(reminds, ncells)
        while ncells == 5 and shape(cells) == (3, 3):
            ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))
            cells = sample(reminds, ncells)
        sg = fill(sg, objc, cells)
        G1 = sg
        G2 = vmirror(sg)
        G3 = hmirror(sg)
        G4 = vmirror(hmirror(sg))
        vbar = canvas(bgc, (oh, 1))
        hbar = canvas(bgc, (1, ow))
        cp = canvas(cc, (1, 1))
        topg = hconcat(hconcat(G1, vbar), G2)
        botg = hconcat(hconcat(G3, vbar), G4)
        ggm = hconcat(hconcat(hbar, cp), hbar)
        GG = vconcat(vconcat(topg, ggm), botg)
        gg = asobject(GG)
        canv = canvas(bgc, (h, w))
        loci = randint(0, h - 2 * oh - 1)
        locj = randint(0, w - 2 * ow - 1)
        loc = (loci, locj)
        go = paint(canv, shift(gg, loc))
        gi = paint(canv, shift(asobject(sg), loc))
        gi = fill(gi, cc, ofcolor(go, cc))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_56ff96f3(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 9))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(2, 7)
            ow = randint(2, 7)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                remcols = remove(col, remcols)
                if choice((True, False)):
                    cnrs = ((loci, locj), (loci + oh - 1, locj + ow - 1))
                else:
                    cnrs = ((loci + oh - 1, locj), (loci, locj + ow - 1))
                gi = fill(gi, col, cnrs)
                go = fill(go, col, bd)
                succ += 1
                indss = indss - bd
            tr += 1
        return {'input': gi, 'output': go}

    def generate_2c608aff(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        boxh = unifint(diff_lb, diff_ub, (2, h // 2))
        boxw = unifint(diff_lb, diff_ub, (2, w // 2))
        loci = randint(0, h - boxh)
        locj = randint(0, w - boxw)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ccol = choice(remcols)
        remcols = remove(ccol, remcols)
        dcol = choice(remcols)
        bd = backdrop(frozenset({(loci, locj), (loci + boxh - 1, locj + boxw - 1)}))
        gi = canvas(bgc, (h, w))
        gi = fill(gi, ccol, bd)
        reminds = totuple(asindices(gi) - backdrop(outbox(bd)))
        noiseb = max(1, len(reminds) // 4)
        nnoise = unifint(diff_lb, diff_ub, (0, noiseb))
        noise = sample(reminds, nnoise)
        gi = fill(gi, dcol, noise)
        go = tuple(e for e in gi)
        hs = interval(loci, loci + boxh, 1)
        ws = interval(locj, locj + boxw, 1)
        for ij in noise:
            a, b = ij
            if a in hs:
                go = fill(go, dcol, connect(ij, (a, locj)))
            elif b in ws:
                go = fill(go, dcol, connect(ij, (loci, b)))
        go = fill(go, ccol, bd)
        return {'input': gi, 'output': go}

    def generate_e98196ab(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (3, 14))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        remcols = remove(linc, remcols)
        topc = choice(remcols)
        remcols = remove(topc, remcols)
        botc = choice(remcols)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        nocc = unifint(diff_lb, diff_ub, (2, (h * w) // 2))
        subs = sample(inds, nocc)
        numa = randint(1, nocc - 1)
        A = sample(subs, numa)
        B = difference(subs, A)
        topg = fill(c, topc, A)
        botg = fill(c, botc, B)
        go = fill(topg, botc, B)
        br = canvas(linc, (1, w))
        gi = vconcat(vconcat(topg, br), botg)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_c9f8e694(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = 0
        remcols = remove(bgc, cols)
        sqc = choice(remcols)
        remcols = remove(sqc, remcols)
        ncols = unifint(diff_lb, diff_ub, (1, min(h, 8)))
        nsq = unifint(diff_lb, diff_ub, (1, 8))
        gir = canvas(bgc, (h, w - 1))
        gil = tuple((choice(remcols),) for j in range(h))
        inds = asindices(gir)
        succ = 0
        fails = 0
        maxfails = nsq * 5
        while succ < nsq and fails < maxfails:
            loci = randint(0, h - 3)
            locj = randint(0, w - 3)
            lock = randint(loci+1, min(loci + max(1, 2*h//3), h - 1))
            locl = randint(locj+1, min(locj + max(1, 2*w//3), w - 1))
            bd = backdrop(frozenset({(loci, locj), (lock, locl)}))
            if bd.issubset(inds):
                gir = fill(gir, sqc, bd)
                succ += 1
                indss = inds - bd
            else:
                fails += 1
        locs = ofcolor(gir, sqc)
        gil = tuple(e if idx in apply(first, locs) else (bgc,) for idx, e in enumerate(gil))
        fullobj = toobject(locs, hupscale(gil, w))
        gi = hconcat(gil, gir)
        giro = paint(gir, fullobj)
        go = hconcat(gil, giro)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_eb5a1d5d(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        d = unifint(diff_lb, diff_ub, (2, 10))
        go = canvas(-1, (d*2-1, d*2-1))
        colss = sample(cols, d)
        for j, cc in enumerate(colss):
            go = fill(go, cc, box(frozenset({(j, j), (2*d - 2 - j, 2*d - 2 - j)})))
        nvenl = unifint(diff_lb, diff_ub, (0, 30 - d))
        nhenl = unifint(diff_lb, diff_ub, (0, 30 - d))
        enl = [nvenl, nhenl]
        gi = tuple(e for e in go)
        while (enl[0] > 0 or enl[1] > 0) and max(shape(gi)) < 30:
            opts = []
            if enl[0] > 0:
                opts.append((identity, 0))
            if enl[1] > 0:
                opts.append((dmirror, 1))
            mirrf, ch = choice(opts)
            gi = mirrf(gi)
            idx = randint(0, len(gi) - 1)
            gi = gi[:idx+1] + gi[idx:]
            gi = mirrf(gi)
            enl[ch] -= 1
        return {'input': gi, 'output': go}

    def generate_82819916(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ass, bss = sample(remcols, 2)
        itv = interval(0, w, 1)
        na = randint(2, w - 2)
        alocs = sample(itv, na)
        blocs = difference(itv, alocs)
        if min(alocs) > min(blocs):
            alocs, blocs = blocs, alocs
        llocs = randint(0, h - 1)
        gi = canvas(bgc, (h, w))
        gi = fill(gi, ass, {(llocs, j) for j in alocs})
        gi = fill(gi, bss, {(llocs, j) for j in blocs})
        numl = unifint(diff_lb, diff_ub, (1, max(1, (h-1)//2)))
        remlocs = remove(llocs, interval(0, h, 1))
        for k in range(numl):
            lloc = choice(remlocs)
            remlocs = remove(lloc, remlocs)
            a, b = sample(remcols, 2)
            gi = fill(gi, a, {(lloc, j) for j in alocs})
            gi = fill(gi, b, {(lloc, j) for j in blocs})
        cutoff = min(blocs) + 1
        go = tuple(e for e in gi)
        gi = fill(gi, bgc, backdrop(frozenset({(0, cutoff), (h - 1, w - 1)})))
        gi = fill(gi, ass, {(llocs, j) for j in alocs})
        gi = fill(gi, bss, {(llocs, j) for j in blocs})
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_5daaa586(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (7, 30))
        loci1 = randint(1, h - 4)
        locj1 = randint(1, w - 4)
        loci1dev = unifint(diff_lb, diff_ub, (0, loci1 - 1))
        locj1dev = unifint(diff_lb, diff_ub, (0, locj1 - 1))
        loci1 -= loci1dev
        locj1 -= locj1dev
        loci2 = unifint(diff_lb, diff_ub, (loci1 + 2, h - 2))
        locj2 = unifint(diff_lb, diff_ub, (locj1 + 2, w - 2))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        c1, c2, c3, c4 = sample(remcols, 4)
        f1 = recolor(c1, hfrontier(toivec(loci1)))
        f2 = recolor(c2, hfrontier(toivec(loci2)))
        f3 = recolor(c3, vfrontier(tojvec(locj1)))
        f4 = recolor(c4, vfrontier(tojvec(locj2)))
        gi = canvas(bgc, (h, w))
        fronts = [f1, f2, f3, f4]
        shuffle(fronts)
        for fr in fronts:
            gi = paint(gi, fr)
        cands = totuple(ofcolor(gi, bgc))
        nn = len(cands)
        nnoise = unifint(diff_lb, diff_ub, (1, max(1, nn // 3)))
        noise = sample(cands, nnoise)
        gi = fill(gi, c1, noise)
        while len(frontiers(gi)) > 4:
            gi = fill(gi, bgc, noise)
            nnoise = unifint(diff_lb, diff_ub, (1, max(1, nn // 3)))
            noise = sample(cands, nnoise)
            if len(set(noise) & ofcolor(gi, c1)) >= len(ofcolor(gi, bgc)):
                break
            gi = fill(gi, c1, noise)
        go = crop(gi, (loci1, locj1), (loci2 - loci1 + 1, locj2 - locj1 + 1))
        ns = ofcolor(go, c1)
        go = fill(go, c1, mapply(rbind(shoot, (-1, 0)), ns))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_68b16354(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = hmirror(gi)
        return {'input': gi, 'output': go}

    def generate_bb43febb(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 8))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(3, 7)
            ow = randint(3, 7)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                remcols = remove(col, remcols)
                gi = fill(gi, col, bd)
                go = fill(go, 2, bd)
                go = fill(go, col, box(obj))
                succ += 1
                indss = indss - bd
            tr += 1
        return {'input': gi, 'output': go}

    def generate_9ecd008a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 15))
        w = h
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        remcols = sample(remcols, numcols)
        canv = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (1, h * w))
        bx = asindices(canv)
        obj = {(choice(remcols), choice(totuple(bx)))}
        for kk in range(nc - 1):
            dns = mapply(neighbors, toindices(obj))
            ch = choice(totuple(bx & dns))
            obj.add((choice(remcols), ch))
            bx = bx - {ch}
        gi = paint(canv, obj)
        tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])
        gi = paint(gi, tr)
        gi = hconcat(gi, vmirror(gi))
        gi = vconcat(gi, hmirror(gi))
        locidev = unifint(diff_lb, diff_ub, (1, 2*h))
        locjdev = unifint(diff_lb, diff_ub, (1, w))
        loci = 2*h - locidev
        locj = w - locjdev
        loci2 = unifint(diff_lb, diff_ub, (loci, 2*h - 1))
        locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))
        bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))
        go = subgrid(bd, gi)
        gi = fill(gi, 0, bd)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_f25ffba3(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 14))
        h = h * 2 + 1
        w = unifint(diff_lb, diff_ub, (3, 15))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        remcols = sample(remcols, numcols)
        canv = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (2, h * w - 2))
        bx = asindices(canv)
        obj = {(choice(remcols), choice(totuple(bx)))}
        for kk in range(nc - 1):
            dns = mapply(neighbors, toindices(obj))
            ch = choice(totuple(bx & dns))
            obj.add((choice(remcols), ch))
            bx = bx - {ch}
        while uppermost(obj) > h // 2 - 1 or lowermost(obj) < h // 2 + 1:
            dns = mapply(neighbors, toindices(obj))
            ch = choice(totuple(bx & dns))
            obj.add((choice(remcols), ch))
            bx = bx - {ch}
        gix = paint(canv, obj)
        gix = apply(rbind(order, matcher(identity, bgc)), gix)
        gi = hconcat(gix, canv)
        go = hconcat(gix, vmirror(gix))
        if choice((True, False)):
            gi = vmirror(gi)
            go = vmirror(go)
        if choice((True, False)):
            gi = hmirror(gi)
            go = hmirror(go)
        return {'input': gi, 'output': go}

    def generate_3bdb4ada(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 8))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            if choice((True, False)):
                oh = 3
                ow = unifint(diff_lb, diff_ub, (1, max(1, w // 2 - 1))) * 2 + 1
            else:
                ow = 3
                oh = unifint(diff_lb, diff_ub, (1, max(1, h // 2 - 1))) * 2 + 1
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                remcols = remove(col, remcols)
                gi = fill(gi, col, bd)
                go = fill(go, col, bd)
                if oh == 3:
                    ln = {(loci + 1, j) for j in range(locj+1, locj+ow, 2)}
                else:
                    ln = {(j, locj + 1) for j in range(loci+1, loci+oh, 2)}
                go = fill(go, bgc, ln)
                succ += 1
                indss = indss - bd
            tr += 1
        return {'input': gi, 'output': go}

    def generate_2013d3e2(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 10))
        w = h
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        remcols = sample(remcols, numcols)
        canv = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (2, h * w - 1))
        bx = asindices(canv)
        obj = {(choice(remcols), choice(totuple(bx)))}
        for kk in range(nc - 1):
            dns = mapply(neighbors, toindices(obj))
            ch = choice(totuple(bx & dns))
            obj.add((choice(remcols), ch))
            bx = bx - {ch}
        gi = paint(canv, obj)
        gi1 = hconcat(gi, rot90(gi))
        gi2 = hconcat(rot270(gi), rot180(gi))
        gi = vconcat(gi1, gi2)
        fullh = unifint(diff_lb, diff_ub, (2*h, 30))
        fullw = unifint(diff_lb, diff_ub, (2*w, 30))
        gio = asobject(gi)
        gic = canvas(bgc, (fullh, fullw))
        loci = randint(0, fullh - 2*h)
        locj = randint(0, fullw - 2*w)
        gi = paint(gic, shift(gio, (loci, locj)))
        reminds = difference(asindices(gi), ofcolor(gi, bgc))
        go = lefthalf(tophalf(subgrid(reminds, gi)))
        return {'input': gi, 'output': go}

    def generate_aabf363d(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 28))
        w = unifint(diff_lb, diff_ub, (3, 28))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        cola = choice(remcols)
        remcols = remove(cola, remcols)
        colb = choice(remcols)
        c = canvas(bgc, (h, w))
        bounds = asindices(c)
        sp = choice(totuple(bounds))
        ub = min(h * w - 1, max(1, (2/3) * h * w))
        ncells = unifint(diff_lb, diff_ub, (1, ub))
        shp = {sp}
        for k in range(ncells):
            ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))
            shp.add(ij)
        shp = shift(shp, (1, 1))
        c2 = canvas(bgc, (h+2, w+2))
        gi = fill(c2, cola, shp)
        go = fill(c2, colb, shp)
        gi = fill(gi, colb, {choice(totuple(ofcolor(gi, bgc)))})
        return {'input': gi, 'output': go}

    def generate_d037b0a7(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        nlocs = unifint(diff_lb, diff_ub, (1, w))
        locs = sample(interval(0, w, 1), nlocs)
        for j in locs:
            col = choice(remcols)
            loci = randint(0, h - 1)
            loc = (loci, j)
            gi = fill(gi, col, {loc})
            go = fill(go, col, connect(loc, (h - 1, j)))
        return {'input': gi, 'output': go}

    def generate_e26a3af2(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        nr = unifint(diff_lb, diff_ub, (1, 10))
        w = unifint(diff_lb, diff_ub, (4, 30))
        scols = sample(cols, nr)
        sgs = [canvas(col, (2, w)) for col in scols]
        numexp = unifint(diff_lb, diff_ub, (0, 30 - nr))
        for k in range(numexp):
            idx = randint(0, nr - 1)
            sgs[idx] = sgs[idx] + sgs[idx][-1:]
        sgs2 = []
        for idx, col in enumerate(scols):
            sg = sgs[idx]
            a, b = shape(sg)
            ub = (a * b) // 2 - 1
            nnoise = unifint(diff_lb, diff_ub, (0, ub))
            inds = totuple(asindices(sg))
            noise = sample(inds, nnoise)
            oc = remove(col, cols)
            noise = frozenset({(choice(oc), ij) for ij in noise})
            sg2 = paint(sg, noise)
            for idxx in [0, -1]:
                while sum([e == col for e in sg2[idxx]]) < w // 2:
                    locs = [j for j, e in enumerate(sg2[idxx]) if e != col]
                    ch = choice(locs)
                    if idxx == 0:
                        sg2 = (sg2[0][:ch] + (col,) + sg2[0][ch+1:],) + sg2[1:]
                    else:
                        sg2 = sg2[:-1] + (sg2[-1][:ch] + (col,) + sg2[-1][ch+1:],)
            sgs2.append(sg2)
        gi = tuple(row for sg in sgs2 for row in sg)
        go = tuple(row for sg in sgs for row in sg)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_b8825c91(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 15))
        w = h
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        remcols = sample(remcols, numcols)
        canv = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (1, h * w))
        bx = asindices(canv)
        obj = {(choice(remcols), choice(totuple(bx)))}
        for kk in range(nc - 1):
            dns = mapply(neighbors, toindices(obj))
            ch = choice(totuple(bx & dns))
            obj.add((choice(remcols), ch))
            bx = bx - {ch}
        gi = paint(canv, obj)
        tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])
        gi = paint(gi, tr)
        gi = hconcat(gi, vmirror(gi))
        gi = vconcat(gi, hmirror(gi))
        go = tuple(e for e in gi)
        for alph in (2, 1):
            locidev = unifint(diff_lb, diff_ub, (1, alph*h))
            locjdev = unifint(diff_lb, diff_ub, (1, w))
            loci = alph*h - locidev
            locj = w - locjdev
            loci2 = unifint(diff_lb, diff_ub, (loci, alph*h - 1))
            locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))
            bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))
            gi = fill(gi, 4, bd)
            gi, go = rot180(gi), rot180(go)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_ba97ae07(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        lineh = unifint(diff_lb, diff_ub, (1, h // 3))
        linew = unifint(diff_lb, diff_ub, (1, w // 3))
        loci = randint(1, h - lineh - 1)
        locj = randint(1, w - linew - 1)
        acol = choice(remcols)
        bcol = choice(remove(acol, remcols))
        for a in range(lineh):
            gi = fill(gi, acol, connect((loci+a, 0), (loci+a, w-1)))
        for b in range(linew):
            gi = fill(gi, bcol, connect((0, locj+b), (h-1, locj+b)))
        for b in range(linew):
            go = fill(go, bcol, connect((0, locj+b), (h-1, locj+b)))
        for a in range(lineh):
            go = fill(go, acol, connect((loci+a, 0), (loci+a, w-1)))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_c909285e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        nfronts = unifint(diff_lb, diff_ub, (1, (h + w) // 2))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        boxcol = choice(remcols)
        remcols = remove(boxcol, remcols)
        gi = canvas(bgc, (h, w))
        inds = totuple(asindices(gi))
        for k in range(nfronts):
            ff = choice((hfrontier, vfrontier))
            loc = choice(inds)
            inds = remove(loc, inds)
            col = choice(remcols)
            gi = fill(gi, col, ff(loc))
        oh = unifint(diff_lb, diff_ub, (3, max(3, (h - 2) // 2)))
        ow = unifint(diff_lb, diff_ub, (3, max(3, (w - 2) // 2)))
        loci = randint(1, h - oh - 1)
        locj = randint(1, w - ow - 1)
        bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
        gi = fill(gi, boxcol, bx)
        go = subgrid(bx, gi)
        return {'input': gi, 'output': go}

    def generate_d511f180(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (5, 8))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        numc = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(cols, numc)
        c = canvas(-1, (h, w))
        inds = totuple(asindices(c))
        numbg = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        bginds = sample(inds, numbg)
        idx = randint(0, numbg)
        blues = bginds[:idx]
        greys = bginds[idx:]
        rem = difference(inds, bginds)
        gi = fill(c, 8, blues)
        gi = fill(gi, 5, greys)
        go = fill(c, 5, blues)
        go = fill(go, 8, greys)
        for ij in rem:
            col = choice(ccols)
            gi = fill(gi, col, {ij})
            go = fill(go, col, {ij})
        return {'input': gi, 'output': go}

    def generate_d0f5fe59(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nobjs = unifint(diff_lb, diff_ub, (1, min(30, (h * w) // 9)))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        nfound = 0
        trials = 0
        maxtrials = nobjs * 5
        gi = canvas(bgc, (h, w))
        inds = asindices(gi)
        while trials < maxtrials and nfound < nobjs:
            oh = unifint(diff_lb, diff_ub, (1, 5))
            ow = unifint(diff_lb, diff_ub, (1, 5))
            bx = asindices(canvas(-1, (oh, ow)))
            sp = choice(totuple(bx))
            shp = {sp}
            dev = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))
            ncells = choice((dev, oh * ow - dev))
            ncells = min(max(1, ncells), oh * ow - 1)
            for k in range(ncells):
                ij = choice(totuple((bx - shp) & mapply(dneighbors, shp)))
                shp.add(ij)
            shp = normalize(shp)
            if len(inds) == 0:
                break
            loc = choice(totuple(inds))
            plcd = shift(shp, loc)
            if plcd.issubset(inds):
                gi = fill(gi, fgc, plcd)
                inds = (inds - plcd) - mapply(neighbors, plcd)
                nfound += 1
            trials += 1
        go = canvas(bgc, (nfound, nfound))
        go = fill(go, fgc, connect((0, 0), (nfound - 1, nfound - 1)))
        return {'input': gi, 'output': go}

    def generate_6e82a1ae(diff_lb: float, diff_ub: float) -> dict:
        b = frozenset({frozenset({ORIGIN, RIGHT}), frozenset({ORIGIN, DOWN})})
        c = frozenset({
        frozenset({ORIGIN, DOWN, UNITY}),
        frozenset({ORIGIN, DOWN, RIGHT}),
        frozenset({UNITY, DOWN, RIGHT}),
        frozenset({UNITY, ORIGIN, RIGHT}),
        shift(frozenset({ORIGIN, UP, DOWN}), DOWN),
        shift(frozenset({ORIGIN, LEFT, RIGHT}), RIGHT)
        })
        d = set()
        for k in range(100):
            shp = {(0, 0)}
            for jj in range(3):
                shp.add(choice(totuple(mapply(dneighbors, shp) - shp)))
            shp = frozenset(normalize(shp))
            d.add(shp)
        d = frozenset(d)
        d, b, c = totuple(d), totuple(b), totuple(c)
        prs = [(b, 3), (c, 2), (d, 1)]
        cols = difference(interval(0, 10, 1), (1, 2, 3))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        reminds = asindices(gi)
        nobjs = unifint(diff_lb, diff_ub, (1, ((h * w) // 2) // 3))
        maxtr = 10
        for k in range(nobjs):
            ntr = 0
            objs, col = choice(prs)
            obj = choice(objs)
            while ntr < maxtr:
                loc = choice(totuple(reminds))
                olcd = shift(obj, loc)
                if olcd.issubset(reminds):
                    gi = fill(gi, fgc, olcd)
                    go = fill(go, col, olcd)
                    reminds = (reminds - olcd) - mapply(dneighbors, olcd)
                    break
                ntr += 1
        return {'input': gi, 'output': go}

    def generate_f2829549(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        remcols = remove(linc, remcols)
        acol = choice(remcols)
        remcols = remove(acol, remcols)
        bcol = choice(remcols)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        bar = canvas(linc, (h, 1))
        numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numa = choice((numadev, h * w - numadev))
        numb = choice((numadev, h * w - numbdev))
        numa = min(max(1, numa), h * w - 1)
        numb = min(max(1, numb), h * w - 1)
        aset = sample(inds, numa)
        bset = sample(inds, numb)
        A = fill(c, acol, aset)
        B = fill(c, bcol, bset)
        gi = hconcat(hconcat(A, bar), B)
        res = (set(inds) - set(aset)) & (set(inds) - set(bset))
        go = fill(c, 3, res)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_ce22a75a(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(1, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        c = canvas(bgc, (h, w))
        ndots = unifint(diff_lb, diff_ub, (1, (h * w) // 3))
        dots = sample(totuple(asindices(c)), ndots)
        gi = fill(c, fgc, dots)
        go = fill(c, 1, mapply(neighbors, dots))
        go = fill(go, 1, dots)
        return {'input': gi, 'output': go}

    def generate_3c9b0459(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (1, 30)
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = rot180(gi)
        return {'input': gi, 'output': go}

    def generate_99b1bc43(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        remcols = remove(linc, remcols)
        acol = choice(remcols)
        remcols = remove(acol, remcols)
        bcol = choice(remcols)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        bar = canvas(linc, (h, 1))
        numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numa = choice((numadev, h * w - numadev))
        numb = choice((numadev, h * w - numbdev))
        numa = min(max(1, numa), h * w - 1)
        numb = min(max(1, numb), h * w - 1)
        aset = sample(inds, numa)
        bset = sample(inds, numb)
        A = fill(c, acol, aset)
        B = fill(c, bcol, bset)
        gi = hconcat(hconcat(A, bar), B)
        res = (set(bset) - set(aset)) | (set(aset) - set(bset))
        go = fill(c, 3, res)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_b6afb2da(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 4))    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 9))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(3, 7)
            ow = randint(3, 7)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                remcols = remove(col, remcols)
                gi = fill(gi, col, bd)
                go = fill(go, 2, bd)
                go = fill(go, 4, box(bd))
                go = fill(go, 1, corners(bd))
                succ += 1
                indss = indss - bd
            tr += 1
        return {'input': gi, 'output': go}

    def generate_c8f0f002(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(7, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        numc = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(cols, numc)
        c = canvas(-1, (h, w))
        inds = totuple(asindices(c))
        numo = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        orng = sample(inds, numo)
        rem = difference(inds, orng)
        gi = fill(c, 7, orng)
        go = fill(c, 5, orng)
        for ij in rem:
            col = choice(ccols)
            gi = fill(gi, col, {ij})
            go = fill(go, col, {ij})
        return {'input': gi, 'output': go}

    def generate_54d82841(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        nshps = unifint(diff_lb, diff_ub, (1, w // 3))
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        locs = interval(1, w - 1, 1)
        for k in range(nshps):
            if len(locs) == 0:
                break
            loc = choice(locs)
            locs = remove(loc, locs)
            locs = remove(loc + 1, locs)
            locs = remove(loc - 1, locs)
            locs = remove(loc + 2, locs)
            locs = remove(loc - 2, locs)
            loci = randint(1, h - 1)
            col = choice(remcols)
            ij = (loci, loc)
            shp = neighbors(ij) - connect((loci + 1, loc - 1), (loci + 1, loc + 1))
            gi = fill(gi, col, shp)
            go = fill(go, col, shp)
            go = fill(go, 4, {(h - 1, loc)})
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_d631b094(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        bgc = 0
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        nc = unifint(diff_lb, diff_ub, (1, min(30, (h * w) // 2 - 1)))
        c = canvas(bgc, (h, w))
        cands = totuple(asindices(c))
        cels = sample(cands, nc)
        gi = fill(c, fgc, cels)
        go = canvas(fgc, (1, nc))
        return {'input': gi, 'output': go}

    def generate_7c008303(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 13))
        w = unifint(diff_lb, diff_ub, (2, 13))
        h = h * 2
        w = w * 2
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        remcols = remove(linc, remcols)
        fgc = choice(remcols)
        remcols = remove(fgc, remcols)
        fremcols = sample(remcols, unifint(diff_lb, diff_ub, (1, 4)))
        qc = [choice(fremcols) for j in range(4)]
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        ncd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        nc = choice((ncd, h * w - ncd))
        nc = min(max(0, nc), h * w)
        cels = sample(inds, nc)
        go = fill(c, fgc, cels)
        gi = canvas(bgc, (h + 3, w + 3))
        gi = paint(gi, shift(asobject(go), (3, 3)))
        gi = fill(gi, linc, connect((2, 0), (2, w + 2)))
        gi = fill(gi, linc, connect((0, 2), (h + 2, 2)))
        gi = fill(gi, qc[0], {(0, 0)})
        gi = fill(gi, qc[1], {(0, 1)})
        gi = fill(gi, qc[2], {(1, 0)})
        gi = fill(gi, qc[3], {(1, 1)})
        A = lefthalf(tophalf(go))
        B = righthalf(tophalf(go))
        C = lefthalf(bottomhalf(go))
        D = righthalf(bottomhalf(go))
        A2 = replace(A, fgc, qc[0])
        B2 = replace(B, fgc, qc[1])
        C2 = replace(C, fgc, qc[2])
        D2 = replace(D, fgc, qc[3])
        go = vconcat(hconcat(A2, B2), hconcat(C2, D2))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_dae9d2b5(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(6, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        acol = choice(remcols)
        remcols = remove(acol, remcols)
        bcol = choice(remcols)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numa = choice((numadev, h * w - numadev))
        numb = choice((numadev, h * w - numbdev))
        numa = min(max(1, numa), h * w - 1)
        numb = min(max(1, numb), h * w - 1)
        aset = sample(inds, numa)
        bset = sample(inds, numb)
        if len(set(aset) & set(bset)) == 0:
            bset = bset[:-1] + [choice(aset)]
        A = fill(c, acol, aset)
        B = fill(c, bcol, bset)
        gi = hconcat(A, B)
        res = set(aset) | set(bset)
        go = fill(c, 6, res)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_aedd82e4(diff_lb: float, diff_ub: float) -> dict:
        colopts = remove(1, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = 0
        remcols = remove(bgc, colopts)
        c = canvas(bgc, (h, w))
        card_bounds = (0, max(0, (h * w) // 2 - 1))
        num = unifint(diff_lb, diff_ub, card_bounds)
        numcols = unifint(diff_lb, diff_ub, (0, min(8, num)))
        inds = totuple(asindices(c))
        chosinds = sample(inds, num)
        choscols = sample(remcols, numcols)
        locs = interval(0, len(chosinds), 1)
        choslocs = sample(locs, numcols)
        gi = canvas(bgc, (h, w))
        for col, endidx in zip(choscols, sorted(choslocs)[::-1]):
            gi = fill(gi, col, chosinds[:endidx])
        objs = objects(gi, F, F, T)
        res = merge(sizefilter(objs, 1))
        go = fill(gi, 1, res)
        return {'input': gi, 'output': go}

    def generate_c9e6f938(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (1, 30)
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 15))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = hconcat(gi, vmirror(gi))
        return {'input': gi, 'output': go}

    def generate_913fb3ed(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (1, 30)
        cols = difference(interval(0, 10, 1), (1, 2, 3, 4, 6, 8))
        sr = (2, 3, 8)
        tr = (1, 6, 4)
        prs = list(zip(sr, tr))
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        numc = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 10)))
        inds = asindices(gi)
        for k in range(numc):
            if len(inds) == 0:
                break
            loc = choice(totuple(inds))
            a, b = choice(prs)
            inds = (inds - neighbors(loc)) - outbox(neighbors(loc))
            inds = remove(loc, inds)
            gi = fill(gi, a, {loc})
            go = fill(go, a, {loc})
            go = fill(go, b, neighbors(loc))
        return {'input': gi, 'output': go}

    def generate_6430c8c4(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        remcols = remove(linc, remcols)
        acol = choice(remcols)
        remcols = remove(acol, remcols)
        bcol = choice(remcols)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        bar = canvas(linc, (h, 1))
        numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numa = choice((numadev, h * w - numadev))
        numb = choice((numadev, h * w - numbdev))
        numa = min(max(1, numa), h * w - 1)
        numb = min(max(1, numb), h * w - 1)
        aset = sample(inds, numa)
        bset = sample(inds, numb)
        A = fill(c, acol, aset)
        B = fill(c, bcol, bset)
        gi = hconcat(hconcat(A, bar), B)
        res = (set(inds) - set(aset)) - set(bset)
        go = fill(c, 3, res)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_c0f76784(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (6, 7, 8))    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, len(remcols)))
        ccols = sample(remcols, numcols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 20))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(indss) == 0:
                break
            oh = choice((3, 4, 5))
            ow = oh
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(ccols)
            if bd.issubset(indss):
                gi = fill(gi, col, bd)
                go = fill(go, col, bd)
                ccc = oh + 3
                bdx = backdrop(inbox(obj))
                gi = fill(gi, bgc, bdx)
                go = fill(go, ccc, bdx)
                succ += 1
                indss = (indss - bd) - outbox(bd)
            tr += 1
        return {'input': gi, 'output': go}

    def generate_3af2c5a8(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (1, 30)
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 15))
        w = unifint(diff_lb, diff_ub, (1, 15))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = hconcat(gi, vmirror(gi))
        go = vconcat(go, hmirror(go))
        return {'input': gi, 'output': go}

    def generate_496994bd(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 14))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        remcols = sample(remcols, numcols)
        canv = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (2, h * w - 1))
        bx = asindices(canv)
        obj = {
            (choice(remcols), choice(totuple(sfilter(bx, lambda ij: ij[0] < h//2)))),
            (choice(remcols), choice(totuple(sfilter(bx, lambda ij: ij[0] > h//2))))
        }
        for kk in range(nc - 2):
            dns = mapply(neighbors, toindices(obj))
            ch = choice(totuple(bx & dns))
            obj.add((choice(remcols), ch))
            bx = bx - {ch}
        gix = paint(canv, obj)
        gix = apply(rbind(order, matcher(identity, bgc)), gix)
        flag = choice((True, False))
        gi = hconcat(gix, canv if flag else hconcat(canvas(bgc, (h, 1)), canv))
        go = hconcat(gix, vmirror(gix) if flag else hconcat(canvas(bgc, (h, 1)), vmirror(gix)))
        if choice((True, False)):
            gi = vmirror(gi)
            go = vmirror(go)
        if choice((True, False)):
            gi = hmirror(gi)
            go = hmirror(go)
        return {'input': gi, 'output': go}

    def generate_bd4472b8(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 28))
        w = unifint(diff_lb, diff_ub, (2, 8))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        ccols = sample(remcols, w)
        cc = (tuple(ccols),)
        br = canvas(linc, (1, w))
        lp = canvas(bgc, (h, w))
        gi = vconcat(vconcat(cc, br), lp)
        go = vconcat(vconcat(cc, br), lp)
        pt = hupscale(dmirror(cc), w)
        pto = asobject(pt)
        idx = 2
        while idx < h+3:
            go = paint(go, shift(pto, (idx, 0)))
            idx += w
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_fafffa47(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        acol = choice(remcols)
        remcols = remove(acol, remcols)
        bcol = choice(remcols)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numa = choice((numadev, h * w - numadev))
        numb = choice((numadev, h * w - numbdev))
        numa = min(max(1, numa), h * w - 1)
        numb = min(max(1, numb), h * w - 1)
        aset = sample(inds, numa)
        bset = sample(inds, numb)
        A = fill(c, acol, aset)
        B = fill(c, bcol, bset)
        gi = hconcat(A, B)
        res = set(inds) - (set(aset) | set(bset))
        go = fill(c, 2, res)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_67e8384a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 14))
        w = unifint(diff_lb, diff_ub, (1, 14))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 9))
        remcols = sample(remcols, numcols)
        canv = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (1, h * w))
        bx = asindices(canv)
        obj = {(choice(remcols), choice(totuple(bx)))}
        for kk in range(nc - 1):
            dns = mapply(neighbors, toindices(obj))
            ch = choice(totuple(bx & dns))
            obj.add((choice(remcols), ch))
            bx = bx - {ch}
        gi = paint(canv, obj)
        go = paint(canv, obj)
        go = hconcat(go, vmirror(go))
        go = vconcat(go, hmirror(go))
        return {'input': gi, 'output': go}

    def generate_ed36ccf7(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = rot270(gi)
        return {'input': gi, 'output': go}

    def generate_67a3c6ac(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = vmirror(gi)
        return {'input': gi, 'output': go}

    def generate_a416b8f3(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 30))
        w = unifint(diff_lb, diff_ub, (1, 15))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = hconcat(gi, gi)
        return {'input': gi, 'output': go}

    def generate_d10ecb37(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = crop(gi, (0, 0), (2, 2))
        return {'input': gi, 'output': go}

    def generate_5bd6f4ac(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = rot90(crop(rot270(gi), (0, 0), (3, 3)))
        return {'input': gi, 'output': go}

    def generate_7b7f7511(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 15))
        bgc = choice(cols)
        go = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, min(9, h * w - 1)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(go))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            go = fill(go, col, chos)
            inds = difference(inds, chos)
        if choice((True, False)):
            go = dmirror(go)
            gi = vconcat(go, go)
        else:
            gi = hconcat(go, go)
        return {'input': gi, 'output': go}

    def generate_c59eb873(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 15))
        w = unifint(diff_lb, diff_ub, (1, 15))
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (0, min(9, h * w)))
        colsch = sample(remcols, numc)
        inds = totuple(asindices(gi))
        for col in colsch:
            num = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // numc)))
            chos = sample(inds, num)
            gi = fill(gi, col, chos)
            inds = difference(inds, chos)
        go = upscale(gi, 2)
        return {'input': gi, 'output': go}

    def generate_b1948b0a(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(6, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        npd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        np = choice((npd, h * w - npd))
        np = min(max(0, npd), h * w)
        gi = canvas(6, (h, w))
        inds = totuple(asindices(gi))
        pp = sample(inds, np)
        npp = difference(inds, pp)
        for ij in npp:
            gi = fill(gi, choice(cols), {ij})
        go = fill(gi, 2, pp)
        return {'input': gi, 'output': go}

    def generate_25ff71a9(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        nc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        c = canvas(bgc, (h, w))
        bounds = asindices(c)
        ch = choice(totuple(bounds))
        shp = {ch}
        bounds = remove(ch, bounds)
        for j in range(nc-1):
            shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))
        shp = normalize(shp)
        oh, ow = shape(shp)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        loc = (loci, locj)
        plcd = shift(shp, loc)
        gi = fill(c, fgc, plcd)
        go = fill(c, fgc, shift(plcd, (1, 0)))
        return {'input': gi, 'output': go}

    def generate_f25fbde4(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        ncd = unifint(diff_lb, diff_ub, (1, max(1, (min(15, h-1) * min(15, w-1)) // 2)))
        nc = choice((ncd, (h-1) * (w-1) - ncd))
        nc = min(max(1, ncd), (h-1) * (w-1) - 1)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        c = canvas(bgc, (h, w))
        bounds = asindices(canvas(-1, (min(15, h - 1), min(15, w - 1))))
        ch = choice(totuple(bounds))
        shp = {ch}
        bounds = remove(ch, bounds)
        for j in range(nc):
            shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))
        shp = normalize(shp)
        oh, ow = shape(shp)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        loc = (loci, locj)
        plcd = shift(shp, loc)
        gi = fill(c, fgc, plcd)
        go = compress(gi)
        go = upscale(go, 2)
        return {'input': gi, 'output': go}

    def generate_a740d043(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(0, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        ncd = unifint(diff_lb, diff_ub, (1, max(1, ((h-1) * (w-1)) // 2)))
        nc = choice((ncd, (h-1) * (w-1) - ncd))
        nc = min(max(1, ncd), (h-1) * (w-1) - 1)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, len(remcols)))
        remcols = sample(remcols, numc)
        c = canvas(bgc, (h, w))
        bounds = asindices(canvas(-1, (h - 1, w - 1)))
        ch = choice(totuple(bounds))
        shp = {ch}
        bounds = remove(ch, bounds)
        for j in range(nc):
            shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))
        shp = normalize(shp)
        oh, ow = shape(shp)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        loc = (loci, locj)
        plcd = shift(shp, loc)
        obj = {(choice(remcols), ij) for ij in plcd}
        gi = paint(c, obj)
        go = compress(gi)
        go = replace(go, bgc, 0)
        return {'input': gi, 'output': go}

    def generate_be94b721(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        no = unifint(diff_lb, diff_ub, (3, max(3, (h * w) // 16)))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        c = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (no+1, max(no+1, 2*no)))
        inds = asindices(c)
        ch = choice(totuple(inds))
        shp = {ch}
        inds = remove(ch, inds)
        for k in range(nc - 1):
            shp.add(choice(totuple((inds - shp) & mapply(dneighbors, shp))))
        inds = (inds - shp) - mapply(neighbors, shp)
        trgc = choice(remcols)
        gi = fill(c, trgc, shp)
        go = fill(canvas(bgc, shape(shp)), trgc, normalize(shp))
        for k in range(no):
            if len(inds) == 0:
                break
            ch = choice(totuple(inds))
            shp = {ch}
            nc2 = unifint(diff_lb, diff_ub, (1, nc - 1))
            for k in range(nc2 - 1):
                cands = totuple((inds - shp) & mapply(dneighbors, shp))
                if len(cands) == 0:
                    break
                shp.add(choice(cands))
            col = choice(remcols)
            gi = fill(gi, col, shp)
            inds = (inds - shp) - mapply(neighbors, shp)
        return {'input': gi, 'output': go}

    def generate_44d8ac46(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 10))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            tr += 1
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(5, 7)
            ow = randint(5, 7)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                ensuresq = choice((True, False))
                if ensuresq:
                    dim = randint(1, min(oh, ow) - 2)
                    iloci = randint(1, oh - dim - 1)
                    ilocj = randint(1, ow - dim - 1)
                    inpart = backdrop({(loci + iloci, locj + ilocj), (loci + iloci + dim - 1, locj + ilocj + dim - 1)})
                else:
                    cnds = backdrop(inbox(bd))
                    ch = choice(totuple(cnds))
                    inpart = {ch}
                    kk = unifint(diff_lb, diff_ub, (1, len(cnds)))
                    for k in range(kk - 1):
                        inpart.add(choice(totuple((cnds - inpart) & mapply(dneighbors, inpart))))
                inpart = frozenset(inpart)
                hi, wi = shape(inpart)
                if hi == wi and len(inpart) == hi * wi:
                    incol = 2
                else:
                    incol = bgc
                gi = fill(gi, col, bd)
                go = fill(go, col, bd)
                gi = fill(gi, bgc, inpart)
                go = fill(go, incol, inpart)
                succ += 1
                indss = (indss - bd) - outbox(bd)
        return {'input': gi, 'output': go}

    def generate_3618c87e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc, linc, dotc = sample(cols, 3)
        c = canvas(bgc, (h, w))
        ln = connect((0, 0), (0, w - 1))
        nlocs = unifint(diff_lb, diff_ub, (1, w//2))
        locs = []
        opts = interval(0, w, 1)
        for k in range(nlocs):
            if len(opts) == 0:
                break
            ch = choice(opts)
            locs.append(ch)
            opts = remove(ch, opts)
            opts = remove(ch-1, opts)
            opts = remove(ch+1, opts)
        nlocs = len(opts)
        gi = fill(c, linc, ln)
        go = fill(c, linc, ln)
        for j in locs:
            hh = randint(1, h - 3)
            lnx = connect((0, j), (hh, j))
            gi = fill(gi, linc, lnx)
            go = fill(go, linc, lnx)
            gi = fill(gi, dotc, {(hh+1, j)})
            go = fill(go, dotc, {(0, j)})
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_b27ca6d3(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc, dotc = sample(cols, 2)
        c = canvas(bgc, (h, w))
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        ndots = unifint(diff_lb, diff_ub, (0, (h * w) // 5))
        nbars = unifint(diff_lb, diff_ub, (0, (h * w) // 12))
        dot = frozenset({(dotc, (1, 1))}) | recolor(bgc, dneighbors((1, 1)))
        bar1 = fill(canvas(bgc, (4, 3)), dotc, {(1, 1), (2, 1)})
        bar2 = dmirror(bar1)
        bar1 = asobject(bar1)
        bar2 = asobject(bar2)
        opts = [dot] * ndots + [choice((bar1, bar2)) for k in range(nbars)]
        shuffle(opts)
        inds = shift(asindices(canvas(-1, (h+2, w+2))), (-1, -1))
        for elem in opts:
            loc = (-1, -1)
            tr = 0
            while not toindices(shift(elem, loc)).issubset(inds) and tr < 5:
                loc = choice(totuple(inds))
                tr += 1
            xx = shift(elem, loc)
            if toindices(xx).issubset(inds):
                gi = paint(gi, xx)
                if len(elem) == 12:
                    go = paint(go, {cel if cel[0] != bgc else (3, cel[1]) for cel in xx})
                else:
                    go = paint(go, xx)
                inds = inds - toindices(xx)
        return {'input': gi, 'output': go}

    def generate_46f33fce(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 7))
        w = unifint(diff_lb, diff_ub, (2, 7))
        nc = unifint(diff_lb, diff_ub, (0, (h * w) // 2 - 1))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        go = canvas(bgc, (h, w))
        gi = canvas(bgc, (h*2, w*2))
        inds = totuple(asindices(go))
        locs = sample(inds, nc)
        objo = frozenset({(choice(remcols), ij) for ij in locs})
        f = lambda cij: (cij[0], double(cij[1]))
        obji = shift(apply(f, objo), (1, 1))
        gi = paint(gi, obji)
        go = paint(go, objo)
        go = upscale(go, 4)
        return {'input': gi, 'output': go}

    def generate_a79310a0(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        nc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        c = canvas(bgc, (h, w))
        bounds = asindices(c)
        ch = choice(totuple(bounds))
        shp = {ch}
        bounds = remove(ch, bounds)
        for j in range(nc - 1):
            shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))
        shp = normalize(shp)
        oh, ow = shape(shp)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        loc = (loci, locj)
        plcd = shift(shp, loc)
        gi = fill(c, fgc, plcd)
        go = fill(c, 2, shift(plcd, (1, 0)))
        return {'input': gi, 'output': go}

    def generate_dc1df850(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        c = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (0, (h * w) // 2 - 1))
        nreddev = unifint(diff_lb, diff_ub, (0, nc // 2))
        nred = choice((nreddev, nc - nreddev))
        nred = min(max(0, nred), nc)
        inds = totuple(asindices(c))
        occ = sample(inds, nc)
        reds = sample(occ, nred)
        others = difference(occ, reds)
        c = fill(c, 2, reds)
        obj = frozenset({(choice(remcols), ij) for ij in others})
        c = paint(c, obj)
        gi = tuple(r for r in c)
        go = underfill(c, 1, mapply(neighbors, frozenset(reds)))
        return {'input': gi, 'output': go}

    def generate_f76d97a5(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(0, remove(5, interval(0, 10, 1)))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        col = choice(cols)
        gi = canvas(5, (h, w))
        go = canvas(col, (h, w))
        numdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        num = choice((numdev, h * w - numdev))
        num = min(max(1, num), h * w)
        inds = totuple(asindices(gi))
        locs = sample(inds, num)
        gi = fill(gi, col, locs)
        go = fill(go, 0, locs)
        return {'input': gi, 'output': go}

    def generate_0d3d703e(diff_lb: float, diff_ub: float) -> dict:
        incols = (1, 2, 3, 4, 5, 6, 8, 9)
        outcols = (5, 6, 4, 3, 1, 2, 9, 8)
        k = len(incols)
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        gi = canvas(-1, (h, w))
        go = canvas(-1, (h, w))
        inds = asindices(gi)
        numc = unifint(diff_lb, diff_ub, (1, k))
        idxes = sample(interval(0, k, 1), numc)
        for ij in inds:
            idx = choice(idxes)
            gi = fill(gi, incols[idx], {ij})
            go = fill(go, outcols[idx], {ij})
        return {'input': gi, 'output': go}

    def generate_445eab21(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 9))
        indss = asindices(gi)
        maxtrials = 4 * num
        succ = 0
        tr = 0
        bigcol, area = 0, 0
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(3, 7)
            ow = randint(3, 7)
            if oh * ow == area:
                continue
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                remcols = remove(col, remcols)
                gi = fill(gi, col, box(bd))
                succ += 1
                indss = indss - bd
                if oh * ow > area:
                    bigcol, area = col, oh * ow
            tr += 1
        go = canvas(bigcol, (2, 2))
        return {'input': gi, 'output': go}

    def generate_b94a9452(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc, outer, inner = sample(cols, 3)
        c = canvas(bgc, (h, w))
        oh = unifint(diff_lb, diff_ub, (3, h - 1))
        ow = unifint(diff_lb, diff_ub, (3, w - 1))
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        oh2d = unifint(diff_lb, diff_ub, (0, oh // 2))
        ow2d = unifint(diff_lb, diff_ub, (0, ow // 2))
        oh2 = choice((oh2d, oh - oh2d))
        oh2 = min(max(1, oh2), oh - 2)
        ow2 = choice((ow2d, ow - ow2d))
        ow2 = min(max(1, ow2), ow - 2)
        loci2 = randint(loci+1, loci+oh-oh2-1)
        locj2 = randint(locj+1, locj+ow-ow2-1)
        obj1 = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
        obj2 = backdrop(frozenset({(loci2, locj2), (loci2 + oh2 - 1, locj2 + ow2 - 1)}))
        gi = fill(c, outer, obj1)
        gi = fill(gi, inner, obj2)
        go = compress(gi)
        go = switch(go, outer, inner)
        return {'input': gi, 'output': go}

    def generate_e9afcf9a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        numc = unifint(diff_lb, diff_ub, (1, min(10, h)))
        colss = sample(cols, numc)
        rr = tuple(choice(colss) for k in range(h))
        rr2 = rr[::-1]
        gi = []
        go = []
        for k in range(w):
            gi.append(rr)
            if k % 2 == 0:
                go.append(rr)
            else:
                go.append(rr2)
        gi = dmirror(tuple(gi))
        go = dmirror(tuple(go))
        return {'input': gi, 'output': go}

    def generate_e9614598(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))    
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        r = randint(0, h - 1)
        sizh = unifint(diff_lb, diff_ub, (2, w//2))
        siz = 2 * sizh + 1
        siz = min(max(5, siz), w)
        locj = randint(0, w - siz)
        bgc, dotc = sample(cols, 2)
        c = canvas(bgc, (h, w))
        A = (r, locj)
        B = (r, locj+siz-1)
        gi = fill(c, dotc, {A, B})
        locc = (r, locj + siz // 2)
        go = fill(gi, 3, {locc})
        go = fill(go, 3, dneighbors(locc))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_d23f8c26(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (2, 30))
        wh = unifint(diff_lb, diff_ub, (1, 14))
        w = 2 * wh + 1
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        numn = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))
        numcols = unifint(diff_lb, diff_ub, (1, 9))
        remcols = sample(remcols, numcols)
        inds = totuple(asindices(gi))
        locs = sample(inds, numn)
        for ij in locs:
            col = choice(remcols)
            gi = fill(gi, col, {ij})
            a, b = ij
            if b == w // 2:
                go = fill(go, col, {ij})
        return {'input': gi, 'output': go}

    def generate_ce9e57f2(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))    
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        nbars = unifint(diff_lb, diff_ub, (2, (w - 2) // 2))
        locopts = interval(1, w - 1, 1)
        barlocs = []
        for k in range(nbars):
            if len(locopts) == 0:
                break
            loc = choice(locopts)
            barlocs.append(loc)
            locopts = remove(loc, locopts)
            locopts = remove(loc + 1, locopts)
            locopts = remove(loc - 1, locopts)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, 8))
        colss = sample(remcols, numc)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        for j in barlocs:
            barloci = unifint(diff_lb, diff_ub, (1, h - 2))
            fullbar = connect((0, j), (barloci, j))
            halfbar = connect((0, j), (barloci // 2 if barloci % 2 == 1 else (barloci - 1) // 2, j))
            barcol = choice(colss)
            gi = fill(gi, barcol, fullbar)
            go = fill(go, barcol, fullbar)
            go = fill(go, 8, halfbar)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_b9b7f026(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 9))
        indss = asindices(gi)
        maxtrials = 4 * num
        succ = 0
        tr = 0
        outcol = None
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(3, 7)
            ow = randint(3, 7)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                remcols = remove(col, remcols)
                gi = fill(gi, col, bd)
                succ += 1
                indss = indss - bd
                if outcol is None:
                    outcol = col
                    cands = totuple(backdrop(inbox(bd)))
                    bd2 = backdrop(
                        frozenset(sample(cands, 2)) if len(cands) > 2 else frozenset(cands)
                    )
                    gi = fill(gi, bgc, bd2)
            tr += 1
        go = canvas(outcol, (1, 1))
        return {'input': gi, 'output': go}

    def generate_6d75e8bb(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        nc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        fgc = choice(remcols)
        c = canvas(bgc, (h, w))
        bounds = asindices(c)
        ch = choice(totuple(bounds))
        shp = {ch}
        bounds = remove(ch, bounds)
        for j in range(nc - 1):
            shp.add(choice(totuple((bounds - shp) & mapply(neighbors, shp))))
        shp = normalize(shp)
        oh, ow = shape(shp)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        loc = (loci, locj)
        plcd = shift(shp, loc)
        gi = fill(c, fgc, plcd)
        go = fill(c, 2, backdrop(plcd))
        go = fill(go, fgc, plcd)
        return {'input': gi, 'output': go}

    def generate_3f7978a0(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc, noisec, linec = sample(cols, 3)
        c = canvas(bgc, (h, w))
        oh = unifint(diff_lb, diff_ub, (4, max(4, int((2/3) * h))))
        oh = min(oh, h)
        ow = unifint(diff_lb, diff_ub, (4, max(4, int((2/3) * w))))
        ow = min(ow, w)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        nnoise = unifint(diff_lb, diff_ub, (0, (h * w) // 4))
        inds = totuple(asindices(c))
        noise = sample(inds, nnoise)
        gi = fill(c, noisec, noise)
        ulc = (loci, locj)
        lrc = (loci + oh - 1, locj + ow - 1)
        llc = (loci + oh - 1, locj)
        urc = (loci, locj + ow - 1)
        gi = fill(gi, linec, connect(ulc, llc))
        gi = fill(gi, linec, connect(urc, lrc))
        crns = {ulc, lrc, llc, urc}
        gi = fill(gi, noisec, crns)
        go = subgrid(crns, gi)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_e76a88a6(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        objh = unifint(diff_lb, diff_ub, (2, 5))
        objw = unifint(diff_lb, diff_ub, (2, 5))
        bounds = asindices(canvas(0, (objh, objw)))
        shp = {choice(totuple(bounds))}
        nc = unifint(diff_lb, diff_ub, (2, len(bounds) - 2))
        for j in range(nc):
            ij = choice(totuple((bounds - shp) & mapply(dneighbors, shp)))
            shp.add(ij)
        shp = normalize(shp)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        dmyc = choice(remcols)
        remcols = remove(dmyc, remcols)
        oh, ow = shape(shp)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        shpp = shift(shp, (loci, locj))
        numco = unifint(diff_lb, diff_ub, (2, 8))
        colll = sample(remcols, numco)
        shppc = frozenset({(choice(colll), ij) for ij in shpp})
        while numcolors(shppc) == 1:
            shppc = frozenset({(choice(colll), ij) for ij in shpp})
        shppcn = normalize(shppc)
        gi = canvas(bgc, (h, w))
        gi = paint(gi, shppc)
        go = tuple(e for e in gi)
        ub = ((h * w) / (oh * ow)) // 2
        ub = max(1, ub)
        numlocs = unifint(diff_lb, diff_ub, (1, ub))
        cnt = 0
        fails = 0
        maxfails = 5 * numlocs
        idns = (asindices(gi) - shpp) - mapply(dneighbors, shpp)
        idns = sfilter(idns, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
        while cnt < numlocs and fails < maxfails:
            if len(idns) == 0:
                break
            loc = choice(totuple(idns))
            plcd = shift(shppcn, loc)
            plcdi = toindices(plcd)
            if plcdi.issubset(idns):
                go = paint(go, plcd)
                gi = fill(gi, dmyc, plcdi)
                cnt += 1
                idns = (idns - plcdi) - mapply(dneighbors, plcdi)
            else:
                fails += 1
        return {'input': gi, 'output': go}

    def generate_a61f2674(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, remove(1, interval(0, 10, 1)))
        w = unifint(diff_lb, diff_ub, (5, 28))
        h = unifint(diff_lb, diff_ub, (w // 2 + 1, 30))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        nbars = unifint(diff_lb, diff_ub, (2, w // 2))
        barlocs = []
        options = interval(0, w, 1)
        while len(options) > 0 and len(barlocs) < nbars:
            loc = choice(options)
            barlocs.append(loc)
            options = remove(loc, options)
            options = remove(loc + 1, options)
            options = remove(loc - 1, options)
        barheights = sample(interval(0, h, 1), nbars)
        for j, bh in zip(barlocs, barheights):
            gi = fill(gi, fgc, connect((0, j), (bh, j)))
            if bh == max(barheights):
                go = fill(go, 1, connect((0, j), (bh, j)))
            if bh == min(barheights):
                go = fill(go, 2, connect((0, j), (bh, j)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_ce4f8723(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        barcol = choice(remcols)
        remcols = remove(barcol, remcols)
        cola = choice(remcols)
        colb = choice(remove(cola, remcols))
        canv = canvas(bgc, (h, w))
        inds = totuple(asindices(canv))
        gbar = canvas(barcol, (h, 1))
        mp = (h * w) // 2
        devrng = (0, mp)
        deva = unifint(diff_lb, diff_ub, devrng)
        devb = unifint(diff_lb, diff_ub, devrng)
        sgna = choice((+1, -1))
        sgnb = choice((+1, -1))
        deva = sgna * deva
        devb = sgnb * devb
        numa = mp + deva
        numb = mp + devb
        numa = max(min(h * w - 1, numa), 1)
        numb = max(min(h * w - 1, numb), 1)
        a = sample(inds, numa)
        b = sample(inds, numb)
        gia = fill(canv, cola, a)
        gib = fill(canv, colb, b)
        gi = hconcat(hconcat(gia, gbar), gib)
        go = fill(canv, 3, set(a) | set(b))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_caa06a1f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        vp = unifint(diff_lb, diff_ub, (2, h//2-1))
        hp = unifint(diff_lb, diff_ub, (2, w//2-1))
        bgc = choice(cols)
        numc = unifint(diff_lb, diff_ub, (2, min(8, max(2, hp * vp))))
        remcols = remove(bgc, cols)
        ccols = sample(remcols, numc)
        remcols = difference(remcols, ccols)
        tric = choice(remcols)
        obj = {(choice(ccols), ij) for ij in asindices(canvas(-1, (vp, hp)))}
        go = canvas(bgc, (h, w))
        gi = canvas(bgc, (h, w))
        for a in range(-vp, h+1, vp):
            for b in range(-hp, w+1, hp):
                go = paint(go, shift(obj, (a, b + 1)))
        for a in range(-vp, h+1, vp):
            for b in range(-hp, w+1, hp):
                gi = paint(gi, shift(obj, (a, b)))
        ioffs = unifint(diff_lb, diff_ub, (1, h - 2 * vp))
        joffs = unifint(diff_lb, diff_ub, (1, w - 2 * hp))
        for a in range(ioffs):
            gi = fill(gi, tric, connect((a, 0), (a, w - 1)))
        for b in range(joffs):
            gi = fill(gi, tric, connect((0, b), (h - 1, b)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_94f9d214(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 14))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        acol = choice(remcols)
        remcols = remove(acol, remcols)
        bcol = choice(remcols)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        numadev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numbdev = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numa = choice((numadev, h * w - numadev))
        numb = choice((numadev, h * w - numbdev))
        numa = min(max(1, numa), h * w - 1)
        numb = min(max(1, numb), h * w - 1)
        aset = sample(inds, numa)
        bset = sample(inds, numb)
        A = fill(c, acol, aset)
        B = fill(c, bcol, bset)
        gi = hconcat(A, B)
        res = (set(inds) - set(aset)) & (set(inds) - set(bset))
        go = fill(c, 2, res)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_feca6190(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        w = unifint(diff_lb, diff_ub, (2, 6))
        bgc = 0
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (1, min(w, 5)))
        ccols = sample(remcols, ncols)
        cands = interval(0, w, 1)
        locs = sample(cands, ncols)
        gi = canvas(bgc, (1, w))
        go = canvas(bgc, (w*ncols, w*ncols))
        for col, j in zip(ccols, locs):
            gi = fill(gi, col, {(0, j)})
            go = fill(go, col, shoot((w*ncols-1, j), UP_RIGHT))
        return {'input': gi, 'output': go}

    def generate_d5d6de2d(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 16))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(1, 7)
            ow = randint(1, 7)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                gi = fill(gi, col, box(bd))
                if oh > 2 and ow > 2:
                    go = fill(go, 3, backdrop(inbox(bd)))
                succ += 1
                indss = (indss - bd) - outbox(bd)
            tr += 1
        return {'input': gi, 'output': go}

    def generate_4612dd53(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        ih = unifint(diff_lb, diff_ub, (5, h-1))
        iw = unifint(diff_lb, diff_ub, (5, w-1))
        bgc, col = sample(cols, 2)
        loci = randint(0, h - ih)
        locj = randint(0, w - iw)
        bx = box(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))
        if choice((True, False)):
            locc = randint(loci + 2, loci + ih - 3)
            br = connect((locc, locj+1), (locc, locj + iw - 2))
        else:
            locc = randint(locj + 2, locj + iw - 3)
            br = connect((loci+1, locc), (loci + ih - 2, locc))
        c = canvas(bgc, (h, w))
        crns = sample(totuple(corners(bx)), 3)
        onbx = totuple(crns)
        rembx = difference(bx, crns)
        onbr = sample(totuple(br), 2)
        rembr = difference(br, onbr)
        noccbx = unifint(diff_lb, diff_ub, (0, len(rembx)))
        noccbr = unifint(diff_lb, diff_ub, (0, len(rembr)))
        occbx = sample(totuple(rembx), noccbx)
        occbr = sample(totuple(rembr), noccbr)
        c = fill(c, col, bx)
        c = fill(c, col, br)
        gi = fill(c, bgc, occbx)
        gi = fill(gi, bgc, occbr)
        go = fill(c, 2, occbx)
        go = fill(go, 2, occbr)
        if choice((True, False)):
            gi = fill(gi, bgc, br)
            go = fill(go, bgc, br)
        return {'input': gi, 'output': go}

    def generate_1f642eb9(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        ih = unifint(diff_lb, diff_ub, (2, min(h - 4, 2 * (h // 3))))
        iw = unifint(diff_lb, diff_ub, (2, min(w - 4, 2 * (w // 3))))
        loci = randint(2, h - ih - 2)
        locj = randint(2, w - iw - 2)
        bgc, sqc = sample(cols, 2)
        remcols = difference(cols, (bgc, sqc))
        numcells = unifint(diff_lb, diff_ub, (1, 2 * ih + 2 * iw - 4))
        outs = []
        ins = []
        c1 = choice((True, False))
        c2 = choice((True, False))
        c3 = choice((True, False))
        c4 = choice((True, False))
        for a in range(loci + (not c1), loci + ih - (not c2)):
            outs.append((a, 0))
            ins.append((a, locj))
        for a in range(loci + (not c3), loci + ih - (not c4)):
            outs.append((a, w - 1))
            ins.append((a, locj + iw - 1))
        for b in range(locj + c1, locj + iw - (c3)):
            outs.append((0, b))
            ins.append((loci, b))
        for b in range(locj + (c2), locj + iw - (c4)):
            outs.append((h - 1, b))
            ins.append((loci + ih - 1, b))
        inds = interval(0, 2 * ih + 2 * iw - 4, 1)
        locs = sample(inds, numcells)
        numc = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numc)
        outs = [e for j, e in enumerate(outs) if j in locs]
        ins = [e for j, e in enumerate(ins) if j in locs]
        c = canvas(bgc, (h, w))
        bd = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))
        gi = fill(c, sqc, bd)
        seq = [choice(ccols) for k in range(numcells)]
        for c, loc in zip(seq, outs):
            gi = fill(gi, c, {loc})
        go = tuple(e for e in gi)
        for c, loc in zip(seq, ins):
            go = fill(go, c, {loc})
        return {'input': gi, 'output': go}

    def generate_681b3aeb(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        fullsuc = False
        while not fullsuc:
            hi = unifint(diff_lb, diff_ub, (2, 8))
            wi = unifint(diff_lb, diff_ub, (2, 8))
            h = unifint(diff_lb, diff_ub, ((3*hi, 30)))
            w = unifint(diff_lb, diff_ub, ((3*wi, 30)))
            c = canvas(-1, (hi, hi))
            bgc, ca, cb = sample(cols, 3)
            gi = canvas(bgc, (h, w))
            conda, condb = True, True
            while conda and condb:
                inds = totuple(asindices(c))
                pa = choice(inds)
                reminds = remove(pa, inds)
                pb = choice(reminds)
                reminds = remove(pb, reminds)
                A = {pa}
                B = {pb}
                for k in range(len(reminds)):
                    acands = set(reminds) & mapply(dneighbors, A)
                    bcands = set(reminds) & mapply(dneighbors, B)
                    opts = []
                    if len(acands) > 0:
                        opts.append(0)
                    if len(bcands) > 0:
                        opts.append(1)
                    idx = choice(opts)
                    if idx == 0:
                        loc = choice(totuple(acands))
                        A.add(loc)
                    else:
                        loc = choice(totuple(bcands))
                        B.add(loc)
                    reminds = remove(loc, reminds)
                conda = len(A) == height(A) * width(A)
                condb = len(B) == height(B) * width(B)
            go = fill(c, ca, A)
            go = fill(go, cb, B)
            fullocs = totuple(asindices(gi))
            A = normalize(A)
            B = normalize(B)
            ha, wa = shape(A)
            hb, wb = shape(B)
            minisuc = False
            if not (ha > h or wa > w):
                for kkk in range(10):
                    locai = randint(0, h - ha)
                    locaj = randint(0, w - wa)
                    plcda = shift(A, (locaj, locaj))
                    remlocs = difference(fullocs, plcda)
                    remlocs2 = sfilter(remlocs, lambda ij: ij[0] <= h - hb and ij[1] <= w - wb)
                    if len(remlocs2) == 0:
                        continue
                    ch = choice(remlocs2)
                    plcdb = shift(B, (ch))
                    if set(plcdb).issubset(set(remlocs2)):
                        minisuc = True
                        break
            if minisuc:
                fullsuc = True
        gi = fill(gi, ca, plcda)
        gi = fill(gi, cb, plcdb)
        return {'input': gi, 'output': go}

    def generate_d364b489(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 6, 7, 8))    
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        inds = totuple(asindices(gi))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 5))
        res = set()
        for j in range(num):
            if len(inds) == 0:
                break
            r = choice(inds)
            inds = remove(r, inds)
            inds = difference(inds, neighbors(r))
            inds = difference(inds, totuple(shift(apply(rbind(multiply, TWO), dneighbors(ORIGIN)), r)))
            res.add(r)
        gi = fill(gi, fgc, res)
        go = fill(gi, 7, shift(res, LEFT))
        go = fill(go, 6, shift(res, RIGHT))
        go = fill(go, 8, shift(res, DOWN))
        go = fill(go, 2, shift(res, UP))
        return {'input': gi, 'output': go}

    def generate_25d8a9c8(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        gi = []
        go = []
        ncols = unifint(diff_lb, diff_ub, (2, 10))
        ccols = sample(cols, ncols)
        for k in range(h):
            singlecol = choice((True, False))
            col = choice(ccols)
            row = repeat(col, w)
            if singlecol:
                gi.append(row)
                go.append(repeat(5, w))
            else:
                remcols = remove(col, ccols)
                nothercinv = unifint(diff_lb, diff_ub, (1, w - 1))
                notherc = w - 1 - nothercinv
                notherc = min(max(1, notherc), w - 1)
                row = list(row)
                indss = interval(0, w, 1)
                for j in sample(indss, notherc):
                    row[j] = choice(remcols)
                gi.append(tuple(row))
                go.append(repeat(0, w))
        gi = tuple(gi)
        go = tuple(go)
        return {'input': gi, 'output': go}

    def generate_bda2d7a6(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 14))
        w = unifint(diff_lb, diff_ub, (2, 14))
        ncols = unifint(diff_lb, diff_ub, (2, 10))
        cols = sample(colopts, ncols)
        colord = [choice(cols) for j in range(min(h, w))]
        shp = (h*2, w*2)
        gi = canvas(0, shp)
        for idx, (ci, co) in enumerate(zip(colord, colord[-1:] + colord[:-1])):
            ulc = (idx, idx)
            lrc = (h*2 - 1 - idx, w*2 - 1 - idx)
            bx = box(frozenset({ulc, lrc}))
            gi = fill(gi, ci, bx)
        I = gi
        objso = order(objects(I, T, F, F), compose(maximum, shape))
        if color(objso[0]) == color(objso[-1]):
            objso = (combine(objso[0], objso[-1]),) + objso[1:-1]
        res = mpapply(recolor, apply(color, objso), (objso[-1],) + objso[:-1])
        go = paint(gi, res)
        return {'input': gi, 'output': go}

    def generate_a5f85a15(diff_lb: float, diff_ub: float) -> dict:
        colopts = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        startlocs = apply(toivec, interval(h - 1, 0, -1)) + apply(tojvec, interval(0, w, 1))
        cands = interval(0, h + w - 1, 1)
        num = unifint(diff_lb, diff_ub, (1, (h + w - 1) // 3))
        locs = []
        for k in range(num):
            if len(cands) == 0:
                break
            loc = choice(cands)
            locs.append(loc)
            cands = remove(loc, cands)
            cands = remove(loc - 1, cands)
            cands = remove(loc + 1, cands)
        locs = set([startlocs[loc] for loc in locs])
        bgc, fgc = sample(colopts, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        for loc in locs:
            ln = order(shoot(loc, (1, 1)), first)
            gi = fill(gi, fgc, ln)
            go = fill(go, fgc, ln)
            go = fill(go, 4, ln[1::2])
        return {'input': gi, 'output': go}

    def generate_32597951(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        ih = unifint(diff_lb, diff_ub, (2, h // 2))
        iw = unifint(diff_lb, diff_ub, (2, w // 2))
        bgc, noisec, fgc = sample(cols, 3)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        ndev = unifint(diff_lb, diff_ub, (1, (h * w) // 2))
        num = choice((ndev, h * w - ndev))
        num = min(max(num, 0), h * w)
        ofc = sample(inds, num)
        c = fill(c, noisec, ofc)
        loci = randint(0, h - ih)
        locj = randint(0, w - iw)
        bd = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))
        tofillfc = bd & ofcolor(c, bgc)
        gi = fill(c, fgc, tofillfc)
        if len(tofillfc) > 0:
            go = fill(gi, 3, backdrop(tofillfc) & ofcolor(gi, noisec))
        else:
            go = gi
        return {'input': gi, 'output': go}

    def generate_cf98881b(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 9))
        bgc, barcol, cola, colb, colc = sample(cols, 5)
        canv = canvas(bgc, (h, w))
        inds = totuple(asindices(canv))
        gbar = canvas(barcol, (h, 1))
        mp = (h * w) // 2
        devrng = (0, mp)
        deva = unifint(diff_lb, diff_ub, devrng)
        devb = unifint(diff_lb, diff_ub, devrng)
        devc = unifint(diff_lb, diff_ub, devrng)
        sgna = choice((+1, -1))
        sgnb = choice((+1, -1))
        sgnc = choice((+1, -1))
        deva = sgna * deva
        devb = sgnb * devb
        devc = sgnc * devc
        numa = mp + deva
        numb = mp + devb
        numc = mp + devc
        numa = max(min(h * w - 1, numa), 1)
        numb = max(min(h * w - 1, numb), 1)
        numc = max(min(h * w - 1, numc), 1)
        a = sample(inds, numa)
        b = sample(inds, numb)
        c = sample(inds, numc)
        gia = fill(canv, cola, a)
        gib = fill(canv, colb, b)
        gic = fill(canv, colc, c)
        gi = hconcat(hconcat(hconcat(gia, gbar), hconcat(gib, gbar)), gic)
        go = fill(gic, colb, b)
        go = fill(go, cola, a)
        return {'input': gi, 'output': go}

    def generate_41e4d17e(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(6, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 16))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        bx = box(frozenset({(0, 0), (4, 4)}))
        bd = backdrop(bx)
        maxtrials = 4 * num
        succ = 0
        tr = 0
        while succ < num and tr < maxtrials:
            loc = choice(totuple(inds))
            bxs = shift(bx, loc)
            if bxs.issubset(set(inds)):
                gi = fill(gi, fgc, bxs)
                go = fill(go, fgc, bxs)
                cen = center(bxs)
                frns = hfrontier(cen) | vfrontier(cen)
                kep = frns & ofcolor(go, bgc)
                go = fill(go, 6, kep)
                inds = difference(inds, shift(bd, loc))
                succ += 1
            tr += 1
        return {'input': gi, 'output': go}

    def generate_91714a58(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        bgc, targc = sample(cols, 2)
        remcols = remove(bgc, cols)
        nnoise = unifint(diff_lb, diff_ub, (1, (h * w) // 2))
        gi = canvas(bgc, (h, w))
        inds = totuple(asindices(gi))
        noise = sample(inds, nnoise)
        ih = randint(2, h // 2)
        iw = randint(2, w // 2)
        loci = randint(0, h - ih)
        locj = randint(0, w - iw)
        loc = (loci, locj)
        bd = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))
        go = fill(gi, targc, bd)
        for ij in noise:
            col = choice(remcols)
            gi = fill(gi, col, {ij})
        gi = fill(gi, targc, bd)
        return {'input': gi, 'output': go}

    def generate_b60334d2(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(1, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 9))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        bx = box(frozenset({(0, 0), (2, 2)}))
        bd = backdrop(bx)
        maxtrials = 4 * num
        succ = 0
        tr = 0
        while succ < num and tr < maxtrials:
            loc = choice(totuple(inds))
            bxs = shift(bx, loc)
            if bxs.issubset(set(inds)):
                cen = center(bxs)
                gi = fill(gi, fgc, {cen})
                go = fill(go, fgc, ineighbors(cen))
                go = fill(go, 1, dneighbors(cen))
                inds = difference(inds, shift(bd, loc))
                succ += 1
            tr += 1
        return {'input': gi, 'output': go}

    def generate_952a094c(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        ih = unifint(diff_lb, diff_ub, (4, h - 2))
        iw = unifint(diff_lb, diff_ub, (4, w - 2))
        loci = randint(1, h - ih - 1)
        locj = randint(1, w - iw - 1)
        sp = (loci, locj)
        ep = (loci + ih - 1, locj + iw - 1)
        bx = box(frozenset({sp, ep}))
        bgc, fgc, a, b, c, d = sample(cols, 6)
        canv = canvas(bgc, (h, w))
        canvv = fill(canv, fgc, bx)
        gi = tuple(e for e in canvv)
        go = tuple(e for e in canvv)
        gi = fill(gi, a, {(loci + 1, locj + 1)})
        go = fill(go, a, {(loci + ih, locj + iw)})
        gi = fill(gi, b, {(loci + 1, locj + iw - 2)})
        go = fill(go, b, {(loci + ih, locj - 1)})
        gi = fill(gi, c, {(loci + ih - 2, locj + 1)})
        go = fill(go, c, {(loci - 1, locj + iw)})
        gi = fill(gi, d, {(loci + ih - 2, locj + iw - 2)})
        go = fill(go, d, {(loci - 1, locj - 1)})
        return {'input': gi, 'output': go}

    def generate_b8cdaf2b(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc, linc, dotc = sample(cols, 3)
        lin = connect((0, 0), (0, w - 1))
        winv = unifint(diff_lb, diff_ub, (2, w - 1))
        w2 = w - winv
        w2 = min(max(w2, 1), w - 2)
        locj = randint(1, w - w2 - 1)
        bar2 = connect((0, locj), (0, locj + w2 - 1))
        c = canvas(bgc, (h, w))
        gi = fill(c, linc, lin)
        gi = fill(gi, dotc, bar2)
        gi = fill(gi, linc, shift(bar2, (1, 0)))
        go = fill(gi, dotc, shoot((2, locj - 1), (1, -1)))
        go = fill(go, dotc, shoot((2, locj + w2), (1, 1)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_b548a754(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        hi = unifint(diff_lb, diff_ub, (4, h - 1))
        wi = unifint(diff_lb, diff_ub, (3, w - 1))
        loci = randint(0, h - hi)
        locj = randint(0, w - wi)
        bx = box(frozenset({(loci, locj), (loci + hi - 1, locj + wi - 1)}))
        ins = backdrop(inbox(bx))
        bgc, boxc, inc, dotc = sample(cols, 4)
        c = canvas(bgc, (h, w))
        go = fill(c, boxc, bx)
        go = fill(go, inc, ins)
        cutoff = randint(loci + 2, loci + hi - 2)
        bx2 = box(frozenset({(loci, locj), (cutoff, locj + wi - 1)}))
        ins2 = backdrop(inbox(bx2))
        gi = fill(c, boxc, bx2)
        gi = fill(gi, inc, ins2)
        locc = choice(totuple(connect((loci+hi-1, locj), (loci+hi-1, locj+wi-1))))
        gi = fill(gi, dotc, {locc})
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_95990924(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 3, 4))
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 16))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        bx = box(frozenset({(0, 0), (3, 3)}))
        bd = backdrop(bx)
        maxtrials = 4 * num
        succ = 0
        tr = 0
        while succ < num and tr < maxtrials:
            loc = choice(totuple(inds))
            bxs = shift(bx, loc)
            if bxs.issubset(set(inds)):
                gi = fill(gi, fgc, inbox(bxs))
                go = fill(go, fgc, inbox(bxs))
                go = fill(go, 1, {loc})
                go = fill(go, 2, {add(loc, (0, 3))})
                go = fill(go, 3, {add(loc, (3, 0))})
                go = fill(go, 4, {add(loc, (3, 3))})
                inds = difference(inds, shift(bd, loc))
                succ += 1
            tr += 1
        return {'input': gi, 'output': go}

    def generate_f1cefba8(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (7, 30))
        ih = unifint(diff_lb, diff_ub, (6, h - 1))
        iw = unifint(diff_lb, diff_ub, (6, w - 1))
        loci = randint(0, h - ih)
        locj = randint(0, w - iw)
        bgc, ringc, inc = sample(cols, 3)
        obj = frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)})
        ring1 = box(obj)
        ring2 = inbox(obj)
        bd = backdrop(obj)
        c = canvas(bgc, (h, w))
        c = fill(c, inc, bd)
        c = fill(c, ringc, ring1 | ring2)
        cands = totuple(ring2 - corners(ring2))
        numc = unifint(diff_lb, diff_ub, (1, len(cands) // 2))
        locs = sample(cands, numc)
        gi = fill(c, inc, locs)
        lm = lowermost(ring2)
        hori = sfilter(locs, lambda ij: ij[0] > loci + 1 and ij[0] < lm)
        verti = difference(locs, hori)
        hlines = mapply(hfrontier, hori)
        vlines = mapply(vfrontier, verti)
        fulllocs = set(hlines) | set(vlines)
        topaintinc = fulllocs & ofcolor(c, bgc)
        topaintringc = fulllocs & ofcolor(c, inc)
        go = fill(c, inc, topaintinc)
        go = fill(go, ringc, topaintringc)
        return {'input': gi, 'output': go}

    def generate_c444b776(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 9))
        w = unifint(diff_lb, diff_ub, (2, 9))
        nh = unifint(diff_lb, diff_ub, (1, 3))
        nw = unifint(diff_lb, diff_ub, (1 if nh > 1 else 2, 3))
        bgclinc = sample(cols, 2)
        bgc, linc = bgclinc
        remcols = difference(cols, bgclinc)
        fullh = h * nh + (nh - 1)
        fullw = w * nw + (nw - 1)
        c = canvas(linc, (fullh, fullw))
        smallc = canvas(bgc, (h, w))
        inds = totuple(asindices(smallc))
        numcol = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numcol)
        numcels = unifint(diff_lb, diff_ub, (1, (h * w) // 2))
        cels = sample(inds, numcels)
        obj = {(choice(ccols), ij) for ij in cels}
        smallcpainted = paint(smallc, obj)
        llocs = set()
        for a in range(0, fullh, h+1):
            for b in range(0, fullw, w + 1):
                llocs.add((a, b))
        llocs = tuple(llocs)
        srcloc = choice(llocs)
        obj = asobject(smallcpainted)
        gi = paint(c, shift(obj, srcloc))
        remlocs = remove(srcloc, llocs)
        bobj = asobject(smallc)
        for rl in remlocs:
            gi = paint(gi, shift(bobj, rl))
        go = tuple(e for e in gi)
        for rl in remlocs:
            go = paint(go, shift(obj, rl))
        return {'input': gi, 'output': go}

    def generate_97999447(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(5, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        opts = interval(0, h, 1)
        num = unifint(diff_lb, diff_ub, (1, h))
        locs = sample(opts, num)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numc)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        for idx in locs:
            col = choice(ccols)
            j = randint(0, w - 1)
            dot = (idx, j)
            gi = fill(gi, col, {dot})
            go = fill(go, col, {(idx, x) for x in range(j, w, 2)})
            go = fill(go, 5, {(idx, x) for x in range(j+1, w, 2)})
        return {'input': gi, 'output': go}

    def generate_d89b689b(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(5, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc, sqc, a, b, c, d = sample(cols, 6)
        loci = randint(1, h - 3)
        locj = randint(1, w - 3)
        canv = canvas(bgc, (h, w))
        go = fill(canv, a, {(loci, locj)})
        go = fill(go, b, {(loci, locj+1)})
        go = fill(go, c, {(loci+1, locj)})
        go = fill(go, d, {(loci+1, locj+1)})
        inds = totuple(asindices(canv))
        aopts = sfilter(inds, lambda ij: ij[0] < loci and ij[1] < locj)
        bopts = sfilter(inds, lambda ij: ij[0] < loci and ij[1] > locj + 1)
        copts = sfilter(inds, lambda ij: ij[0] > loci + 1 and ij[1] < locj)
        dopts = sfilter(inds, lambda ij: ij[0] > loci + 1 and ij[1] > locj + 1)
        aopts = order(aopts, lambda ij: manhattan({ij}, {(loci, locj)}))
        bopts = order(bopts, lambda ij: manhattan({ij}, {(loci, locj + 1)}))
        copts = order(copts, lambda ij: manhattan({ij}, {(loci + 1, locj)}))
        dopts = order(dopts, lambda ij: manhattan({ij}, {(loci + 1, locj + 1)}))
        aidx = unifint(diff_lb, diff_ub, (0, len(aopts) - 1))
        bidx = unifint(diff_lb, diff_ub, (0, len(bopts) - 1))
        cidx = unifint(diff_lb, diff_ub, (0, len(copts) - 1))
        didx = unifint(diff_lb, diff_ub, (0, len(dopts) - 1))
        loca = aopts[aidx]
        locb = bopts[bidx]
        locc = copts[cidx]
        locd = dopts[didx]
        gi = fill(canv, sqc, backdrop({(loci, locj), (loci + 1, locj + 1)}))
        gi = fill(gi, a, {loca})
        gi = fill(gi, b, {locb})
        gi = fill(gi, c, {locc})
        gi = fill(gi, d, {locd})
        return {'input': gi, 'output': go}

    def generate_543a7ed5(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (3, 4))    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, 7))
        ccols = sample(remcols, numc)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(indss) == 0:
                break
            oh = randint(4, 8)
            ow = randint(4, 8)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(ccols)
            if bd.issubset(indss):
                bdibd = backdrop(frozenset({(loci+1, locj+1), (loci + oh - 2, locj + ow - 2)}))
                go = fill(go, col, bdibd)
                go = fill(go, 3, box(bd))
                gi = fill(gi, col, bdibd)
                if oh > 5 and ow > 5 and randint(1, 10) != 1:
                    ulci, ulcj = ulcorner(bdibd)
                    lrci, lrcj = lrcorner(bdibd)
                    aa = randint(ulci + 1, lrci - 1)
                    aa = randint(ulci + 1, aa)
                    bb = randint(ulcj + 1, lrcj - 1)
                    bb = randint(ulcj + 1, bb)
                    cc = randint(aa, lrci - 1)
                    dd = randint(bb, lrcj - 1)
                    cc = randint(cc, lrci - 1)
                    dd = randint(dd, lrcj - 1)
                    ins = backdrop({(aa, bb), (cc, dd)})
                    go = fill(go, 4, ins)
                    gi = fill(gi, bgc, ins)
                succ += 1
                indss = indss - bd
            tr += 1
        return {'input': gi, 'output': go}

    def generate_a2fd1cf0(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 3, 8))    
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        gloci = unifint(diff_lb, diff_ub, (1, h - 1))
        glocj = unifint(diff_lb, diff_ub, (1, w - 1))
        gloc = (gloci, glocj)
        bgc = choice(cols)
        g = canvas(bgc, (h, w))
        g = fill(g, 3, {gloc})
        g = rot180(g)
        glocinv = center(ofcolor(g, 3))
        glocinvi, glocinvj = glocinv
        rloci = unifint(diff_lb, diff_ub, (glocinvi+1, h - 1))
        rlocj = unifint(diff_lb, diff_ub, (glocinvj+1, w - 1))
        rlocinv = (rloci, rlocj)
        g = fill(g, 2, {rlocinv})
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(g)
        a, b = center(ofcolor(gi, 2))
        c, d = center(ofcolor(gi, 3))
        go = fill(gi, 8, connect((a, b), (a, d)))
        go = fill(go, 8, connect((a, d), (c, d)))
        go = fill(go, 2, {(a, b)})
        go = fill(go, 3, {(c, d)})
        return {'input': gi, 'output': go}

    def generate_cdecee7f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        numc = unifint(diff_lb, diff_ub, (1, min(9, w)))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, numcols)
        inds = interval(0, w, 1)
        locs = sample(inds, numc)
        locs = order(locs, identity)
        gi = canvas(bgc, (h, w))
        go = []
        for j in locs:
            iloc = randint(0, h - 1)
            col = choice(ccols)
            gi = fill(gi, col, {(iloc, j)})
            go.append(col)
        go = go + [bgc] * (9 - len(go))
        go = tuple(go)
        go = tuple([go[:3], go[3:6][::-1], go[6:]])
        return {'input': gi, 'output': go}

    def generate_0962bcdd(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (3, 4))    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (2, 7))
        ccols = sample(remcols, numc)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        oh, ow = 5, 5
        subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
        while succ < num and tr <= maxtrials:
            if len(indss) == 0:
                break
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + 4, locj + 4)})
            bd = backdrop(obj)
            col = choice(ccols)
            if bd.issubset(indss):
                ca, cb = sample(ccols, 2)
                cp = (loci + 2, locj + 2)
                lins1 = connect((loci, locj), (loci + 4, locj + 4))
                lins2 = connect((loci + 4, locj), (loci, locj + 4))
                lins12 = lins1 | lins2
                lins3 = connect((loci + 2, locj), (loci + 2, locj + 4))
                lins4 = connect((loci, locj + 2), (loci + 4, locj + 2))
                lins34 = lins3 | lins4
                go = fill(go, cb, lins34)
                go = fill(go, ca, lins12)
                gi = fill(gi, ca, {cp})
                gi = fill(gi, cb, dneighbors(cp))
                succ += 1
                indss = indss - bd
            tr += 1
        return {'input': gi, 'output': go}

    def generate_dc0a314f(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 15))
        w = h
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        remcols = sample(remcols, numcols)
        canv = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (1, h * w))
        bx = asindices(canv)
        obj = {(choice(remcols), choice(totuple(bx)))}
        for kk in range(nc - 1):
            dns = mapply(neighbors, toindices(obj))
            ch = choice(totuple(bx & dns))
            obj.add((choice(remcols), ch))
            bx = bx - {ch}
        gi = paint(canv, obj)
        tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])
        gi = paint(gi, tr)
        gi = hconcat(gi, vmirror(gi))
        gi = vconcat(gi, hmirror(gi))
        locidev = unifint(diff_lb, diff_ub, (1, 2*h))
        locjdev = unifint(diff_lb, diff_ub, (1, w))
        loci = 2*h - locidev
        locj = w - locjdev
        loci2 = unifint(diff_lb, diff_ub, (loci, 2*h - 1))
        locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))
        bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))
        go = subgrid(bd, gi)
        gi = fill(gi, 3, bd)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_29623171(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 6))
        w = unifint(diff_lb, diff_ub, (2, 6))
        nh = unifint(diff_lb, diff_ub, (2, 4))
        nw = unifint(diff_lb, diff_ub, (2, 4))
        bgc, linc, fgc = sample(cols, 3)
        fullh = h * nh + (nh - 1)
        fullw = w * nw + (nw - 1)
        c = canvas(linc, (fullh, fullw))
        smallc = canvas(bgc, (h, w))
        inds = totuple(asindices(smallc))
        llocs = set()
        for a in range(0, fullh, h+1):
            for b in range(0, fullw, w + 1):
                llocs.add((a, b))
        llocs = tuple(llocs)
        srcloc = choice(llocs)
        nmostc = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))
        mostc = sample(inds, nmostc)
        srcg = fill(smallc, fgc, mostc)
        obj = asobject(srcg)
        shftd = shift(obj, srcloc)
        gi = paint(c, shftd)
        go = fill(c, fgc, shftd)
        remlocs = remove(srcloc, llocs)
        gg = asobject(fill(smallc, bgc, inds))
        for rl in remlocs:
            noth = unifint(diff_lb, diff_ub, (0, nmostc))
            otherg = fill(smallc, fgc, sample(inds, noth))
            gi = paint(gi, shift(asobject(otherg), rl))
            if noth == nmostc:
                go = fill(go, fgc, shift(obj, rl))
            else:
                go = paint(go, shift(gg, rl))
        return {'input': gi, 'output': go}

    def generate_d4a91cb9(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 4, 8))    
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        gloci = unifint(diff_lb, diff_ub, (1, h - 1))
        glocj = unifint(diff_lb, diff_ub, (1, w - 1))
        gloc = (gloci, glocj)
        bgc = choice(cols)
        g = canvas(bgc, (h, w))
        g = fill(g, 8, {gloc})
        g = rot180(g)
        glocinv = center(ofcolor(g, 8))
        glocinvi, glocinvj = glocinv
        rloci = unifint(diff_lb, diff_ub, (glocinvi+1, h - 1))
        rlocj = unifint(diff_lb, diff_ub, (glocinvj+1, w - 1))
        rlocinv = (rloci, rlocj)
        g = fill(g, 2, {rlocinv})
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(g)
        a, b = center(ofcolor(gi, 2))
        c, d = center(ofcolor(gi, 8))
        go = fill(gi, 4, connect((a, b), (a, d)))
        go = fill(go, 4, connect((a, d), (c, d)))
        go = fill(go, 2, {(a, b)})
        go = fill(go, 8, {(c, d)})
        return {'input': gi, 'output': go}

    def generate_60b61512(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(7, interval(0, 10, 1))    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numcols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 20))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(indss) == 0:
                break
            oh = randint(2, 7)
            ow = randint(2, 7)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            indsss = asindices(canvas(-1, (oh, ow)))
            chch = choice(totuple(indsss))
            obj = {chch}
            indsss = remove(chch, indsss)
            numcd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))
            numc = choice((numcd, oh * ow - numcd))
            numc = min(max(2, numc), oh * ow - 1)
            for k in range(numc):
                obj.add(choice(totuple(indsss & mapply(neighbors, obj))))
                indsss = indsss - obj
            oh, ow = shape(obj)
            obj = shift(obj, (loci, locj))
            bd = backdrop(obj)
            col = choice(ccols)
            if bd.issubset(indss):
                gi = fill(gi, col, obj)
                go = fill(go, 7, bd)
                go = fill(go, col, obj)
                succ += 1
                indss = (indss - bd) - outbox(bd)
            tr += 1
        return {'input': gi, 'output': go}

    def generate_4938f0c2(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 31))
        w = unifint(diff_lb, diff_ub, (10, 31))
        oh = unifint(diff_lb, diff_ub, (2, (h - 3) // 2))
        ow = unifint(diff_lb, diff_ub, (2, (w - 3) // 2))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        cc = choice(remcols)
        remcols = remove(cc, remcols)
        objc = choice(remcols)
        sg = canvas(bgc, (oh, ow))
        locc = (oh - 1, ow - 1)
        sg = fill(sg, cc, {locc})
        reminds = totuple(remove(locc, asindices(sg)))
        ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))
        cells = sample(reminds, ncells)
        while ncells == 4 and shape(cells) == (2, 2):
            ncells = unifint(diff_lb, diff_ub, (1, max(1, int((2/3) * oh * ow))))
            cells = sample(reminds, ncells)
        sg = fill(sg, objc, cells)
        G1 = sg
        G2 = vmirror(sg)
        G3 = hmirror(sg)
        G4 = vmirror(hmirror(sg))
        vbar = canvas(bgc, (oh, 1))
        hbar = canvas(bgc, (1, ow))
        cp = canvas(cc, (1, 1))
        topg = hconcat(hconcat(G1, vbar), G2)
        botg = hconcat(hconcat(G3, vbar), G4)
        ggm = hconcat(hconcat(hbar, cp), hbar)
        GG = vconcat(vconcat(topg, ggm), botg)
        gg = asobject(GG)
        canv = canvas(bgc, (h, w))
        loci = randint(0, h - 2 * oh - 1)
        locj = randint(0, w - 2 * ow - 1)
        loc = (loci, locj)
        go = paint(canv, shift(gg, loc))
        gi = paint(canv, shift(asobject(sg), loc))
        gi = fill(gi, cc, ofcolor(go, cc))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        ccpi, ccpj = center(ofcolor(gi, cc))
        gi = gi[:ccpi] + gi[ccpi+1:]
        gi = tuple(r[:ccpj] + r[ccpj + 1:] for r in gi)
        go = go[:ccpi] + go[ccpi+1:]
        go = tuple(r[:ccpj] + r[ccpj + 1:] for r in go)
        return {'input': gi, 'output': go}

    def generate_a8d7556c(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (0, 2))
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        fgc = choice(cols)
        c = canvas(fgc, (h, w))
        numblacks = unifint(diff_lb, diff_ub, (1, (h * w) // 3 * 2))
        inds = totuple(asindices(c))
        blacks = sample(inds, numblacks)
        gi = fill(c, 0, blacks)
        numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 10))
        sqlocs = sample(inds, numsq)
        gi = fill(gi, 0, shift(sqlocs, (0, 0)))
        gi = fill(gi, 0, shift(sqlocs, (0, 1)))
        gi = fill(gi, 0, shift(sqlocs, (1, 0)))
        gi = fill(gi, 0, shift(sqlocs, (1, 1)))
        go = tuple(e for e in gi)
        for a in range(h - 1):
            for b in range(w - 1):
                if gi[a][b] == 0 and gi[a+1][b] == 0 and gi[a][b+1] == 0 and gi[a+1][b+1] == 0:
                    go = fill(go, 2, {(a, b), (a+1, b), (a, b+1), (a+1, b+1)})
        return {'input': gi, 'output': go}

    def generate_007bbfb7(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        c = canvas(0, (h, w))
        numcd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numc = choice((numcd, h * w - numcd))
        numc = min(max(1, numc), h * w - 1)
        inds = totuple(asindices(c))
        locs = sample(inds, numc)
        fgc = choice(cols)
        gi = fill(c, fgc, locs)
        go = canvas(0, (h**2, w**2))
        for loc in locs:
            go = fill(go, fgc, shift(locs, multiply(loc, (h, w))))
        return {'input': gi, 'output': go}

    def generate_b190f7f5(diff_lb: float, diff_ub: float) -> dict:
        fullcols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        bgc = choice(fullcols)
        cols = remove(bgc, fullcols)
        c = canvas(bgc, (h, w))
        numcd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numc = choice((numcd, h * w - numcd))
        numc = min(max(1, numc), h * w - 1)
        numcd2 = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numc2 = choice((numcd2, h * w - numcd2))
        numc2 = min(max(2, numc2), h * w - 1)
        inds = totuple(asindices(c))
        srclocs = sample(inds, numc)
        srccol = choice(cols)
        remcols = remove(srccol, cols)
        numcols = unifint(diff_lb, diff_ub, (2, 8))
        trglocs = sample(inds, numc2)
        ccols = sample(remcols, numcols)
        fixc1 = choice(ccols)
        trgobj = [(fixc1, trglocs[0]), (choice(remove(fixc1, ccols)), trglocs[1])] + [(choice(ccols), ij) for ij in trglocs[2:]]
        trgobj = frozenset(trgobj)
        gisrc = fill(c, srccol, srclocs)
        gitrg = paint(c, trgobj)
        catf = choice((hconcat, vconcat))
        ordd = choice(([gisrc, gitrg], [gitrg, gisrc]))
        gi = catf(*ordd)
        go = canvas(bgc, (h**2, w**2))
        for loc in trglocs:
            a, b = loc
            go = fill(go, gitrg[a][b], shift(srclocs, multiply(loc, (h, w))))
        return {'input': gi, 'output': go}

    def generate_2bcee788(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 20))
        w = unifint(diff_lb, diff_ub, (2, 10))
        bgc, sepc, objc = sample(cols, 3)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        spi = randint(0, h - 1)
        sp = (spi, w - 1)
        shp = {sp}
        numcellsd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numc = choice((numcellsd, h * w - numcellsd))
        numc = min(max(2, numc), h * w - 1)
        reminds = set(remove(sp, inds))
        for k in range(numc):
            shp.add(choice(totuple((reminds - shp) & mapply(neighbors, shp))))
        while width(shp) == 1:
            shp.add(choice(totuple((reminds - shp) & mapply(neighbors, shp))))
        c2 = fill(c, objc, shp)
        borderinds = sfilter(shp, lambda ij: ij[1] == w - 1)
        c3 = fill(c, sepc, borderinds)
        gimini = asobject(hconcat(c2, vmirror(c3)))
        gomini = asobject(hconcat(c2, vmirror(c2)))
        fullh = unifint(diff_lb, diff_ub, (h+1, 30))
        fullw = unifint(diff_lb, diff_ub, (2*w+1, 30))
        fullg = canvas(bgc, (fullh, fullw))
        loci = randint(0, fullh - h)
        locj = randint(0, fullw - 2 * w)
        loc = (loci, locj)
        gi = paint(fullg, gimini)
        go = paint(fullg, gomini)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        go = replace(go, bgc, 3)
        return {'input': gi, 'output': go}

    def generate_a3df8b1e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        w = unifint(diff_lb, diff_ub, (2, 10))
        h = unifint(diff_lb, diff_ub, (w+1, 30))
        bgc, linc = sample(cols, 2)
        c = canvas(bgc, (h, w))
        sp = (h - 1, 0)
        gi = fill(c, linc, {sp})
        go = tuple(e for e in gi)
        changing = True
        direc = 1
        while True:
            sp = add(sp, (-1, direc))
            if sp[1] == w - 1 or sp[1] == 0:
                direc *= -1
            go2 = fill(go, linc, {sp})
            if go2 == go:
                break
            go = go2
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        gix = tuple(e for e in gi)
        gox = tuple(e for e in go)
        numlins = unifint(diff_lb, diff_ub, (1, 4))
        if numlins > 1:
            gi = fill(gi, linc, ofcolor(hmirror(gix), linc))
            go = fill(go, linc, ofcolor(hmirror(gox), linc))
        if numlins > 2:
            gi = fill(gi, linc, ofcolor(vmirror(gix), linc))
            go = fill(go, linc, ofcolor(vmirror(gox), linc))
        if numlins > 3:
            gi = fill(gi, linc, ofcolor(hmirror(vmirror(gix)), linc))
            go = fill(go, linc, ofcolor(hmirror(vmirror(gox)), linc))
        return {'input': gi, 'output': go}

    def generate_80af3007(diff_lb: float, diff_ub: float) -> dict:
        fullcols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        bgc = choice(fullcols)
        cols = remove(bgc, fullcols)
        c = canvas(bgc, (h, w))
        numcd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        numc = choice((numcd, h * w - numcd))
        numc = min(max(0, numc), h * w)
        inds = totuple(asindices(c))
        locs = tuple(set(sample(inds, numc)) | set(sample(totuple(corners(inds)), 3)))
        fgc = choice(cols)
        gi = fill(c, fgc, locs)
        go = canvas(bgc, (h**2, w**2))
        for loc in locs:
            go = fill(go, fgc, shift(locs, multiply(loc, (h, w))))
        fullh = unifint(diff_lb, diff_ub, (h**2+2, 30))
        fullw = unifint(diff_lb, diff_ub, (w**2+2, 30))
        fullg = canvas(bgc, (fullh, fullw))
        loci = randint(1, fullh - h**2 - 1)
        locj = randint(1, fullw - w**2 - 1)
        loc = (loci, locj)
        giups = hupscale(vupscale(gi, h), w)
        gi = paint(fullg, shift(asobject(giups), loc))
        return {'input': gi, 'output': go}

    def generate_e50d258f(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        padcol = choice(remcols)
        remcols = remove(padcol, remcols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 10))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        bound = None
        go = None
        while succ < num and tr <= maxtrials:
            if len(remcols) == 0 or len(indss) == 0:
                break
            oh = randint(3, 8)
            ow = randint(3, 8)
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            if bd.issubset(indss):
                numcc = unifint(diff_lb, diff_ub, (1, 7))
                ccols = sample(remcols, numcc)
                if succ == 0:
                    numred = unifint(diff_lb, diff_ub, (1, oh * ow))
                    bound = numred
                else:
                    numred = unifint(diff_lb, diff_ub, (0, min(oh * ow, bound - 1)))
                cc = canvas(choice(ccols), (oh, ow))
                cci = asindices(cc)
                subs = sample(totuple(cci), numred)
                obj1 = {(choice(ccols), ij) for ij in cci - set(subs)}
                obj2 = {(2, ij) for ij in subs}
                obj = obj1 | obj2
                gi = paint(gi, shift(obj, (loci, locj)))
                if go is None:
                    go = paint(cc, obj)
                succ += 1
                indss = (indss - bd) - outbox(bd)
            tr += 1
        return {'input': gi, 'output': go}

    def generate_0e206a2e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc, acol, bcol, ccol, Dcol = sample(cols, 5)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        nsrcs = unifint(diff_lb, diff_ub, (1, min(h, w) // 5))
        srcs = []
        abclist = []
        maxtrforsrc = 5 * nsrcs
        trforsrc = 0
        srcsucc = 0
        while trforsrc < maxtrforsrc and srcsucc < nsrcs:
            trforsrc += 1
            objsize = unifint(diff_lb, diff_ub, (5, 20))
            bb = asindices(canvas(-1, (7, 7)))
            sp = choice(totuple(bb))
            bb = remove(sp, bb)
            shp = {sp}
            for k in range(objsize - 1):
                shp.add(choice(totuple((bb - shp) & mapply(dneighbors, shp))))
            while 1 in shape(shp):
                shp.add(choice(totuple((bb - shp) & mapply(dneighbors, shp))))
            while len(set([x - y for x, y in shp])) == 1 or len(set([x + y for x, y in shp])) == 1:
                shp.add(choice(totuple((bb - shp) & mapply(dneighbors, shp))))
            shp = normalize(shp)
            shp = list(shp)
            shuffle(shp)
            a, b, c = shp[:3]
            while 1 in shape({a, b, c}) or (len(set([x - y for x, y in {a, b, c}])) == 1 or len(set([x + y for x, y in {a, b, c}])) == 1):
                shuffle(shp)
                a, b, c = shp[:3]
            if sorted(shape({a, b, c})) in abclist:
                continue
            D = shp[3:]
            markers = {(acol, a), (bcol, b), (ccol, c)}
            obj = markers | {(Dcol, ij) for ij in D}
            obj = frozenset(obj)
            oh, ow = shape(obj)
            opts = sfilter(inds, lambda ij: shift(set(shp), ij).issubset(inds))
            if len(opts) == 0:
                continue
            loc = choice(totuple(opts))
            srcsucc += 1
            gi = paint(gi, shift(obj, loc))
            shpplcd = shift(set(shp), loc)
            go = fill(go, -1, shpplcd)
            inds = (inds - shpplcd) - mapply(neighbors, shpplcd)
            srcs.append((obj, markers))
            abclist.append(sorted(shape({a, b, c})))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 30))
        maxtrials = 10 * num
        tr = 0
        succ = 0
        while succ < num and tr < maxtrials:
            mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
            fn = choice(mfs)
            gi = fn(gi)
            go = fn(go)
            aigo = asindices(go)
            fullinds = ofcolor(go, bgc) - mapply(neighbors, aigo - ofcolor(go, bgc))
            obj, markers = choice(srcs)
            shp = toindices(obj)
            if len(fullinds) == 0:
                break
            loctr = choice(totuple(fullinds))
            xx = shift(shp, loctr)
            if xx.issubset(fullinds):
                succ += 1
                gi = paint(gi, shift(markers, loctr))
                go = paint(go, shift(obj, loctr))
            tr += 1
        go = replace(go, -1, bgc)
        return {'input': gi, 'output': go}

    def generate_b230c067(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2))
        while True:
            h = unifint(diff_lb, diff_ub, (10, 30))
            w = unifint(diff_lb, diff_ub, (10, 30))
            oh = unifint(diff_lb, diff_ub, (2, h // 3 - 1))
            ow = unifint(diff_lb, diff_ub, (2, w // 3 - 1))
            numcd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))
            numc = choice((numcd, oh * ow - numcd))
            numca = min(max(2, numc), oh * ow - 2)
            bounds = asindices(canvas(-1, (oh, ow)))
            sp = choice(totuple(bounds))
            shp = {sp}
            for k in range(numca):
                ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))
                shp.add(ij)
            shpa = normalize(shp)
            shpb = set(normalize(shp))
            mxnch = oh * ow - len(shpa)
            nchinv = unifint(diff_lb, diff_ub, (1, mxnch))
            nch = mxnch - nchinv
            nch = min(max(1, nch), mxnch)
            for k in range(nch):
                ij = choice(totuple((bounds - shpb) & mapply(neighbors, shpb)))
                shpb.add(ij)
            if choice((True, False)):
                shpa, shpb = shpb, shpa
            bgc, fgc = sample(cols, 2)
            c = canvas(bgc, (h, w))
            inds = asindices(c)
            acands = sfilter(inds, lambda ij: ij[0] <= h - height(shpa) and ij[1] <= w - width(shpa))
            aloc = choice(totuple(acands))
            aplcd = shift(shpa, aloc)
            gi = fill(c, fgc, aplcd)
            go = fill(c, 2, aplcd)
            maxtrials = 10
            tr = 0
            succ = 0
            inds = (inds - aplcd) - mapply(neighbors, aplcd)
            inds = sfilter(inds, lambda ij: ij[0] <= h - height(shpb) and ij[1] <= w - width(shpb))
            while succ < 2 and tr <= maxtrials:
                if len(inds) == 0:
                    break
                loc = choice(totuple(inds))
                plcbd = shift(shpb, loc)
                if plcbd.issubset(inds):
                    gi = fill(gi, fgc, plcbd)
                    go = fill(go, 1, plcbd)
                    succ += 1
                    inds = (inds - plcbd) - mapply(neighbors, plcbd)
                tr += 1
            if succ == 2:
                break
        return {'input': gi, 'output': go}

    def generate_db93a21d(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 3))
        h = unifint(diff_lb, diff_ub, (12, 31))
        w = unifint(diff_lb, diff_ub, (12, 32))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(indss) == 0:
                break
            oh = randint(1, h // 4)
            ow = oh
            fullh = 4 * oh
            fullw = 4 * ow
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - fullh and ij[1] < w - fullw))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            bigobj = backdrop(frozenset({(loci, locj), (loci + fullh - 1, locj + fullw - 1)}))
            smallobj = backdrop(frozenset({(loci+oh, locj+ow), (loci + fullh - 1 - oh, locj + fullw - 1 - ow)}))
            if bigobj.issubset(indss | ofcolor(go, 3)):
                gi = fill(gi, fgc, smallobj)
                go = fill(go, 3, bigobj)
                go = fill(go, fgc, smallobj)
                strp = mapply(rbind(shoot, (1, 0)), connect(lrcorner(smallobj), llcorner(smallobj)))
                go = fill(go, 1, ofcolor(go, bgc) & strp)
                succ += 1
                indss = indss - bigobj
            tr += 1
        gi = gi[1:]
        go = go[1:]
        gi = tuple(r[1:-1] for r in gi)
        go = tuple(r[1:-1] for r in go)
        return {'input': gi, 'output': go}

    def generate_1e32b0e9(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 6))
        w = unifint(diff_lb, diff_ub, (4, 6))
        nh = unifint(diff_lb, diff_ub, (1, 4))
        nw = unifint(diff_lb, diff_ub, (1 if nh > 1 else 2, 3))
        bgc, linc, fgc = sample(cols, 3)
        fullh = h * nh + (nh - 1)
        fullw = w * nw + (nw - 1)
        c = canvas(linc, (fullh, fullw))
        smallc = canvas(bgc, (h, w))
        llocs = set()
        for a in range(0, fullh, h+1):
            for b in range(0, fullw, w + 1):
                llocs.add((a, b))
        llocs = tuple(llocs)
        srcloc = choice(llocs)
        remlocs = remove(srcloc, llocs)
        ncells = unifint(diff_lb, diff_ub, (0, (h - 2) * (w - 2) - 1))
        smallc2 = canvas(bgc, (h-2, w - 2))
        inds = asindices(smallc2)
        sp = choice(totuple(inds))
        inds = remove(sp, inds)
        shp = {sp}
        for j in range(ncells):
            ij = choice(totuple((inds - shp) & mapply(neighbors, shp)))
            shp.add(ij)
        shp = shift(shp, (1, 1))
        gg = asobject(fill(smallc, fgc, shp))
        gg2 = asobject(fill(smallc, linc, shp))
        gi = paint(c, shift(gg, srcloc))
        go = tuple(e for e in gi)
        ncc = ncells + 1
        for rl in remlocs:
            nleft = randint(0, ncc)
            subobj = sample(totuple(shp), nleft)
            sg2 = asobject(fill(smallc, fgc, subobj))
            gi = paint(gi, shift(sg2, rl))
            go = paint(go, shift(gg2, rl))
            go = fill(go, fgc, shift(subobj, rl))
        return {'input': gi, 'output': go}

    def generate_6773b310(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(1, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        nh = unifint(diff_lb, diff_ub, (2, 5))
        nw = unifint(diff_lb, diff_ub, (2, 5))
        bgc, linc, fgc = sample(cols, 3)
        fullh = h * nh + (nh - 1)
        fullw = w * nw + (nw - 1)
        c = canvas(linc, (fullh, fullw))
        smallc = canvas(bgc, (h, w))
        llocs = set()
        for a in range(0, fullh, h + 1):
            for b in range(0, fullw, w + 1):
                llocs.add((a, b))
        llocs = tuple(llocs)
        nbldev = unifint(diff_lb, diff_ub, (0, (nh * nw) // 2))
        nbl = choice((nbldev, nh * nw - nbldev))
        nbl = min(max(1, nbl), nh * nw - 1)
        bluelocs = sample(llocs, nbl)
        bglocs = difference(llocs, bluelocs)
        inds = totuple(asindices(smallc))
        gi = tuple(e for e in c)
        go = canvas(bgc, (nh, nw))
        for ij in bluelocs:
            subg = asobject(fill(smallc, fgc, sample(inds, 2)))
            gi = paint(gi, shift(subg, ij))
            a, b = ij
            loci = a // (h+1)
            locj = b // (w+1)
            go = fill(go, 1, {(loci, locj)})
        for ij in bglocs:
            subg = asobject(fill(smallc, fgc, sample(inds, 1)))
            gi = paint(gi, shift(subg, ij))
        return {'input': gi, 'output': go}

    def generate_6ecd11f4(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 7))
        w = unifint(diff_lb, diff_ub, (2, 7))
        bgc, fgc = sample(cols, 2)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, ncols)
        inds = asindices(canvas(bgc, (h, w)))
        nlocsd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        nlocs = choice((nlocsd, h * w - nlocsd))
        nlocs = min(max(3, nlocs), h * w - 1)
        sp = choice(totuple(inds))
        inds = remove(sp, inds)
        shp = {sp}
        for j in range(nlocs):
            ij = choice(totuple((inds - shp) & mapply(neighbors, shp)))
            shp.add(ij)
        shp = normalize(shp)
        h, w = shape(shp)
        canv = canvas(bgc, (h, w))
        objbase = fill(canv, fgc, shp)
        maxhscf = (2*h+h+1) // h
        maxwscf = (2*w+w+1) // w
        hscf = unifint(diff_lb, diff_ub, (2, maxhscf))
        wscf = unifint(diff_lb, diff_ub, (2, maxwscf))
        obj = asobject(hupscale(vupscale(objbase, hscf), wscf))
        oh, ow = shape(obj)
        inds = asindices(canv)
        objx = {(choice(ccols), ij) for ij in inds}
        if len(palette(objx)) == 1:
            objxodo = first(objx)
            objx = insert((choice(remove(objxodo[0], ccols)), objxodo[1]), remove(objxodo, objx))
        fullh = unifint(diff_lb, diff_ub, (hscf*h+h+1, 30))
        fullw = unifint(diff_lb, diff_ub, (wscf*w+w+1, 30))
        gi = canvas(bgc, (fullh, fullw))
        fullinds = asindices(gi)
        while True:
            loci = randint(0, fullh - oh)
            locj = randint(0, fullw - ow)
            loc = (loci, locj)
            gix = paint(gi, shift(obj, loc))
            ofc = ofcolor(gix, fgc)
            delt = (fullinds - ofc)
            delt2 = delt - mapply(neighbors, ofc)
            scands = sfilter(
                delt2,
                lambda ij: ij[0] <= fullh - oh and ij[1] <= fullw - ow
            )
            if len(scands) == 0:
                continue
            locc = choice(totuple(scands))
            shftd = shift(objx, locc)
            if toindices(shftd).issubset(delt2):
                gi = paint(gix, shftd)
                break
        go = paint(canv, objx)
        go = fill(go, bgc, ofcolor(objbase, bgc))
        return {'input': gi, 'output': go}

    def generate_8403a5d5(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(5, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        loccinv = unifint(diff_lb, diff_ub, (1, w - 1))
        locc = w - loccinv
        bgc, fgc = sample(cols, 2)
        c = canvas(bgc, (h, w))
        idx = (h - 1, locc)
        gi = fill(c, fgc, {idx})
        go = canvas(bgc, (h, w))
        for j in range(locc, w, 2):
            go = fill(go, fgc, connect((0, j), (h - 1, j)))
        for j in range(locc+1, w, 4):
            go = fill(go, 5, {(0, j)})
        for j in range(locc+3, w, 4):
            go = fill(go, 5, {(h-1, j)})
        return {'input': gi, 'output': go}

    def generate_941d9a10(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 3))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        opts = interval(2, (h-1)//2 + 1, 2)
        nhidx = unifint(diff_lb, diff_ub, (0, len(opts) - 1))
        nh = opts[nhidx]
        opts = interval(2, (w-1)//2 + 1, 2)
        nwidx = unifint(diff_lb, diff_ub, (0, len(opts) - 1))
        nw = opts[nwidx]
        bgc, fgc = sample(cols, 2)
        hgrid = canvas(bgc, (2*nh+1, w))
        for j in range(1, h, 2):
            hgrid = fill(hgrid, fgc, connect((j, 0), (j, w)))
        for k in range(h - (2*nh+1)):
            loc = randint(0, height(hgrid) - 1)
            hgrid = hgrid[:loc] + canvas(bgc, (1, w)) + hgrid[loc:]
        wgrid = canvas(bgc, (2*nw+1, h))
        for j in range(1, w, 2):
            wgrid = fill(wgrid, fgc, connect((j, 0), (j, h)))
        for k in range(w - (2*nw+1)):
            loc = randint(0, height(wgrid) - 1)
            wgrid = wgrid[:loc] + canvas(bgc, (1, h)) + wgrid[loc:]
        wgrid = dmirror(wgrid)
        gi = canvas(bgc, (h, w))
        fronts = ofcolor(hgrid, fgc) | ofcolor(wgrid, fgc)
        gi = fill(gi, fgc, fronts)
        objs = objects(gi, T, T, F)
        objs = colorfilter(objs, bgc)
        blue = argmin(objs, lambda o: leftmost(o) + uppermost(o))
        green = argmax(objs, lambda o: leftmost(o) + uppermost(o))
        f1 = lambda o: len(sfilter(objs, lambda o2: leftmost(o2) < leftmost(o))) == len(sfilter(objs, lambda o2: leftmost(o2) > leftmost(o)))
        f2 = lambda o: len(sfilter(objs, lambda o2: uppermost(o2) < uppermost(o))) == len(sfilter(objs, lambda o2: uppermost(o2) > uppermost(o)))
        red = extract(objs, lambda o: f1(o) and f2(o))
        go = fill(gi, 1, blue)
        go = fill(go, 3, green)
        go = fill(go, 2, red)
        return {'input': gi, 'output': go}

    def generate_b0c4d837(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        oh = unifint(diff_lb, diff_ub, (3, h - 1))
        ow = unifint(diff_lb, diff_ub, (3, w - 1))
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        bgc, boxc, fillc = sample(cols, 3)
        subg = canvas(boxc, (oh, ow))
        subg2 = canvas(fillc, (oh-1, ow-2))
        ntofill = unifint(diff_lb, diff_ub, (1, min(9, oh-2)))
        for j in range(ntofill):
            subg2 = fill(subg2, bgc, connect((j, 0), (j, ow-2)))
        subg = paint(subg, shift(asobject(subg2), (0, 1)))
        gi = canvas(bgc, (h, w))
        gi = paint(gi, shift(asobject(subg), (loci, locj)))
        go = repeat(fillc, ntofill) + repeat(bgc, 9 - ntofill)
        go = (go[:3], go[3:6][::-1], go[6:])
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        return {'input': gi, 'output': go}

    def generate_0a938d79(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 29))
        w = unifint(diff_lb, diff_ub, (h+1, 30))
        bgc, cola, colb = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        locja = unifint(diff_lb, diff_ub, (3, w - 2))
        locjb = unifint(diff_lb, diff_ub, (1, locja - 2))
        locia = choice((0, h-1))
        locib = choice((0, h-1))
        gi = fill(gi, cola, {(locia, locja)})
        gi = fill(gi, colb, {(locib, locjb)})
        ofs = -2 * (locja-locjb)
        for aa in range(locja, -1, ofs):
            go = fill(go, cola, connect((0, aa), (h-1, aa)))
        for bb in range(locjb, -1, ofs):    
            go = fill(go, colb, connect((0, bb), (h-1, bb)))
        rotf = choice((rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_b7249182(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        ih = unifint(diff_lb, diff_ub, (3, (h-1)//2))
        bgc, ca, cb = sample(cols, 3)
        subg = canvas(bgc, (ih, 5))
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        subg = fill(subg, ca, connect((0, 2), (ih-2, 2)))
        subg = fill(subg, ca, connect((ih-2, 0), (ih-2, 4)))
        subg = fill(subg, ca, {(ih-1, 0)})
        subga = fill(subg, ca, {(ih-1, 4)})
        subgb = replace(subga, ca, cb)
        subg = vconcat(subga, hmirror(subgb))
        loci = randint(0, h-2*ih)
        locj = randint(0, w-5)
        obj = asobject(subg)
        obj = shift(obj, (loci, locj))
        gi = fill(gi, ca, {(loci, locj+2)})
        gi = fill(gi, cb, {(loci+2*ih-1, locj+2)})
        go = paint(go, obj)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_7b6016b9(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, remove(2, interval(0, 10, 1)))
        while True:
            h = unifint(diff_lb, diff_ub, (5, 30))
            w = unifint(diff_lb, diff_ub, (5, 30))
            bgc, fgc = sample(cols, 2)
            numl = unifint(diff_lb, diff_ub, (4, min(h, w)))
            gi = canvas(bgc, (h, w))
            jint = interval(0, w, 1)
            iint = interval(0, h, 1)
            iopts = interval(1, h-1, 1)
            jopts = interval(1, w-1, 1)
            numlh = randint(numl//3, numl//3*2)
            numlw = numl - numlh
            for k in range(numlh):
                if len(iopts) == 0:
                    continue
                loci = choice(iopts)
                iopts = remove(loci, iopts)
                iopts = remove(loci+1, iopts)
                iopts = remove(loci-1, iopts)
                a, b = sample(jint, 2)
                a = randint(0, a)
                b = randint(b, w - 1)
                gi = fill(gi, fgc, connect((loci, a), (loci, b)))
            for k in range(numlw):
                if len(jopts) == 0:
                    continue
                locj = choice(jopts)
                jopts = remove(locj, jopts)
                jopts = remove(locj+1, jopts)
                jopts = remove(locj-1, jopts)
                a, b = sample(iint, 2)
                a = randint(0, a)
                b = randint(b, h - 1)
                gi = fill(gi, fgc, connect((a, locj), (b, locj)))
            objs = objects(gi, T, F, F)
            bgobjs = colorfilter(objs, bgc)
            tofill = toindices(mfilter(bgobjs, compose(flip, rbind(bordering, gi))))
            if len(tofill) > 0:
                break
        tofix = mapply(neighbors, tofill) - tofill
        gi = fill(gi, fgc, tofix)
        go = fill(gi, 2, tofill)
        go = replace(go, bgc, 3)
        return {'input': gi, 'output': go}

    def generate_72ca375d(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 25))
        srcobjh = unifint(diff_lb, diff_ub, (2, 8))
        srcobjwh = unifint(diff_lb, diff_ub, (1, 4))
        bnds = asindices(canvas(-1, (srcobjh, srcobjwh)))
        spi = randint(0, srcobjh - 1)
        sp = (spi, srcobjwh - 1)
        srcobj = {sp}
        bnds = remove(sp, bnds)
        ncellsd = unifint(diff_lb, diff_ub, (0, (srcobjh * srcobjwh) // 2))
        ncells1 = choice((ncellsd, srcobjh * srcobjwh - ncellsd))
        ncells2 = unifint(diff_lb, diff_ub, (1, srcobjh * srcobjwh))
        ncells = (ncells1 + ncells2) // 2
        ncells = min(max(1, ncells), srcobjh * srcobjwh, (h * w) // 2 - 1)
        for k in range(ncells - 1):
            srcobj.add(choice(totuple((bnds - srcobj) & mapply(neighbors, srcobj))))
        srcobj = normalize(srcobj)
        srcobj = srcobj | shift(vmirror(srcobj), (0, width(srcobj)))
        srcobjh, srcobjw = shape(srcobj)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        trgc = choice(remcols)
        go = canvas(bgc, (srcobjh, srcobjw))
        go = fill(go, trgc, srcobj)
        loci = randint(0, h - srcobjh)
        locj = randint(0, w - srcobjw)
        locc = (loci, locj)
        gi = canvas(bgc, (h, w))
        shftd = shift(srcobj, locc)
        gi = fill(gi, trgc, shftd)
        indss = asindices(gi)
        indss = (indss - shftd) - mapply(neighbors, shftd)
        maxtrials = 4 * nobjs
        tr = 0
        succ = 0
        remcands = asindices(canvas(-1, (8, 8))) - srcobj
        while succ < nobjs and tr <= maxtrials:
            if len(indss) == 0:
                break
            while True:
                newobj = {e for e in srcobj}
                numperti = unifint(diff_lb, diff_ub, (1, 63))
                numpert = 64 - numperti
                for np in range(numpert):
                    isadd = choice((True, False))
                    if isadd and len(newobj) < 64:
                        cndds = totuple((remcands - newobj) & mapply(neighbors, newobj))
                        if len(cndds) == 0:
                            break
                        newobj.add(choice(cndds))
                    if not isadd and len(newobj) > 2:
                        newobj = remove(choice(totuple(newobj)), newobj)
                newobj = normalize(newobj)
                a, b = shape(newobj)
                cc = canvas(-1, (a+2, b+2))
                cc2 = compress(fill(cc, -2, shift(newobj, (1, 1))))
                newobj = toindices(argmax(colorfilter(objects(cc2, T, T, F), -2), size))
                if newobj != vmirror(newobj):
                    break
            col = choice(remcols)
            loccands = sfilter(indss, lambda ij: shift(newobj, ij).issubset(indss))
            if len(loccands) == 0:
                tr += 1
                continue
            locc = choice(totuple(loccands))
            newobj = shift(newobj, locc)
            gi = fill(gi, col, newobj)
            succ += 1
            indss = (indss - newobj) - mapply(neighbors, newobj)
        return {'input': gi, 'output': go}

    def generate_673ef223(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        barh = unifint(diff_lb, diff_ub, (2, (h-1)//2))
        ncells = unifint(diff_lb, diff_ub, (1, barh))
        bgc, barc, dotc = sample(cols, 3)
        sg = canvas(bgc, (barh, w))
        topsgi = fill(sg, barc, connect((0, 0), (barh-1, 0)))
        botsgi = vmirror(topsgi)
        topsgo = tuple(e for e in topsgi)
        botsgo = tuple(e for e in botsgi)
        iloccands = interval(0, barh, 1)
        ilocs = sample(iloccands, ncells)
        for k in ilocs:
            jloc = randint(2, w - 2)
            topsgi = fill(topsgi, dotc, {(k, jloc)})
            topsgo = fill(topsgo, 4, {(k, jloc)})
            topsgo = fill(topsgo, dotc, connect((k, 1), (k, jloc-1)))
            botsgo = fill(botsgo, dotc, connect((k, 0), (k, w - 2)))
        outpi = (topsgi, botsgi)
        outpo = (topsgo, botsgo)
        rr = canvas(bgc, (1, w))
        while len(merge(outpi)) < h:
            idx = randint(0, len(outpi) - 1)
            outpi = outpi[:idx] + (rr,) + outpi[idx:]
            outpo = outpo[:idx] + (rr,) + outpo[idx:]
        gi = merge(outpi)
        go = merge(outpo)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_868de0fa(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 7))    
        h = unifint(diff_lb, diff_ub, (9, 30))
        w = unifint(diff_lb, diff_ub, (9, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        num = unifint(diff_lb, diff_ub, (1, 9))
        indss = asindices(gi)
        maxtrials = 4 * num
        tr = 0
        succ = 0
        while succ < num and tr <= maxtrials:
            if len(indss) == 0:
                break
            oh = randint(3, 8)
            ow = oh
            subs = totuple(sfilter(indss, lambda ij: ij[0] < h - oh and ij[1] < w - ow))
            if len(subs) == 0:
                tr += 1
                continue
            loci, locj = choice(subs)
            obj = frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})
            bd = backdrop(obj)
            col = choice(remcols)
            if bd.issubset(indss):
                gi = fill(gi, col, box(bd))
                if oh % 2 == 1:
                    go = fill(go, 7, bd)
                else:
                    go = fill(go, 2, bd)
                go = fill(go, col, box(bd))
                succ += 1
                indss = (indss - bd) - outbox(bd)
            tr += 1
        return {'input': gi, 'output': go}

    def generate_40853293(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        nlines = unifint(diff_lb, diff_ub, (2, min(8, (h*w)//2)))
        nhorilines = randint(1, nlines - 1)
        nvertilines = nlines - nhorilines
        ilocs = interval(0, h, 1)
        ilocs = sample(ilocs, min(nhorilines, len(ilocs)))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        for ii in ilocs:
            llen = unifint(diff_lb, diff_ub, (2, w - 1))
            js = randint(0, w - llen)
            je = js + llen - 1
            a = (ii, js)
            b = (ii, je)
            hln = connect(a, b)
            col = choice(remcols)
            remcols = remove(col, remcols)
            gi = fill(gi, col, {a, b})
            go = fill(go, col, hln)
        jlocs = interval(0, w, 1)
        gim = dmirror(gi)
        jlocs = sfilter(jlocs, lambda j: sum(1 for e in gim[j] if e == bgc) > 1)
        nvertilines = min(nvertilines, len(jlocs))
        jlocs = sample(jlocs, nvertilines)
        for jj in jlocs:
            jcands = [idx for idx, e in enumerate(gim[jj]) if e == bgc]
            kk = len(jcands)
            locopts = interval(0, kk, 1)
            llen = unifint(diff_lb, diff_ub, (2, kk))
            sp = randint(0, kk - llen)
            ep = sp + llen - 1
            sp = jcands[sp]
            ep = jcands[ep]
            a = (sp, jj)
            b = (ep, jj)
            vln = connect(a, b)
            col = choice(remcols)
            remcols = remove(col, remcols)
            gi = fill(gi, col, {a, b})
            go = fill(go, col, vln)
        return {'input': gi, 'output': go}

    def generate_6e19193c(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        dirs = (
        ((0, 0), (-1, -1)),
        ((0, 1), (-1, 1)),
        ((1, 0), (1, -1)),
        ((1, 1), (1, 1))
        )
        base = ((0, 0), (1, 0), (0, 1), (1, 1))
        candsi = [
        set(base) - {dr[0]} for dr in dirs
        ]
        candso = [
        (set(base) | shoot(dr[0], dr[1])) - {dr[0]} for dr in dirs
        ]
        cands = list(zip(candsi, candso))    
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 8))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        fullinds = asindices(gi)
        inds = asindices(canvas(-1, (h, w)))
        kk, tr = 0, 0
        maxtrials = num * 4
        while kk < num and tr < maxtrials:
            if len(inds) == 0:
                break
            loc = choice(totuple(inds))
            obji, objo = choice(cands)
            obji = shift(obji, loc)
            objo = shift(objo, loc)
            objo = objo & fullinds
            if objo.issubset(inds) and obji.issubset(objo):
                col = choice(remcols)
                gi = fill(gi, col, obji)
                go = fill(go, col, objo)
                inds = (inds - objo) - mapply(dneighbors, obji)
                kk += 1
            tr += 1
        return {'input': gi, 'output': go}

    def generate_8731374e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        inh = randint(5, h - 2)
        inw = randint(5, w - 2)
        bgc, fgc = sample(cols, 2)
        num = unifint(diff_lb, diff_ub, (1, min(inh, inw)))
        mat = canvas(bgc, (inh - 2, inw - 2))
        tol = lambda g: list(list(e) for e in g)
        tot = lambda g: tuple(tuple(e) for e in g)
        mat = fill(mat, fgc, connect((0, 0), (num - 1, num - 1)))
        mat = tol(mat)
        shuffle(mat)
        mat = tol(dmirror(tot(mat)))
        shuffle(mat)
        mat = dmirror(tot(mat))
        sgi = paint(canvas(bgc, (inh, inw)), shift(asobject(mat), (1, 1)))
        inds = ofcolor(sgi, fgc)
        lins = mapply(fork(combine, vfrontier, hfrontier), inds)
        go = fill(sgi, fgc, lins)
        numci = unifint(diff_lb, diff_ub, (3, 10))
        numc = 13 - numci
        ccols = sample(cols, numc)
        c = canvas(-1, (h, w))
        inds = asindices(c)
        obj = {(choice(ccols), ij) for ij in inds}
        gi = paint(c, obj)
        loci = randint(1, h - inh - 1)
        locj = randint(1, w - inw - 1)
        loc = (loci, locj)
        plcd = shift(asobject(sgi), loc)
        gi = paint(gi, plcd)
        a, b = ulcorner(plcd)
        c, d = lrcorner(plcd)
        p1 = choice(totuple(connect((a - 1, b), (a - 1, d))))
        p2 = choice(totuple(connect((a, b - 1), (c, b - 1))))
        p3 = choice(totuple(connect((c + 1, b), (c + 1, d))))
        p4 = choice(totuple(connect((a, d + 1), (c, d + 1))))
        remcols = remove(bgc, ccols)
        fixobj = {
            (choice(remcols), p1), (choice(remcols), p2),
            (choice(remcols), p3), (choice(remcols), p4)
        }
        gi = paint(gi, fixobj)
        return {'input': gi, 'output': go}

    def generate_cce03e0d(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 8))    
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        nred = unifint(diff_lb, diff_ub, (1, h * w - 1))
        ncols = unifint(diff_lb, diff_ub, (1, min(8, nred)))
        ncells = unifint(diff_lb, diff_ub, (1, h * w - nred))
        ccols = sample(cols, ncols)
        gi = canvas(0, (h, w))
        inds = asindices(gi)
        reds = sample(totuple(inds), nred)
        reminds = difference(inds, reds)
        gi = fill(gi, 2, reds)
        rest = sample(totuple(reminds), ncells)
        rest = {(choice(ccols), ij) for ij in rest}
        gi = paint(gi, rest)
        go = canvas(0, (h**2, w**2))
        locs = apply(rbind(multiply, (h, w)), reds)
        res = mapply(lbind(shift, asobject(gi)), locs)
        go = paint(go, res)
        return {'input': gi, 'output': go}

    def generate_f9012d9b(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)    
        hp = unifint(diff_lb, diff_ub, (2, 10))
        wp = unifint(diff_lb, diff_ub, (2, 10))
        srco = canvas(0, (hp, wp))
        inds = asindices(srco)
        nc = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(cols, nc)
        obj = {(choice(ccols), ij) for ij in inds}
        srco = paint(srco, obj)
        gi = paint(srco, obj)
        numhp = unifint(diff_lb, diff_ub, (3, 30 // hp))
        numwp = unifint(diff_lb, diff_ub, (3, 30 // wp))
        for k in range(numhp - 1):
            gi = vconcat(gi, srco)
        srco = tuple(e for e in gi)
        for k in range(numwp - 1):
            gi = hconcat(gi, srco)
        hcropfac = randint(0, hp)
        for k in range(hcropfac):
            gi = gi[:-1]
        gi = dmirror(gi)
        wcropfac = randint(0, wp)
        for k in range(wcropfac):
            gi = gi[:-1]
        gi = dmirror(gi)
        h, w = shape(gi)
        sgh = unifint(diff_lb, diff_ub, (1, h - hp - 1))
        sgw = unifint(diff_lb, diff_ub, (1, w - wp - 1))
        loci = randint(0, h - sgh)
        locj = randint(0, w - sgw)
        loc = (loci, locj)
        shp = (sgh, sgw)
        obj = {loc, decrement(add(loc, shp))}
        obj = backdrop(obj)
        go = subgrid(obj, gi)
        gi = fill(gi, 0, obj)
        mf = choice((
            identity, rot90, rot180, rot270,
            dmirror, vmirror, hmirror, cmirror
        ))
        gi = mf(gi)
        go = mf(go)
        return {'input': gi, 'output': go}

    def generate_f8ff0b80(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        nobjs = unifint(diff_lb, diff_ub, (1, min(30, (h * w) // 25)))
        gi = canvas(bgc, (h, w))
        numcells = unifint(diff_lb, diff_ub, (nobjs+1, 36))
        base = asindices(canvas(-1, (6, 6)))
        maxtr = 10
        inds = asindices(gi)
        go = []
        for k in range(nobjs):
            if len(inds) == 0 or numcells < 2:
                break
            numcells = unifint(diff_lb, diff_ub, (nobjs - k, numcells - 1))
            if numcells == 0:
                break
            sp = choice(totuple(base))
            shp = {sp}
            reminds = remove(sp, base)
            for kk in range(numcells - 1):
                shp.add(choice(totuple((reminds - shp) & mapply(neighbors, shp))))
            shp = normalize(shp)
            validloc = False
            rems = sfilter(inds, lambda ij: ij[0] <= h - height(shp) and ij[1] <= w - width(shp))
            if len(rems) == 0:
                break
            loc = choice(totuple(rems))
            tr = 0
            while not validloc and tr < maxtr:
                loc = choice(totuple(inds))
                validloc = shift(shp, loc).issubset(inds)
                tr += 1
            if validloc:
                plcd = shift(shp, loc)
                col = choice(remcols)
                go.append(col)
                inds = (inds - plcd) - mapply(neighbors, plcd)
                gi = fill(gi, col, plcd)
        go = dmirror((tuple(go),))
        return {'input': gi, 'output': go}

    def generate_e21d9049(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        ph = unifint(diff_lb, diff_ub, (2, 9))
        pw = unifint(diff_lb, diff_ub, (2, 9))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        hbar = frozenset({(choice(remcols), (k, 0)) for k in range(ph)})
        wbar = frozenset({(choice(remcols), (0, k)) for k in range(pw)})
        locih = randint(0, h - ph)
        locjh = randint(0, w - 1)
        loch = (locih, locjh)
        locjw = randint(0, w - pw)
        lociw = randint(0, h - 1)
        locw = (lociw, locjw)
        canv = canvas(bgc, (h, w))
        hbar = shift(hbar, loch)
        wbar = shift(wbar, locw)
        cp = (lociw, locjh)
        col = choice(remcols)
        hbard = extract(hbar, lambda cij: abs(cij[1][0] - lociw) % ph == 0)[1]
        hbar = sfilter(hbar, lambda cij: abs(cij[1][0] - lociw) % ph != 0) | {(col, hbard)}
        wbard = extract(wbar, lambda cij: abs(cij[1][1] - locjh) % pw == 0)[1]
        wbar = sfilter(wbar, lambda cij: abs(cij[1][1] - locjh) % pw != 0) | {(col, wbard)}
        gi = paint(canv, hbar | wbar)
        go = paint(canv, hbar | wbar)
        for k in range(h//ph + 1):
            go = paint(go, shift(hbar, (k*ph, 0)))
            go = paint(go, shift(hbar, (-k*ph, 0)))
        for k in range(w//pw + 1):
            go = paint(go, shift(wbar, (0, k*pw)))
            go = paint(go, shift(wbar, (0, -k*pw)))
        return {'input': gi, 'output': go}

    def generate_d4f3cd78(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        ih = unifint(diff_lb, diff_ub, (3, h//3*2))
        iw = unifint(diff_lb, diff_ub, (3, w//3*2))
        loci = randint(1, h - ih - 1)
        locj = randint(1, w - iw - 1)
        crns = frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)})
        fullcrns = corners(crns)
        bx = box(crns)
        opts = bx - fullcrns
        bgc, fgc = sample(cols, 2)
        c = canvas(bgc, (h, w))
        nholes = unifint(diff_lb, diff_ub, (1, len(opts)))
        holes = sample(totuple(opts), nholes)
        gi = fill(c, fgc, bx - set(holes))
        bib = backdrop(inbox(bx))
        go = fill(gi, 8, bib)
        A, B = ulcorner(bib)
        C, D = lrcorner(bib)
        f1 = lambda idx: 1 if idx > C else (-1 if idx < A else 0)
        f2 = lambda idx: 1 if idx > D else (-1 if idx < B else 0)
        f = lambda d: shoot(d, (f1(d[0]), f2(d[1])))
        res = mapply(f, set(holes))
        go = fill(go, 8, res)
        return {'input': gi, 'output': go}

    def generate_9d9215db(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (5, 14))
        w = unifint(diff_lb, diff_ub, (5, 14))
        h = h * 2 + 1
        w = w * 2 + 1
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ub = min(h, w)//4
        nrings = unifint(diff_lb, diff_ub, (1, ub))
        onlinesbase = tuple([(2*k+1, 2*k+1) for k in range(ub)])
        onlines = sample(onlinesbase, nrings)
        onlines = {(choice(remcols), ij) for ij in onlines}
        gi = canvas(bgc, (h, w))
        gi = paint(gi, onlines)
        linsbase = apply(rbind(add, (0, 2)), onlinesbase[:-1])
        nlines = unifint(diff_lb, diff_ub, (1, len(linsbase)))
        linesps = sample(linsbase, nlines)
        colors = [choice(remcols) for k in range(nlines)]
        dots = {(col, ij) for col, ij in zip(colors, linesps)}
        dots2 = {(col, ij[::-1]) for col, ij in zip(colors, linesps)}
        gi = paint(gi, dots | dots2)
        ff = lambda ij: ij[1] % 2 == 1
        ff2 = lambda ij: ij[0] % 2 == 1
        linesps2 = tuple(x[::-1] for x in linesps)
        lines = tuple(sfilter(connect(ij, (ij[0], w - ij[1] - 1)), ff) for ij in linesps)
        lines2 = tuple(sfilter(connect(ij, (h - ij[0] - 1, ij[1])), ff2) for ij in linesps2)
        lines = merge({recolor(col, l1 | l2) for col, (l1, l2) in zip(colors, zip(lines, lines2))})
        gobase = paint(gi, lines)
        go = paint(gobase, merge(fgpartition(vmirror(gobase))))
        go = paint(go, merge(fgpartition(hmirror(gobase))))
        go = paint(go, merge(fgpartition(vmirror(hmirror(gobase)))))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_0ca9ddb6(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 4, 6, 7, 8))
        xi = {(8, (0, 0))}
        xo = {(8, (0, 0))}
        ai = {(6, (0, 0))}
        ao = {(6, (0, 0))}
        bi = {(2, (1, 1))}
        bo = {(2, (1, 1))} | recolor(4, ineighbors((1, 1)))
        ci = {(1, (1, 1))}
        co = {(1, (1, 1))} | recolor(7, dneighbors((1, 1)))
        arr = ((ai, ao), (bi, bo), (ci, co), (xi, xo))    
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 4))
        maxtr = 5 * nobjs
        tr = 0
        succ = 0
        bgc = choice(cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while succ < nobjs and tr < maxtr:
            ino, outo = choice(arr)
            loc = choice(totuple(inds))
            oplcd = shift(outo, loc)
            oplcdi = toindices(oplcd)
            if oplcdi.issubset(inds):
                succ += 1
                gi = paint(gi, shift(ino, loc))
                go = paint(go, oplcd)
                inds = inds - oplcdi
            tr += 1
        return {'input': gi, 'output': go}

    def generate_5521c0d9(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        inds = interval(0, w, 1)
        nobjs = unifint(diff_lb, diff_ub, (1, w//3))
        speps = sample(inds, nobjs*2)
        while 0 in speps or w - 1 in speps:
            nobjs = unifint(diff_lb, diff_ub, (1, w//3))
            speps = sample(inds, nobjs*2)
        speps = sorted(speps)
        starts = speps[::2]
        ends = speps[1::2]
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, ncols)
        forb = -1
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        forb = -1
        for sp, ep in zip(starts, ends):
            col = choice(remove(forb, ccols))
            forb = col
            hdev = unifint(diff_lb, diff_ub, (0, h//2))
            hei = choice((hdev, h - hdev))
            hei = min(max(1, hei), h - 1)
            ulc = (h - hei, sp)
            lrc = (h - 1, ep)
            obj = backdrop(frozenset({ulc, lrc}))
            gi = fill(gi, col, obj)
            go = fill(go, col, shift(obj, (-hei, 0)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_e3497940(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (3, 14))
        bgc, barc = sample(cols, 2)
        remcols = remove(barc, remove(bgc, cols))
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, ncols)
        nlinesocc = unifint(diff_lb, diff_ub, (1, h))
        lopts = interval(0, h, 1)
        linesocc = sample(lopts, nlinesocc)
        rs = canvas(bgc, (h, w))
        ls = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        for idx in linesocc:
            j = unifint(diff_lb, diff_ub, (1, w - 1))
            obj = [(choice(ccols), (idx, jj)) for jj in range(j)]
            go = paint(go, obj)
            slen = randint(1, j)
            obj2 = obj[:slen]
            if choice((True, False)):
                obj, obj2 = obj2, obj
            rs = paint(rs, obj)
            ls = paint(ls, obj2)
        gi = hconcat(hconcat(vmirror(ls), canvas(barc, (h, 1))), rs)
        go = vmirror(go)
        return {'input': gi, 'output': go}

    def generate_6cdd2623(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        linc = choice(remcols)
        remcols = remove(linc, remcols)
        nnoisecols = unifint(diff_lb, diff_ub, (1, 7))
        noisecols = sample(remcols, nnoisecols)
        c = canvas(bgc, (h, w))
        ininds = totuple(shift(asindices(canvas(-1, (h-2, w-1))), (1, 1)))
        fixinds = sample(ininds, nnoisecols)
        fixobj = {(col, ij) for col, ij in zip(list(noisecols), fixinds)}
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        gi = paint(gi, fixobj)
        nnoise = unifint(diff_lb, diff_ub, (1, (h * w - nnoisecols) // 3))
        noise = sample(totuple(asindices(c) - set(fixinds)), nnoise)
        noise = {(choice(remcols), ij) for ij in noise}
        gi = paint(gi, noise)
        ilocs = interval(1, h - 1, 1)
        jlocs = interval(1, w - 1, 1)
        aa, bb = sample((0, 1), 2)
        nilocs = unifint(diff_lb, diff_ub, (aa, (h - 2) // 2))
        njlocs = unifint(diff_lb, diff_ub, (bb, (w - 2) // 2))
        ilocs = sample(ilocs, nilocs)
        jlocs = sample(jlocs, njlocs)
        for ii in ilocs:
            gi = fill(gi, linc, {(ii, 0)})
            gi = fill(gi, linc, {(ii, w - 1)})
            go = fill(go, linc, connect((ii, 0), (ii, w - 1)))
        for jj in jlocs:
            gi = fill(gi, linc, {(0, jj)})
            gi = fill(gi, linc, {(h - 1, jj)})
            go = fill(go, linc, connect((0, jj), (h - 1, jj)))
        return {'input': gi, 'output': go}

    def generate_dc433765(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc, src = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        if choice((True, False)):
            opts = {(ii, 0) for ii in range(h - 2)} | {(0, jj) for jj in range(1, w - 2, 1)}
            opts = tuple([inds & shoot(src, (1, 1)) for src in opts])
            opts = order(opts, size)
            k = len(opts)
            opt = unifint(diff_lb, diff_ub, (0, k - 1))
            ln = order(opts[opt], first)
            epi = unifint(diff_lb, diff_ub, (2, len(ln) - 1))
            ep = ln[epi]
            ln = ln[:epi-1][::-1]
            spi = unifint(diff_lb, diff_ub, (0, len(ln) - 1))
            sp = ln[spi]
            gi = fill(gi, src, {sp})
            gi = fill(gi, 4, {ep})
            go = fill(go, src, {add(sp, (1, 1))})
            go = fill(go, 4, {ep})
        else:
            loci = randint(0, h - 1)
            objw = unifint(diff_lb, diff_ub, (3, w))
            locj1 = randint(0, w - objw)
            locj2 = locj1 + objw - 1
            sp = (loci, locj1)
            ep = (loci, locj2)
            gi = fill(gi, src, {sp})
            gi = fill(gi, 4, {ep})
            go = fill(go, src, {add(sp, (0, 1))})
            go = fill(go, 4, {ep})
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_d2abd087(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        bgc = choice(difference(cols, (1, 2)))
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 10))
        maxtrials = 4 * nobjs
        tr = 0
        succ = 0
        while succ < nobjs and tr <= maxtrials:
            if len(inds) == 0:
                break
            opts = asindices(canvas(-1, (5, 5)))
            sp = choice(totuple(opts))
            opts = remove(sp, opts)
            lb = unifint(diff_lb, diff_ub, (1, 5))
            lopts = interval(lb, 6, 1)
            ubi = unifint(diff_lb, diff_ub, (1, 5))
            ub = 12 - ubi
            uopts = interval(7, ub + 1, 1)
            if choice((True, False)):
                numcells = 6
            else:
                numcells = choice(lopts + uopts)
            obj = {sp}
            for k in range(numcells - 1):
                obj.add(choice(totuple((opts - obj) & mapply(dneighbors, obj))))
            obj = normalize(obj)
            loc = choice(totuple(inds))
            plcd = shift(obj, loc)
            if plcd.issubset(inds):
                gi = fill(gi, choice(remcols), plcd)
                go = fill(go, 1 + (len(obj) == 6), plcd)
                succ += 1
                inds = (inds - plcd) - mapply(dneighbors, plcd)
            tr += 1
        return {'input': gi, 'output': go}

    def generate_88a10436(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        objh = unifint(diff_lb, diff_ub, (0, 2))
        objw = unifint(diff_lb, diff_ub, (0 if objh > 0 else 1, 2))
        objh = objh * 2 + 1
        objw = objw * 2 + 1
        bb = asindices(canvas(-1, (objh, objw)))
        sp = (objh // 2, objw // 2)
        obj = {sp}
        bb = remove(sp, bb)
        ncells = unifint(diff_lb, diff_ub, (max(objh, objw), objh * objw))
        for k in range(ncells - 1):
            obj.add(choice(totuple((bb - obj) & mapply(dneighbors, obj))))
        while height(obj) != objh or width(obj) != objw:
            obj.add(choice(totuple((bb - obj) & mapply(dneighbors, obj))))
        bgc, fgc = sample(cols, 2)
        remcols = remove(bgc, remove(fgc, cols))
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, ncols)
        obj = {(choice(ccols), ij) for ij in obj}
        obj = normalize(obj)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        loci = randint(0, h - objh)
        locj = randint(0, w - objw)
        loc = (loci, locj)
        plcd = shift(obj, loc)
        gi = paint(gi, plcd)
        go = paint(go, plcd)
        inds = (asindices(gi) - toindices(plcd)) - mapply(neighbors, toindices(plcd))
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // (2 * ncells)))
        maxtrials = 4 * nobjs
        tr = 0
        succ = 0
        while succ < nobjs and tr <= maxtrials:
            if len(inds) == 0:
                break
            loc = choice(totuple(inds))
            plcd = shift(obj, loc)
            plcdi = toindices(plcd)
            if plcdi.issubset(inds):
                go = paint(go, plcd)
                gi = fill(gi, fgc, {center(plcdi)})
                succ += 1
                inds = (inds - plcdi) - mapply(dneighbors, plcdi)
            tr += 1
        return {'input': gi, 'output': go}

    def generate_05f2a901(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        objh = unifint(diff_lb, diff_ub, (2, min(w//2, h//2)))
        objw = unifint(diff_lb, diff_ub, (objh, w//2))
        bb = asindices(canvas(-1, (objh, objw)))
        sp = choice(totuple(bb))
        obj = {sp}
        bb = remove(sp, bb)
        ncells = unifint(diff_lb, diff_ub, (objh + objw, objh * objw))
        for k in range(ncells - 1):
            obj.add(choice(totuple((bb - obj) & mapply(dneighbors, obj))))
        if height(obj) * width(obj) == len(obj):
            obj = remove(choice(totuple(obj)), obj)
        obj = normalize(obj)
        objh, objw = shape(obj)
        loci = unifint(diff_lb, diff_ub, (3, h - objh))
        locj = unifint(diff_lb, diff_ub, (0, w - objw))
        loc = (loci, locj)
        bgc, fgc, destc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        obj = shift(obj, loc)
        gi = fill(gi, fgc, obj)
        sqd = randint(1, min(w, loci - 1))
        locisq = randint(0, loci-sqd-1)
        locjsq = randint(locj-sqd+1, locj+objw-1)
        locsq = (locisq, locjsq)
        sq = backdrop({(locisq, locjsq), (locisq+sqd-1, locjsq+sqd-1)})
        gi = fill(gi, destc, sq)
        go = fill(go, destc, sq)
        while len(obj & sq) == 0:
            obj = shift(obj, (-1, 0))
        obj = shift(obj, (1, 0))
        go = fill(go, fgc, obj)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_928ad970(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        ih = unifint(diff_lb, diff_ub, (9, h))
        iw = unifint(diff_lb, diff_ub, (9, w))
        bgc, linc, dotc = sample(cols, 3)
        loci = randint(0, h - ih)
        locj = randint(0, w - iw)
        ulc = (loci, locj)
        lrc = (loci + ih - 1, locj + iw - 1)
        dot1 = choice(totuple(connect(ulc, (loci + ih - 1, locj)) - {ulc, (loci + ih - 1, locj)}))
        dot2 = choice(totuple(connect(ulc, (loci, locj + iw - 1)) - {ulc, (loci, locj + iw - 1)}))
        dot3 = choice(totuple(connect(lrc, (loci + ih - 1, locj)) - {lrc, (loci + ih - 1, locj)}))
        dot4 = choice(totuple(connect(lrc, (loci, locj + iw - 1)) - {lrc, (loci, locj + iw - 1)}))
        a, b = sorted(sample(interval(loci + 2, loci + ih - 2, 1), 2))
        while a + 1 == b:
            a, b = sorted(sample(interval(loci + 2, loci + ih - 2, 1), 2))
        c, d = sorted(sample(interval(locj + 2, locj + iw - 2, 1), 2))
        while c + 1 == d:
            c, d = sorted(sample(interval(locj + 2, locj + iw - 2, 1), 2))
        sp = box(frozenset({(a, c), (b, d)}))
        bx = {dot1, dot2, dot3, dot4}
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        gi = fill(gi, dotc, bx)
        gi = fill(gi, linc, sp)
        go = fill(gi, linc, inbox(bx))
        return {'input': gi, 'output': go}

    def generate_f8b3ba0a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 5))
        w = unifint(diff_lb, diff_ub, (1, 5))
        nh = unifint(diff_lb, diff_ub, (3, 29 // (h + 1)))
        nw = unifint(diff_lb, diff_ub, (3, 29 // (w + 1)))
        fullh = (h + 1) * nh + 1
        fullw = (w + 1) * nw + 1
        fullbgc, bgc = sample(cols, 2)
        remcols = remove(fullbgc, remove(bgc, cols))
        shp = shift(asindices(canvas(-1, (h, w))), (1, 1))
        gi = canvas(fullbgc, (fullh, fullw))
        locs = set()
        for a in range(nh):
            for b in range(nw):
                loc = (a * (h + 1), b * (w + 1))
                locs.add(loc)
                gi = fill(gi, bgc, shift(shp, loc))
        numc = unifint(diff_lb, diff_ub, (1, (nh * nw) // 2 - 1))
        stack = []
        nn = numc + 1
        ncols = 0
        while nn > 1 and numc > 0 and len(remcols) > 0:
            nn3 = int(0.5 * (8 * numc + 1) ** 0.5 - 1)
            nn = min(max(1, nn3), nn - 1)
            col = choice(remcols)
            remcols = remove(col, remcols)
            numc -= nn
            stack.append((col, nn))
        go = dmirror((tuple(c for c, nn in stack),))
        for col, nn in stack:
            slocs = sample(totuple(locs), nn)
            gi = fill(gi, col, mapply(lbind(shift, shp), slocs))
            locs = locs - set(slocs)
        return {'input': gi, 'output': go}

    def generate_fcb5c309(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc, dotc, sqc = sample(cols, 3)
        numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 25))
        gi = canvas(bgc, (h, w))
        inds = asindices(gi)
        maxtr = 4 * numsq
        tr = 0
        succ = 0
        numcells = None
        take = False
        while tr < maxtr and succ < numsq:
            oh = randint(3, 7)
            ow = randint(3, 7)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            loci, locj = loc
            sq = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            bd = backdrop(sq)
            if bd.issubset(inds):
                gi = fill(gi, sqc, sq)
                ib = backdrop(inbox(sq))
                if numcells is None:
                    numcells = unifint(diff_lb, diff_ub, (1, len(ib)))
                    cells = sample(totuple(ib), numcells)
                    take = True
                else:
                    nc = unifint(diff_lb, diff_ub, (0, min(max(0, numcells - 1), len(ib))))
                    cells = sample(totuple(ib), nc)
                gi = fill(gi, dotc, cells)
                if take:
                    go = replace(subgrid(sq, gi), sqc, dotc)
                    take = False
                inds = (inds - bd) - outbox(bd)
                succ += 1
            tr += 1
        nnoise = unifint(diff_lb, diff_ub, (0, max(0, len(inds) // 2 - 1)))
        noise = sample(totuple(inds), nnoise)
        gi = fill(gi, dotc, noise)
        return {'input': gi, 'output': go}

    def generate_54d9e175(diff_lb: float, diff_ub: float) -> dict:
        cols = (0, 5)
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        nh = unifint(diff_lb, diff_ub, (1, 31 // (h + 1)))
        nw = unifint(diff_lb, diff_ub, (1 if nh > 1 else 2, 31 // (w + 1)))
        fullh = (h + 1) * nh - 1
        fullw = (w + 1) * nw - 1
        linc, bgc = sample(cols, 2)
        gi = canvas(linc, (fullh, fullw))
        go = canvas(linc, (fullh, fullw))
        obj = asindices(canvas(bgc, (h, w)))
        for a in range(nh):
            for b in range(nw):
                plcd = shift(obj, (a * (h + 1), b * (w + 1)))
                icol = randint(1, 4)
                ocol = icol + 5
                gi = fill(gi, bgc, plcd)
                go = fill(go, ocol, plcd)
                dot = choice(totuple(plcd))
                gi = fill(gi, icol, {dot})
        return {'input': gi, 'output': go}

    def generate_7f4411dc(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc, fgc = sample(cols, 2)
        nsq = unifint(diff_lb, diff_ub, (1, (h * w) // 15))
        maxtr = 4 * nsq
        tr = 0
        succ = 0
        go = canvas(bgc, (h, w))
        inds = asindices(go)
        while tr < maxtr and succ < nsq:
            oh = randint(2, 6)
            ow = randint(2, 6)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            loci, locj = loc
            obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            obj = shift(obj, loc)
            if obj.issubset(inds):
                go = fill(go, fgc, obj)
                succ += 1
                inds = (inds - obj) - outbox(obj)
            tr += 1
        inds = ofcolor(go, bgc)
        nnoise = unifint(diff_lb, diff_ub, (0, len(inds) // 2 - 1))
        gi = tuple(e for e in go)
        for k in range(nnoise):
            loc = choice(totuple(inds))
            inds = inds - dneighbors(loc)
            gi = fill(gi, fgc, {loc})
        return {'input': gi, 'output': go}

    def generate_67385a82(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(0, remove(8, interval(0, 10, 1)))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        col = choice(cols)
        gi = canvas(0, (h, w))
        inds = totuple(asindices(gi))
        ncd = unifint(diff_lb, diff_ub, (0, len(inds) // 2))
        nc = choice((ncd, len(inds) - ncd))
        nc = min(max(1, nc), len(inds) - 1)
        locs = sample(inds, nc)
        gi = fill(gi, col, locs)
        objs = objects(gi, T, F, F)
        rems = toindices(merge(sizefilter(colorfilter(objs, col), 1)))
        blues = difference(ofcolor(gi, col), rems)
        go = fill(gi, 8, blues)
        return {'input': gi, 'output': go}

    def generate_d6ad076f(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        inh = unifint(diff_lb, diff_ub, (3, h))
        inw = unifint(diff_lb, diff_ub, (3, w))
        bgc, c1, c2 = sample(cols, 3)
        itv = interval(0, inh, 1)
        loci2i = unifint(diff_lb, diff_ub, (2, inh - 1))
        loci2 = itv[loci2i]
        itv = itv[:loci2i-1][::-1]
        loci1i = unifint(diff_lb, diff_ub, (0, len(itv) - 1))
        loci1 = itv[loci1i]
        cp = randint(1, inw - 2)
        ajs = randint(0, cp - 1)
        aje = randint(cp + 1, inw - 1)
        bjs = randint(0, cp - 1)
        bje = randint(cp + 1, inw - 1)
        obja = backdrop(frozenset({(0, ajs), (loci1, aje)}))
        objb = backdrop(frozenset({(loci2, bjs), (inh - 1, bje)}))
        c = canvas(bgc, (inh, inw))
        c = fill(c, c1, obja)
        c = fill(c, c2, objb)
        obj = asobject(c)
        loci = randint(0, h - inh)
        locj = randint(0, w - inw)
        loc = (loci, locj)
        obj = shift(obj, loc)
        gi = canvas(bgc, (h, w))
        gi = paint(gi, obj)
        midobj = backdrop(frozenset({(loci1 + 1, max(ajs, bjs) + 1), (loci2 - 1, min(aje, bje) - 1)}))
        go = fill(gi, 8, shift(midobj, loc))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_e48d4e1a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        loci = randint(1, h - 2)
        locj = randint(1, w - 2)
        inds = asindices(canvas(-1, (loci, locj)))
        maxn = min(min(h - loci - 1, w - locj - 1), len(inds))
        nn = unifint(diff_lb, diff_ub, (1, maxn))
        ss = sample(totuple(inds), nn)
        bgc, fgc, dotc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        gi = fill(gi, fgc, hfrontier((loci, 0)) | vfrontier((0, locj)))
        gi = fill(gi, dotc, ss)
        go = fill(go, fgc, hfrontier((loci + nn, 0)) | vfrontier((0, locj + nn)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_a48eeaf7(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        ih = unifint(diff_lb, diff_ub, (2, h//2))
        iw = unifint(diff_lb, diff_ub, (2, w//2))
        loci = randint(2, h - ih - 2)
        locj = randint(2, w - iw - 2)
        bgc, sqc, dotc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        sq = backdrop(frozenset({(loci, locj), (loci + ih - 1, locj + iw - 1)}))
        A = [(x, locj - 1) for x in interval(loci, loci + ih, 1)]
        Ap = [(x, randint(0, locj - 2)) for x in interval(loci, loci + ih, 1)]
        B = [(x, locj + iw) for x in interval(loci, loci + ih, 1)]
        Bp = [(x, randint(locj + iw + 1, w - 1)) for x in interval(loci, loci + ih, 1)]
        C = [(loci - 1, x) for x in interval(locj, locj + iw, 1)]
        Cp = [(randint(0, loci - 2), x) for x in interval(locj, locj + iw, 1)]
        D = [(loci + ih, x) for x in interval(locj, locj + iw, 1)]
        Dp = [(randint(loci + ih + 1, h - 1), x) for x in interval(locj, locj + iw, 1)]
        srarr = Ap + Bp + Cp + Dp
        dearr = A + B + C + D
        inds = interval(0, len(srarr), 1)
        num = unifint(diff_lb, diff_ub, (1, len(srarr)))
        locs = sample(inds, num)
        srarr = [e for j, e in enumerate(srarr) if j in locs]
        dearr = [e for j, e in enumerate(dearr) if j in locs]
        gi = fill(gi, sqc, sq)
        go = fill(go, sqc, sq)
        for s, d in zip(srarr, dearr):
            gi = fill(gi, dotc, {s})
            go = fill(go, dotc, {d})
        ncorn = unifint(diff_lb, diff_ub, (0, 4))
        fullinds = asindices(gi)
        if ncorn > 0:
            go = fill(go, dotc, {(loci - 1, locj - 1)})
            cands = shoot((loci - 2, locj - 2), (-1, -1)) & fullinds
            locc = choice(totuple(cands))
            gi = fill(gi, dotc, {locc})
        if ncorn > 1:
            go = fill(go, dotc, {(loci - 1, locj + iw)})
            cands = shoot((loci - 2, locj + iw + 1), (-1, 1)) & fullinds
            locc = choice(totuple(cands))
            gi = fill(gi, dotc, {locc})
        if ncorn > 2:
            go = fill(go, dotc, {(loci + ih, locj - 1)})
            cands = shoot((loci + ih + 1, locj - 2), (1, -1)) & fullinds
            locc = choice(totuple(cands))
            gi = fill(gi, dotc, {locc})
        if ncorn > 3:
            go = fill(go, dotc, {(loci + ih, locj + iw)})
            cands = shoot((loci + ih + 1, locj + iw + 1), (1, 1)) & fullinds
            locc = choice(totuple(cands))
            gi = fill(gi, dotc, {locc})
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_56dc2b01(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 8))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        oh = unifint(diff_lb, diff_ub, (1, h))
        ow = unifint(diff_lb, diff_ub, (1, (w - 1) // 2 - 1))
        bb = asindices(canvas(-1, (oh, ow)))
        sp = choice(totuple(bb))
        obj = {sp}
        bb = remove(sp, bb)
        ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))
        ncells = choice((ncellsd, oh * ow - ncellsd))
        ncells = min(max(0, ncells), oh * ow - 1)
        for k in range(ncells):
            obj.add(choice(totuple((bb - obj) & mapply(neighbors, obj))))
        obj = normalize(obj)
        oh, ow = shape(obj)
        loci = randint(0, h - oh)
        locj = unifint(diff_lb, diff_ub, (1, w - ow))
        bgc, objc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        barlocji = unifint(diff_lb, diff_ub, (0, locj))
        barlocj = locj - barlocji
        barlocj = min(max(0, barlocj), locj - 1)
        gi = fill(gi, 2, connect((0, barlocj), (h - 1, barlocj)))
        go = fill(gi, objc, shift(obj, (loci, barlocj + 1)))
        go = fill(go, 8, connect((0, barlocj + ow + 1), (h - 1, barlocj + ow + 1)))
        gi = fill(gi, objc, shift(obj, (loci, locj)))
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_1caeab9d(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1,))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        oh = unifint(diff_lb, diff_ub, (1, h//2))
        ow = unifint(diff_lb, diff_ub, (1, w//3))
        bb = asindices(canvas(-1, (oh, ow)))
        sp = choice(totuple(bb))
        obj = {sp}
        bb = remove(sp, bb)
        ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))
        ncells = choice((ncellsd, oh * ow - ncellsd))
        ncells = min(max(0, ncells), oh * ow - 1)
        for k in range(ncells):
            obj.add(choice(totuple((bb - obj) & mapply(neighbors, obj))))
        obj = normalize(obj)
        oh, ow = shape(obj)
        loci = randint(0, h - oh)
        numo = unifint(diff_lb, diff_ub, (2, min(8, w // ow))) - 1
        itv = interval(0, w, 1)
        locj = randint(0, w - ow)
        objp = shift(obj, (loci, locj))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        c = canvas(bgc, (h, w))
        gi = fill(c, 1, objp)
        go = fill(c, 1, objp)
        itv = difference(itv, interval(locj, locj + ow, 1))
        for k in range(numo):
            cands = sfilter(itv, lambda j: set(interval(j, j + ow, 1)).issubset(set(itv)))
            if len(cands) == 0:
                break
            locj = choice(cands)
            col = choice(remcols)
            remcols = remove(col, remcols)
            gi = fill(gi, col, shift(obj, (randint(0, h - oh), locj)))
            go = fill(go, col, shift(obj, (loci, locj)))
            itv = difference(itv, interval(locj, locj + ow, 1))
        return {'input': gi, 'output': go}

    def generate_b91ae062(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        numc = unifint(diff_lb, diff_ub, (3, min(h * w, min(10, 30 // max(h, w)))))
        ccols = sample(cols, numc)
        c = canvas(-1, (h, w))
        inds = totuple(asindices(c))
        fixinds = sample(inds, numc)
        obj = {(cc, ij) for cc, ij in zip(ccols, fixinds)}
        for ij in difference(inds, fixinds):
            obj.add((choice(ccols), ij))
        gi = paint(c, obj)
        go = upscale(gi, numc - 1)
        return {'input': gi, 'output': go}

    def generate_834ec97d(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        loci = unifint(diff_lb, diff_ub, (0, h - 2))
        locjd = unifint(diff_lb, diff_ub, (0, w // 2))
        locj = choice((locjd, w - locjd))
        locj = min(max(0, locj), w - 1)
        loc = (loci, locj)
        bgc, fgc = sample(cols, 2)
        c = canvas(bgc, (h, w))
        gi = fill(c, fgc, {loc})
        go = fill(c, fgc, {add(loc, (1, 0))})
        for jj in range(w//2 + 1):
            go = fill(go, 4, connect((0, locj + 2 * jj), (loci, locj + 2 * jj)))
            go = fill(go, 4, connect((0, locj - 2 * jj), (loci, locj - 2 * jj)))
        return {'input': gi, 'output': go}

    def generate_a699fb00(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        numls = unifint(diff_lb, diff_ub, (1, h - 1))
        opts = interval(0, h, 1)
        locs = sample(opts, numls)
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        for ii in locs:
            endidx = unifint(diff_lb, diff_ub, (2, w - 2))
            ofs = unifint(diff_lb, diff_ub, (1, endidx//2)) * 2
            ofs = min(max(2, ofs), endidx)
            startidx = endidx - ofs
            ln = connect((ii, startidx), (ii, endidx))
            go = fill(go, 2, ln)
            sparseln = {(ii, jj) for jj in range(startidx, endidx + 1, 2)}
            go = fill(go, fgc, sparseln)
            gi = fill(gi, fgc, sparseln)
        return {'input': gi, 'output': go}

    def generate_91413438(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        maxnb = min(h * w - 1, min(30//h, 30//w))
        minnb = int(0.5 * ((4 * h * w + 1) ** 0.5 - 1)) + 1
        nbi = unifint(diff_lb, diff_ub, (0, maxnb - minnb))
        nb = min(max(minnb, maxnb - nbi), maxnb)
        fgc = choice(cols)
        c = canvas(0, (h, w))
        obj = sample(totuple(asindices(c)), h * w - nb)
        gi = fill(c, fgc, obj)
        go = canvas(0, (h * nb, w * nb))
        for j in range(h * w - nb):
            loc = (j // nb, j % nb)
            go = fill(go, fgc, shift(obj, multiply((h, w), loc)))
        return {'input': gi, 'output': go}

    def generate_99fa7670(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        num = unifint(diff_lb, diff_ub, (1, h // 2))
        inds = interval(0, h, 1)
        starts = sorted(sample(inds, num))
        ends = [x - 1 for x in starts[1:]] + [h - 1]
        nc = unifint(diff_lb, diff_ub, (1, 9))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ccols = sample(remcols, nc)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        for s, e in zip(starts, ends):
            col = choice(ccols)
            locj = randint(0, w - 2)
            l1 = connect((s, locj), (s, w - 1))
            l2 = connect((s, w - 1), (e, w - 1))
            gi = fill(gi, col, {(s, locj)})
            go = fill(go, col, l1 | l2)
        return {'input': gi, 'output': go}

    def generate_d13f3404(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 15))
        w = unifint(diff_lb, diff_ub, (3, 15))
        vopts = {(ii, 0) for ii in interval(0, h, 1)}
        hopts = {(0, jj) for jj in interval(1, w, 1)}
        opts = tuple(vopts | hopts)
        num = unifint(diff_lb, diff_ub, (1, len(opts)))
        locs = sample(opts, num)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h*2, w*2))
        inds = asindices(gi)
        for loc in locs:
            ln = tuple(shoot(loc, (1, 1)) & inds)
            locc = choice(ln)
            col = choice(remcols)
            gi = fill(gi, col, {locc})
            go = fill(go, col, shoot(locc, (1, 1)))
        return {'input': gi, 'output': go}

    def generate_c3f564a4(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (7, 30))
        p = unifint(diff_lb, diff_ub, (2, min(9, min(h//3, w//3))))
        fixc = choice(cols)
        remcols = remove(fixc, cols)
        ccols = list(sample(remcols, p))
        shuffle(ccols)
        c = canvas(-1, (h, w))
        baseobj = {(cc, (0, jj)) for cc, jj in zip(ccols, range(p))}
        obj = {c for c in baseobj}
        while rightmost(obj) < 2 * max(w, h):
            obj = obj | shift(obj, (0, p))
        if choice((True, False)):
            obj = mapply(lbind(shift, obj), {(jj, 0) for jj in interval(0, h, 1)})
        else:
            obj = mapply(lbind(shift, obj), {(jj, -jj) for jj in interval(0, h, 1)})
        go = paint(c, obj)
        gi = tuple(e for e in go)
        nsq = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 25)))
        maxtr = 4 * nsq
        tr = 0
        succ = 0
        while succ < nsq and tr < maxtr:
            oh = unifint(diff_lb, diff_ub, (2, 5))
            ow = unifint(diff_lb, diff_ub, (2, 5))
            loci = randint(0, h - oh)
            locj = randint(0, w - ow)
            tmpg = fill(gi, fixc, backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)})))
            if len(occurrences(tmpg, baseobj)) > 1 and len([r for r in tmpg if fixc not in r]) > 0 and len([r for r in dmirror(tmpg) if fixc not in r]) > 0:
                gi = tmpg
                succ += 1
            tr += 1
        if choice((True, False)):
            gi = rot90(gi)
            go = rot90(go)
        return {'input': gi, 'output': go}

    def generate_ecdecbb3(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc, dotc, linc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        nl = unifint(diff_lb, diff_ub, (1, h//4))
        inds = interval(0, h, 1)
        locs = []
        for k in range(nl):
            if len(inds) == 0:
                break
            idx = choice(inds)
            locs.append(idx)
            inds = remove(idx, inds)
            inds = remove(idx - 1, inds)
            inds = remove(idx + 1, inds)
            inds = remove(idx - 2, inds)
            inds = remove(idx + 2, inds)
        locs = sorted(locs)
        for ii in locs:
            gi = fill(gi, linc, hfrontier((ii, 0)))
        iopts = difference(difference(difference(interval(0, h, 1), locs), apply(increment, locs)), apply(decrement, locs))
        jopts = interval(0, w, 1)
        ndots = unifint(diff_lb, diff_ub, (1, min(len(iopts), w // 2)))
        dlocs = []
        for k in range(ndots):
            if len(iopts) == 0 or len(jopts) == 0:
                break
            loci = choice(iopts)
            locj = choice(jopts)
            dlocs.append((loci, locj))
            jopts = remove(locj, jopts)
            jopts = remove(locj+1, jopts)
            jopts = remove(locj-1, jopts)
        go = gi
        for d in dlocs:
            loci, locj = d
            if loci < min(locs):
                go = fill(go, dotc, connect(d, (min(locs), locj)))
                go = fill(go, linc, neighbors((min(locs), locj)))
            elif loci > max(locs):
                go = fill(go, dotc, connect(d, (max(locs), locj)))
                go = fill(go, linc, neighbors((max(locs), locj)))
            else:
                sp = [e for e in locs if e < loci][-1]
                ep = [e for e in locs if e > loci][0]
                go = fill(go, dotc, connect((sp, locj), (ep, locj)))
                go = fill(go, linc, neighbors((sp, locj)))
                go = fill(go, linc, neighbors((ep, locj)))
            gi = fill(gi, dotc, {d})
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_ac0a08a4(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        num = unifint(diff_lb, diff_ub, (1, min(min(9, h * w - 2), min(30//h, 30//w))))
        bgc = choice(cols)
        c = canvas(bgc, (h, w))
        inds = asindices(c)
        locs = sample(totuple(inds), num)
        remcols = remove(bgc, cols)
        obj = {(col, loc) for col, loc in zip(sample(remcols, num), locs)}
        gi = paint(c, obj)
        go = upscale(gi, num)
        return {'input': gi, 'output': go}

    def generate_22168020(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        num = unifint(diff_lb, diff_ub, (1, min(9, (h * w) // 10)))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        succ = 0
        tr = 0
        maxtr = 6 * num
        inds = asindices(gi)
        while tr < maxtr and succ < num:
            d = unifint(diff_lb, diff_ub, (2, 5))
            oh = d + 1
            ow = 2 * d
            if len(inds) == 0:
                tr += 1
                continue
            loc = choice(totuple(inds))
            loci, locj = loc
            io1 = connect(loc, (loci + d - 1, locj + d - 1))
            io2 = connect((loci, locj + ow - 1), (loci + d - 1, locj + d))
            io = io1 | io2 | {(loci + d, locj + d - 1), (loci + d, locj + d)}
            oo = merge(sfilter(prapply(connect, io, io), hline))
            mf = choice((identity, dmirror, cmirror, hmirror, vmirror))
            io = mf(io)
            oo = mf(oo)
            col = choice(remcols)
            if oo.issubset(inds):
                gi = fill(gi, col, io)
                go = fill(go, col, oo)
                succ += 1
                inds = inds - oo
                remcols = remove(col, remcols)
            tr += 1
        return {'input': gi, 'output': go}

    def generate_ff805c23(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 15))
        w = h
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        remcols = sample(remcols, numcols)
        canv = canvas(bgc, (h, w))
        nc = unifint(diff_lb, diff_ub, (1, h * w))
        bx = asindices(canv)
        obj = {(choice(remcols), choice(totuple(bx)))}
        for kk in range(nc - 1):
            dns = mapply(neighbors, toindices(obj))
            ch = choice(totuple(bx & dns))
            obj.add((choice(remcols), ch))
            bx = bx - {ch}
        gi = paint(canv, obj)
        tr = sfilter(asobject(dmirror(gi)), lambda cij: cij[1][1] >= cij[1][0])
        gi = paint(gi, tr)
        gi = hconcat(gi, vmirror(gi))
        gi = vconcat(gi, hmirror(gi))
        locidev = unifint(diff_lb, diff_ub, (1, 2*h))
        locjdev = unifint(diff_lb, diff_ub, (1, w))
        loci = 2*h - locidev
        locj = w - locjdev
        loci2 = unifint(diff_lb, diff_ub, (loci, 2*h - 1))
        locj2 = unifint(diff_lb, diff_ub, (locj, w - 1))
        bd = backdrop(frozenset({(loci, locj), (loci2, locj2)}))
        go = subgrid(bd, gi)
        gi = fill(gi, 0, bd)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_4093f84a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (7, 30))
        loci1, loci2 = sorted(sample(interval(2, h - 2, 1), 2))
        bgc, barc, dotc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        for ii in range(loci1, loci2+1, 1):
            gi = fill(gi, barc, connect((ii, 0), (ii, w - 1)))
        go = tuple(e for e in gi)
        opts = interval(0, w, 1)
        num1 = unifint(diff_lb, diff_ub, (1, w // 2))
        num2 = unifint(diff_lb, diff_ub, (1, w // 2))
        locs1 = sample(opts, num1)
        locs2 = sample(opts, num2)
        for l1 in locs1:
            k = unifint(diff_lb, diff_ub, (1, loci1 - 1))
            locsx = sample(interval(0, loci1, 1), k)
            gi = fill(gi, dotc, apply(rbind(astuple, l1), locsx))
            go = fill(go, barc, connect((loci1 - 1, l1), (loci1 - k, l1)))
        for l2 in locs2:
            k = unifint(diff_lb, diff_ub, (1, h - loci2 - 2))
            locsx = sample(interval(loci2+1, h, 1), k)
            gi = fill(gi, dotc, apply(rbind(astuple, l2), locsx))
            go = fill(go, barc, connect((loci2 + 1, l2), (loci2 + k, l2)))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_760b3cac(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        objL = frozenset({(0, 0), (1, 0), (1, 1), (1, 2), (2, 1)})
        objR = vmirror(objL)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (3, 14))
        w = 2 * w + 1
        bgc, objc, indc = sample(cols, 3)
        objh = unifint(diff_lb, diff_ub, (1, h - 3))
        objw = unifint(diff_lb, diff_ub, (1, w // 6))
        objw = 2 * objw + 1
        c = canvas(-1, (objh, objw))
        gi = canvas(bgc, (h, w))
        if choice((True, False)):
            obj = objL
            sgn = -1
        else:
            obj = objR
            sgn = 1
        gi = fill(gi, indc, shift(obj, (h - 3, w//2 - 1)))
        inds = asindices(c)
        sp = choice(totuple(inds))
        objx = {sp}
        numcd = unifint(diff_lb, diff_ub, (0, (objh * objw) // 2))
        numc = choice((numcd, objh * objw - numcd))
        numc = min(max(1, numc), objh * objw)
        for k in range(numc - 1):
            objx.add(choice(totuple((inds - objx) & mapply(neighbors, objx))))
        while width(objx) != objw:
            objx.add(choice(totuple((inds - objx) & mapply(neighbors, objx))))
        objx = normalize(objx)
        objh, objw = shape(objx)
        loci = randint(0, h - 3 - objh)
        locj = w//2 - objw//2
        loc = (loci, locj)
        plcd = shift(objx, loc)
        gi = fill(gi, objc, plcd)
        objx2 = vmirror(plcd)
        plcd2 = shift(objx2, (0, objw * sgn))
        go = fill(gi, objc, plcd2)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_8efcae92(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc, sqc, dotc = sample(cols, 3)
        num = unifint(diff_lb, diff_ub, (1, (h * w) // 25))
        succ = 0
        maxtr = 4 * num
        tr = 0
        gi = canvas(bgc, (h, w))
        go = None
        inds = asindices(gi)
        oho, owo = None, None
        while succ < num and tr < maxtr:
            if oho is None and owo is None:
                oh = randint(2, h - 1)
                ow = randint(2, w - 1)
                oho = oh
                owo = ow
            else:
                ohd = unifint(diff_lb, diff_ub, (0, min(oho, h - 1 - oho)))
                owd = unifint(diff_lb, diff_ub, (0, min(owo, w - 1 - owo)))
                ohd = min(oho, h - 1 - oho) - ohd
                owd = min(owo, w - 1 - owo) - owd
                oh = choice((oho - ohd, oho + ohd))
                ow = choice((owo - owd, owo + owd))
                oh = min(max(2, oh), h - 1)
                ow = min(max(2, ow), w - 1)
            minig = canvas(sqc, (oh, ow))
            mini = asindices(minig)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            tr += 1
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            if not shift(mini, loc).issubset(inds):
                continue
            succ += 1
            if go is None:
                numdots = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2 - 1))
                nd = numdots
            else:
                nd = unifint(diff_lb, diff_ub, (0, min((oh * ow) // 2 - 1, numdots - 1)))
            locs = sample(totuple(mini), nd)
            minig = fill(minig, dotc, locs)
            if go is None:
                go = minig
            obj = asobject(minig)
            plcd = shift(obj, loc)
            gi = paint(gi, plcd)
            inds = (inds - toindices(plcd)) - mapply(dneighbors, toindices(plcd))
        return {'input': gi, 'output': go}

    def generate_48d8fb45(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 15))
        tr = 0
        maxtr = 4 * nobjs
        done = False
        succ = 0
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        inds = asindices(gi)
        while tr < maxtr and succ < nobjs:
            oh = randint(2, 6)
            ow = randint(2, 6)
            bx = asindices(canvas(-1, (oh, ow)))
            nc = randint(3, oh * ow)
            sp = choice(totuple(bx))
            bx = remove(sp, bx)
            obj = {sp}
            for k in range(nc - 1):
                obj.add(choice(totuple((bx - obj) & mapply(neighbors, obj))))
            if not done:
                done = True
                idx = choice(totuple(obj))
                coll = choice(remcols)
                obj2 = {(coll, idx)}
                obj3 = recolor(choice(remove(coll, remcols)), remove(idx, obj))
                obj = obj2 | obj3
                go = paint(canvas(bgc, shape(obj3)), normalize(obj3))
            else:
                obj = recolor(choice(remcols), obj)
            locopts = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            tr += 1
            if len(locopts) == 0:
                continue
            loc = choice(totuple(locopts))
            plcd = shift(obj, loc)
            plcdi = toindices(plcd)
            if plcdi.issubset(inds):
                gi = paint(gi, plcd)
                succ += 1
                inds = (inds - plcdi) - mapply(neighbors, plcdi)
        return {'input': gi, 'output': go}

    def generate_8e1813be(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        bgc, sqc = sample(cols, 2)
        remcols = remove(bgc, remove(sqc, cols))
        nbars = unifint(diff_lb, diff_ub, (3, 8))
        ccols = sample(remcols, nbars)
        w = unifint(diff_lb, diff_ub, (nbars+3, 30))
        hmarg = unifint(diff_lb, diff_ub, (2 * nbars, 30 - nbars))
        ccols = list(ccols)
        go = tuple(repeat(col, nbars) for col in ccols)
        gi = tuple(repeat(col, w) for col in ccols)
        r = repeat(bgc, w)
        for k in range(hmarg):
            idx = randint(0, len(go) - 1)
            gi = gi[:idx] + (r,) + gi[idx:]
        h2 = nbars + hmarg
        oh, ow = nbars, nbars
        loci = randint(1, h2 - oh - 2)
        locj = randint(1, w - ow - 2)
        sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
        gi = fill(gi, sqc, sq)
        gi = fill(gi, bgc, outbox(sq))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_5117e062(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 15))
        tr = 0
        maxtr = 4 * nobjs
        done = False
        succ = 0
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        inds = asindices(gi)
        while tr < maxtr and succ < nobjs:
            oh = randint(2, 6)
            ow = randint(2, 6)
            bx = asindices(canvas(-1, (oh, ow)))
            nc = randint(3, oh * ow)
            sp = choice(totuple(bx))
            bx = remove(sp, bx)
            obj = {sp}
            for k in range(nc - 1):
                obj.add(choice(totuple((bx - obj) & mapply(neighbors, obj))))
            if not done:
                done = True
                idx = choice(totuple(obj))
                coll = choice(remcols)
                obj2 = {(coll, idx)}
                coll2 = choice(remove(coll, remcols))
                obj3 = recolor(coll2, remove(idx, obj))
                obj = obj2 | obj3
                go = fill(canvas(bgc, shape(obj)), coll2, normalize(obj))
            else:
                obj = recolor(choice(remcols), obj)
            locopts = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            tr += 1
            if len(locopts) == 0:
                continue
            loc = choice(totuple(locopts))
            plcd = shift(obj, loc)
            plcdi = toindices(plcd)
            if plcdi.issubset(inds):
                gi = paint(gi, plcd)
                succ += 1
                inds = (inds - plcdi) - mapply(neighbors, plcdi)
        return {'input': gi, 'output': go}

    def generate_f15e1fac(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        nsps = unifint(diff_lb, diff_ub, (1, (w-1) // 2))
        ngps = unifint(diff_lb, diff_ub, (1, (h-1) // 2))
        spsj = sorted(sample(interval(1, w - 1, 1), nsps))
        gpsi = sorted(sample(interval(1, h - 1, 1), ngps))
        ofs = 0
        bgc, linc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        gi = fill(gi, linc, {(0, jj) for jj in spsj})
        gi = fill(gi, 2, {(ii, 0) for ii in gpsi})
        go = tuple(e for e in gi)
        for a, b in zip([0] + gpsi, [x - 1 for x in gpsi] + [h - 1]):
            for jj in spsj:
                go = fill(go, linc, connect((a, jj + ofs), (b, jj + ofs)))
            ofs += 1
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_3906de3d(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        oh = unifint(diff_lb, diff_ub, (2, h // 2))
        ow = unifint(diff_lb, diff_ub, (3, w - 2))
        bgc, boxc, linc = sample(cols, 3)
        locj = randint(1, w - ow - 1)
        bx = backdrop(frozenset({(0, locj), (oh - 1, locj + ow - 1)}))
        gi = canvas(bgc, (h, w))
        gi = fill(gi, boxc, bx)
        rng = range(locj, locj + ow)
        cutoffs = [randint(1, oh - 1) for j in rng]
        for jj, co in zip(rng, cutoffs):
            gi = fill(gi, bgc, connect((co, jj), (oh - 1, jj)))
        numlns = unifint(diff_lb, diff_ub, (1, ow - 1))
        lnlocs = sample(list(rng), numlns)
        go = tuple(e for e in gi)
        for jj, co in zip(rng, cutoffs):
            if jj in lnlocs:
                lineh = randint(1, h - co - 1)
                linei = connect((h - lineh, jj), (h - 1, jj))
                lineo = connect((co, jj), (co + lineh - 1, jj))
                gi = fill(gi, linc, linei)
                go = fill(go, linc, lineo)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_77fdfe62(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 13))
        w = unifint(diff_lb, diff_ub, (1, 13))
        c1, c2, c3, c4, barc, bgc, inc = sample(cols, 7)
        qd = canvas(bgc, (h, w))
        inds = totuple(asindices(qd))
        fullh = 2 * h + 4
        fullw = 2 * w + 4
        n1 = unifint(diff_lb, diff_ub, (1, h * w))
        n2 = unifint(diff_lb, diff_ub, (1, h * w))
        n3 = unifint(diff_lb, diff_ub, (1, h * w))
        n4 = unifint(diff_lb, diff_ub, (1, h * w))
        i1 = sample(inds, n1)
        i2 = sample(inds, n2)
        i3 = sample(inds, n3)
        i4 = sample(inds, n4)
        gi = canvas(bgc, (2 * h + 4, 2 * w + 4))
        gi = fill(gi, barc, connect((1, 0), (1, fullw - 1)))
        gi = fill(gi, barc, connect((fullh - 2, 0), (fullh - 2, fullw - 1)))
        gi = fill(gi, barc, connect((0, 1), (fullh - 1, 1)))
        gi = fill(gi, barc, connect((0, fullw - 2), (fullh - 1, fullw - 2)))
        gi = fill(gi, c1, {(0, 0)})
        gi = fill(gi, c2, {(0, fullw - 1)})
        gi = fill(gi, c3, {(fullh - 1, 0)})
        gi = fill(gi, c4, {(fullh - 1, fullw - 1)})
        gi = fill(gi, inc, shift(i1, (2, 2)))
        gi = fill(gi, inc, shift(i2, (2, 2+w)))
        gi = fill(gi, inc, shift(i3, (2+h, 2)))
        gi = fill(gi, inc, shift(i4, (2+h, 2+w)))
        go = canvas(bgc, (2 * h, 2 * w))
        go = fill(go, c1, shift(i1, (0, 0)))
        go = fill(go, c2, shift(i2, (0, w)))
        go = fill(go, c3, shift(i3, (h, 0)))
        go = fill(go, c4, shift(i4, (h, w)))
        return {'input': gi, 'output': go}

    def generate_d406998b(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        bgc, dotc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        itv = interval(0, h, 1)
        for j in range(w):
            nilocs = unifint(diff_lb, diff_ub, (1, h // 2 - 1 if h % 2 == 0 else h // 2))
            ilocs = sample(itv, nilocs)
            locs = {(ii, j) for ii in ilocs}
            gi = fill(gi, dotc, locs)
            go = fill(go, dotc if (j - w) % 2 == 0 else 3, locs)
        return {'input': gi, 'output': go}

    def generate_694f12f3(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2))
        h = unifint(diff_lb, diff_ub, (9, 30))
        w = unifint(diff_lb, diff_ub, (9, 30))
        seploc = randint(4, h - 5)
        bigh = unifint(diff_lb, diff_ub, (4, seploc))
        bigw = unifint(diff_lb, diff_ub, (3, w - 1))
        bigloci = randint(0, seploc - bigh)
        biglocj = randint(0, w - bigw)
        smallmaxh = h - seploc - 1
        smallmaxw = w - 1
        cands = []
        bigsize = bigh * bigw
        for a in range(3, smallmaxh+1):
            for b in range(3, smallmaxw+1):
                if a * b < bigsize:
                    cands.append((a, b))
        cands = sorted(cands, key=lambda ab: ab[0]*ab[1])
        num = len(cands)
        idx = unifint(diff_lb, diff_ub, (0, num - 1))
        smallh, smallw = cands[idx]
        smallloci = randint(seploc+1, h - smallh)
        smalllocj = randint(0, w - smallw)
        bgc, sqc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        bigsq = backdrop(frozenset({(bigloci, biglocj), (bigloci + bigh - 1, biglocj + bigw - 1)}))
        smallsq = backdrop(frozenset({(smallloci, smalllocj), (smallloci + smallh - 1, smalllocj + smallw - 1)}))
        gi = fill(gi, sqc, bigsq | smallsq)
        go = fill(gi, 2, backdrop(inbox(bigsq)))
        go = fill(go, 1, backdrop(inbox(smallsq)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_3befdf3e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, numcols)
        nobjs = unifint(diff_lb, diff_ub, (1, ((h * w) // 40)))
        succ = 0
        maxtr = 5 * nobjs
        tr = 0
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while succ < nobjs and tr < maxtr:
            tr += 1
            if len(inds) == 0:
                break
            rh = choice((1, 2))
            rw = choice((1, 2))
            fullh = (2 + 3 * rh)
            fullw = (2 + 3 * rw)
            cands = sfilter(inds, lambda ij: ij[0] <= h - fullh and ij[1] <= w - fullw)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            fullobj = backdrop(frozenset({loc, (loci + fullh - 1, locj + fullw - 1)}))
            if fullobj.issubset(inds):
                succ += 1
                inds = inds - fullobj
                incol, outcol = sample(ccols, 2)
                ofincol = backdrop(frozenset({(loci + rh + 1, locj + rw + 1), (loci + 2 * rh, locj + 2 * rw)}))
                ofoutcol = outbox(ofincol)
                gi = fill(gi, incol, ofincol)
                gi = fill(gi, outcol, ofoutcol)
                go = fill(go, outcol, ofincol)
                go = fill(go, incol, ofoutcol)
                ilocs = apply(first, ofoutcol)
                jlocs = apply(last, ofoutcol)
                ff = lambda ij: ij[0] in ilocs or ij[1] in jlocs
                addon = sfilter(fullobj - (ofincol | ofoutcol), ff)
                go = fill(go, outcol, addon)
        return {'input': gi, 'output': go}

    def generate_9f236235(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        numh = unifint(diff_lb, diff_ub, (2, 14))
        numw = unifint(diff_lb, diff_ub, (2, 14))
        h = unifint(diff_lb, diff_ub, (1, 31 // numh - 1))
        w = unifint(diff_lb, diff_ub, (1, 31 // numw - 1))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        frontcol = choice(remcols)
        remcols = remove(frontcol, cols)
        numcols = unifint(diff_lb, diff_ub, (1, min(9, numh * numw)))
        ccols = sample(remcols, numcols)
        numcells = unifint(diff_lb, diff_ub, (1, numh * numw))
        cands = asindices(canvas(-1, (numh, numw)))
        inds = asindices(canvas(-1, (h, w)))
        locs = sample(totuple(cands), numcells)
        gi = canvas(frontcol, (h * numh + numh - 1, w * numw + numw - 1))
        go = canvas(bgc, (numh, numw))
        for cand in cands:
            a, b = cand
            plcd = shift(inds, (a * (h + 1), b * (w + 1)))
            col = choice(remcols) if cand in locs else bgc
            gi = fill(gi, col, plcd)
            go = fill(go, col, {cand})
        go = vmirror(go)
        return {'input': gi, 'output': go}

    def generate_d8c310e9(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        p = unifint(diff_lb, diff_ub, (2, (w - 1) // 3))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, numc)
        obj = set()
        for j in range(p):
            numcells = unifint(diff_lb, diff_ub, (1, h - 1))
            for ii in range(h - 1, h - numcells - 1, -1):
                loc = (ii, j)
                col = choice(ccols)
                cell = (col, loc)
                obj.add(cell)
        gi = canvas(bgc, (h, w))
        minobj = obj | shift(obj, (0, p))
        addonw = randint(0, p)
        addon = sfilter(obj, lambda cij: cij[1][1] < addonw)
        fullobj = minobj | addon
        leftshift = randint(0, addonw)
        fullobj = shift(fullobj, (0, -leftshift))
        gi = paint(gi, fullobj)
        go = tuple(e for e in gi)
        for j in range(w//(2*p)+2):
            go = paint(go, shift(fullobj, (0, j * 2 * p)))
        mfs = (identity, rot90, rot180, rot270)
        fn = choice(mfs)
        gi = fn(gi)
        go = fn(go)
        return {'input': gi, 'output': go}

    def generate_7e0986d6(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        nsqcols = unifint(diff_lb, diff_ub, (1, 5))
        sqcols = sample(remcols, nsqcols)
        remcols = difference(remcols, sqcols)
        nnoisecols = unifint(diff_lb, diff_ub, (1, len(remcols)))
        noisecols = sample(remcols, nnoisecols)
        numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 25))
        succ = 0
        tr = 0
        maxtr = 5 * numsq
        go = canvas(bgc, (h, w))
        inds = asindices(go)
        while tr < maxtr and succ < numsq:
            tr += 1
            oh = randint(2, 7)
            ow = randint(2, 7)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            if sq.issubset(inds):
                succ += 1
                inds = (inds - sq) - outbox(sq)
                col = choice(sqcols)
                go = fill(go, col, sq)
        gi = tuple(e for e in go)
        namt = unifint(diff_lb, diff_ub, (1, (h * w) // 9))
        cands = asindices(gi)
        for k in range(namt):
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            col = gi[loc[0]][loc[1]]
            torem = neighbors(loc) & ofcolor(gi, col)
            cands = cands - torem
            noisec = choice(noisecols)
            gi = fill(gi, noisec, {loc})
        return {'input': gi, 'output': go}

    def generate_a64e4611(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (18, 30))
        w = unifint(diff_lb, diff_ub, (18, 30))
        bgc, noisec = sample(cols, 2)
        lb = int(0.4 * h * w)
        ub = int(0.5 * h * w)
        nbgc = unifint(diff_lb, diff_ub, (lb, ub))
        gi = canvas(noisec, (h, w))
        inds = totuple(asindices(gi))
        bgcinds = sample(inds, nbgc)
        gi = fill(gi, bgc, bgcinds)
        sinds = asindices(canvas(-1, (3, 3)))
        bgcf = recolor(bgc, sinds)
        noisecf = recolor(noisec, sinds)
        addn = set()
        addb = set()
        for occ in occurrences(gi, bgcf):
            occi, occj = occ
            addn.add((randint(0, 2) + occi, randint(0, 2) + occj))
        for occ in occurrences(gi, noisecf):
            occi, occj = occ
            addb.add((randint(0, 2) + occi, randint(0, 2) + occj))
        gi = fill(gi, noisec, addn)
        gi = fill(gi, bgc, addb)
        go = tuple(e for e in gi)
        dim = randint(randint(3, 8), 8)
        locj = randint(3, h - dim - 4)
        spi = choice((0, randint(3, h//2)))
        for j in range(locj, locj + dim):
            ln = connect((spi, j), (h - 1, j))
            gi = fill(gi, bgc, ln)
            go = fill(go, bgc, ln)
        for j in range(locj + 1, locj + dim - 1):
            ln = connect((spi + 1 if spi > 0 else spi, j), (h - 1, j))
            go = fill(go, 3, ln)
        sgns = choice(((-1,), (1,), (-1, 1)))
        startloc = choice((spi, randint(spi + 3, h - 6)))
        hh = randint(3, min(8, h - startloc - 3))
        for sgn in sgns:
            for ii in range(startloc, startloc + hh, 1):
                ln = shoot((ii, locj), (0, sgn))
                gi = fill(gi, bgc, ln)
                go = fill(go, bgc, ln - ofcolor(go, 3))
        for sgn in sgns:
            for ii in range(startloc+1 if startloc > 0 else startloc, startloc + hh - 1, 1):
                ln = shoot((ii, locj+dim-2 if sgn == -1 else locj+1), (0, sgn))
                go = fill(go, 3, ln)
        if len(sgns) == 1 and unifint(diff_lb, diff_ub, (0, 1)) == 1:
            sgns = (-sgns[0],)
            startloc = choice((spi, randint(spi + 3, h - 6)))
            hh = randint(3, min(8, h - startloc - 3))
            for sgn in sgns:
                for ii in range(startloc, startloc + hh, 1):
                    ln = shoot((ii, locj), (0, sgn))
                    gi = fill(gi, bgc, ln)
                    go = fill(go, bgc, ln - ofcolor(go, 3))
            for sgn in sgns:
                for ii in range(startloc+1 if startloc > 0 else startloc, startloc + hh - 1, 1):
                    ln = shoot((ii, locj+dim-2 if sgn == -1 else locj+1), (0, sgn))
                    go = fill(go, 3, ln)
        return {'input': gi, 'output': go}

    def generate_b782dc8a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        wall_pairs = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}
        dlt = [('W', (-1, 0)), ('E', (1, 0)), ('S', (0, 1)), ('N', (0, -1))]
        walls = {'N': True, 'S': True, 'E': True, 'W': True}
        fullsucc = False
        while True:
            h = unifint(diff_lb, diff_ub, (3, 15))
            w = unifint(diff_lb, diff_ub, (3, 15))
            maze = [[{'x': x, 'y': y, 'walls': {**walls}} for y in range(h)] for x in range(w)]
            kk = h * w
            stck = []
            cc = maze[0][0]
            nv = 1
            while nv < kk:
                nbhs = []
                for direc, (dx, dy) in dlt:
                    x2, y2 = cc['x'] + dx, cc['y'] + dy
                    if 0 <= x2 < w and 0 <= y2 < h:
                        neighbour = maze[x2][y2]
                        if all(neighbour['walls'].values()):
                            nbhs.append((direc, neighbour))
                if not nbhs:
                    cc = stck.pop()
                    continue
                direc, next_cell = choice(nbhs)
                cc['walls'][direc] = False
                next_cell['walls'][wall_pairs[direc]] = False
                stck.append(cc)
                cc = next_cell
                nv += 1
            pathcol, wallcol, dotcol, ncol = sample(cols, 4)
            grid = [[pathcol for x in range(w * 2)]]
            for y in range(h):
                row = [pathcol]
                for x in range(w):
                    row.append(wallcol)
                    row.append(pathcol if maze[x][y]['walls']['E'] else wallcol)
                grid.append(row)
                row = [pathcol]
                for x in range(w):
                    row.append(pathcol if maze[x][y]['walls']['S'] else wallcol)
                    row.append(pathcol)
                grid.append(row)
            gi = tuple(tuple(r[1:-1]) for r in grid[1:-1])
            objs = objects(gi, T, F, F)
            objs = colorfilter(objs, pathcol)
            objs = sfilter(objs, lambda obj: size(obj) > 4)
            if len(objs) == 0:
                continue
            objs = order(objs, size)
            nobjs = len(objs)
            idx = unifint(diff_lb, diff_ub, (0, nobjs - 1))
            obj = toindices(objs[idx])
            cell = choice(totuple(obj))
            gi = fill(gi, dotcol, {cell})
            nbhs = dneighbors(cell) & ofcolor(gi, pathcol)
            gi = fill(gi, ncol, nbhs)
            obj1 = sfilter(obj, lambda ij: even(manhattan({ij}, {cell})))
            obj2 = obj - obj1
            go = fill(gi, dotcol, obj1)
            go = fill(go, ncol, obj2)
            break
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_af902bf9(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numcols)
        numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 20))
        succ = 0
        maxtr = 5 * numsq
        tr = 0
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while tr < maxtr and succ < numsq:
            tr += 1
            oh = randint(3, 5)
            ow = randint(3, 5)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            if sq.issubset(inds):
                inds = inds - sq
                succ += 1
                col = choice(ccols)
                crns = corners(sq)
                gi = fill(gi, col, crns)
                go = fill(go, col, crns)
                ins = backdrop(inbox(crns))
                go = fill(go, 2, ins)
        return {'input': gi, 'output': go}

    def generate_a87f7484(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 30))
        num = unifint(diff_lb, diff_ub, (3, min(30 // h, 9)))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ccols = sample(remcols, num)
        ncd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        nc = choice((ncd, h * w - ncd))
        nc = min(max(1, nc), h * w - 1)
        c = canvas(bgc, (h, w))
        inds = asindices(c)
        origlocs = sample(totuple(inds), nc)
        canbrem = {l for l in origlocs}
        canbeadd = inds - set(origlocs)
        otherlocs = {l for l in origlocs}
        nchangesinv = unifint(diff_lb, diff_ub, (0, h * w - 1))
        nchanges = h * w - nchangesinv
        for k in range(nchanges):
            if choice((True, False)):
                if len(canbrem) > 1:
                    ch = choice(totuple(canbrem))
                    otherlocs = remove(ch, otherlocs)
                    canbrem = remove(ch, canbrem)
                elif len(canbeadd) > 1:
                    ch = choice(totuple(canbeadd))
                    otherlocs = insert(ch, otherlocs)
                    canbeadd = remove(ch, canbeadd)
            else:
                if len(canbeadd) > 1:
                    ch = choice(totuple(canbeadd))
                    otherlocs = insert(ch, otherlocs)
                    canbeadd = remove(ch, canbeadd)
                elif len(canbrem) > 1:
                    ch = choice(totuple(canbrem))
                    otherlocs = remove(ch, otherlocs)
                    canbrem = remove(ch, canbrem)
        go = fill(c, ccols[0], origlocs)
        grids = [go]
        for cc in ccols[1:]:
            grids.append(fill(c, cc, otherlocs))
        shuffle(grids)
        grids = tuple(grids)
        gi = merge(grids)
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_fcc82909(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (7, 30))
        nobjs = unifint(diff_lb, diff_ub, (1, w // 3))
        opts = interval(0, w, 1)
        tr = 0
        maxtr = 4 * nobjs
        succ = 0
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        while succ < nobjs and tr < maxtr:
            tr += 1
            sopts = sfilter(opts, lambda j: set(interval(j, j + 2, 1)).issubset(opts))
            if len(sopts) == 0:
                break
            numc = unifint(diff_lb, diff_ub, (1, 4))
            jstart = choice(sopts)
            opts = remove(jstart, opts)
            opts = remove(jstart+1, opts)
            options = interval(0, h - 2 - numc + 1, 1)
            if len(options) == 0:
                break
            iloc = choice(options)
            ccols = sample(remcols, numc)
            bd = backdrop(frozenset({(iloc, jstart), (iloc + 1, jstart + 1)}))
            bd = list(bd)
            shuffle(bd)
            obj = {(c, ij) for c, ij in zip(ccols, bd[:numc])} | {(choice(ccols), ij) for ij in bd[numc:]}
            if not mapply(dneighbors, toindices(obj)).issubset(ofcolor(gi, bgc)):
                continue
            gi = paint(gi, obj)
            go = paint(go, obj)
            for k in range(numc):
                go = fill(go, 3, {(iloc+k+2, jstart), (iloc+k+2, jstart+1)})
        return {'input': gi, 'output': go}

    def generate_d9fac9be(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        bgc, noisec, ringc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        nnoise1 = unifint(diff_lb, diff_ub, (1, (h * w) // 3 - 1))
        nnoise2 = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 3 - 9)))
        inds = asindices(gi)
        noise1 = sample(totuple(inds), nnoise1)
        noise2 = sample(difference(totuple(inds), noise1), nnoise2)
        gi = fill(gi, noisec, noise1)
        gi = fill(gi, ringc, noise2)
        rng = neighbors((1, 1))
        fp1 = recolor(noisec, rng)
        fp2 = recolor(ringc, rng)
        fp1occ = occurrences(gi, fp1)
        fp2occ = occurrences(gi, fp2)
        for occ1 in fp1occ:
            loc = choice(totuple(shift(rng, occ1)))
            gi = fill(gi, choice((bgc, ringc)), {loc})
        for occ2 in fp2occ:
            loc = choice(totuple(shift(rng, occ2)))
            gi = fill(gi, choice((bgc, noisec)), {loc})
        loci = randint(0, h - 3)
        locj = randint(0, w - 3)
        ringp = shift(rng, (loci, locj))
        gi = fill(gi, ringc, ringp)
        gi = fill(gi, noisec, {(loci + 1, locj + 1)})
        go = canvas(noisec, (1, 1))
        return {'input': gi, 'output': go}

    def generate_eb281b96(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 8))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, numc)
        c = canvas(bgc, (h, w))
        inds = asindices(c)
        ncells = unifint(diff_lb, diff_ub, (1, h * w))
        locs = sample(totuple(inds), ncells)
        obj = {(choice(ccols), ij) for ij in locs}
        gi = paint(c, obj)
        go = vconcat(gi, hmirror(gi[:-1]))
        go = vconcat(go, hmirror(go[:-1]))
        return {'input': gi, 'output': go}

    def generate_d43fd935(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        boxh = unifint(diff_lb, diff_ub, (2, h // 2))
        boxw = unifint(diff_lb, diff_ub, (2, w // 2))
        loci = randint(0, h - boxh)
        locj = randint(0, w - boxw)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ccol = choice(remcols)
        remcols = remove(ccol, remcols)
        ndcols = unifint(diff_lb, diff_ub, (1, 8))
        dcols = sample(remcols, ndcols)
        bd = backdrop(frozenset({(loci, locj), (loci + boxh - 1, locj + boxw - 1)}))
        gi = canvas(bgc, (h, w))
        gi = fill(gi, ccol, bd)
        reminds = totuple(asindices(gi) - bd)
        noiseb = max(1, len(reminds) // 4)
        nnoise = unifint(diff_lb, diff_ub, (0, noiseb))
        noise = sample(reminds, nnoise)
        truenoise = sfilter(noise, lambda ij: (ij[0] < loci or ij[0] > loci + boxh - 1) and (ij[1] < locj or ij[1] > locj + boxw - 1))
        rem = difference(noise, truenoise)
        top = sfilter(rem, lambda ij: ij[0] < loci)
        bottom = sfilter(rem, lambda ij: ij[0] > loci + boxh - 1)
        left = sfilter(rem, lambda ij: ij[1] < locj)
        right = sfilter(rem, lambda ij: ij[1] > locj + boxw - 1)
        truenoiseobj = {(choice(dcols), ij) for ij in truenoise}
        gi = paint(gi, truenoiseobj)
        go = tuple(e for e in gi)
        for jj in apply(last, top):
            col = choice(dcols)
            mf = matcher(last, jj)
            subs = sfilter(top, mf)
            gi = fill(gi, col, subs)
            go = fill(go, col, connect((valmin(subs, first), jj), (loci - 1, jj)))
        for jj in apply(last, bottom):
            col = choice(dcols)
            mf = matcher(last, jj)
            subs = sfilter(bottom, mf)
            gi = fill(gi, col, subs)
            go = fill(go, col, connect((valmax(subs, first), jj), (loci + boxh, jj)))
        for ii in apply(first, left):
            col = choice(dcols)
            mf = matcher(first, ii)
            subs = sfilter(left, mf)
            gi = fill(gi, col, subs)
            go = fill(go, col, connect((ii, valmin(subs, last)), (ii, locj - 1)))
        for ii in apply(first, right):
            col = choice(dcols)
            mf = matcher(first, ii)
            subs = sfilter(right, mf)
            gi = fill(gi, col, subs)
            go = fill(go, col, connect((ii, valmax(subs, last)), (ii, locj + boxw)))
        return {'input': gi, 'output': go}

    def generate_44f52bb0(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, ncols)
        gi = canvas(bgc, (h, w))
        numcells = unifint(diff_lb, diff_ub, (1, h * w - 1))
        inds = asindices(gi)
        while gi == hmirror(gi):
            cells = sample(totuple(inds), numcells)
            gi = canvas(bgc, (h, w))
            for ij in cells:
                a, b = ij
                col = choice(ccols)
                gi = fill(gi, col, {ij})
                gi = fill(gi, col, {(a, w - 1 - b)})
        issymm = choice((True, False))
        if not issymm:
            numpert = unifint(diff_lb, diff_ub, (1, h * (w // 2)))
            cands = asindices(canvas(-1, (h, w // 2)))
            locs = sample(totuple(cands), numpert)
            for a, b in locs:
                col = gi[a][b]
                newcol = choice(totuple(remove(col, insert(bgc, set(ccols)))))
                gi = fill(gi, newcol, {(a, b)})
            go = canvas(7, (1, 1))
        else:
            go = canvas(1, (1, 1))
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_d22278a0(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)    
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        crns = corners(inds)
        ncorns = unifint(diff_lb, diff_ub, (1, 4))
        crns = sample(totuple(crns), ncorns)
        ccols = sample(remcols, ncorns)
        for col, crn in zip(ccols, crns):
            gi = fill(gi, col, {crn})
            go = fill(go, col, {crn})
            rings = {crn}
            for k in range(1, max(h, w) // 2 + 2, 1):
                rings = rings | outbox(outbox(rings))
            if len(crns) > 1:
                ff = lambda ij: manhattan({ij}, {crn}) < min(apply(rbind(manhattan, {ij}), apply(initset, remove(crn, crns))))
            else:
                ff = lambda ij: True
            locs = sfilter(inds, ff) & rings
            go = fill(go, col, locs)
        return {'input': gi, 'output': go}

    def generate_272f95fa(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 3, 4, 6))    
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc, linc = sample(cols, 2)
        c = canvas(bgc, (5, 5))
        l1 = connect((1, 0), (1, 4))
        l2 = connect((3, 0), (3, 4))
        lns = l1 | l2
        gi = fill(dmirror(fill(c, linc, lns)), linc, lns)
        hdist = [0, 0, 0]
        wdist = [0, 0, 0]
        idx = 0
        for k in range(h - 2):
            hdist[idx] += 1
            idx = (idx + 1) % 3
        for k in range(w - 2):
            wdist[idx] += 1
            idx = (idx + 1) % 3
        shuffle(hdist)
        shuffle(wdist)
        hdelt1 = unifint(diff_lb, diff_ub, (0, hdist[0] - 1))
        hdist[0] -= hdelt1
        hdist[1] += hdelt1
        hdelt2 = unifint(diff_lb, diff_ub, (0, min(hdist[1], hdist[2]) - 1))
        hdelt2 = choice((+hdelt2, -hdelt2))
        hdist[1] += hdelt2
        hdist[2] -= hdelt2
        wdelt1 = unifint(diff_lb, diff_ub, (0, wdist[0] - 1))
        wdist[0] -= wdelt1
        wdist[1] += wdelt1
        wdelt2 = unifint(diff_lb, diff_ub, (0, min(wdist[1], wdist[2]) - 1))
        wdelt2 = choice((+wdelt2, -wdelt2))
        wdist[1] += wdelt2
        wdist[2] -= wdelt2
        gi = gi[:1] * hdist[0] + gi[1:2] + gi[2:3] * hdist[1] + gi[3:4] + gi[4:5] * hdist[2]
        gi = dmirror(gi)
        gi = gi[:1] * wdist[0] + gi[1:2] + gi[2:3] * wdist[1] + gi[3:4] + gi[4:5] * wdist[2]
        gi = dmirror(gi)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
        objs = objects(gi, T, T, F)
        bgobjs = colorfilter(objs, bgc)
        cnrs = corners(asindices(gi))
        bgobjs = sfilter(bgobjs, lambda o: len(toindices(o) & cnrs) == 0)
        pinkobj = extract(bgobjs, lambda o: not bordering(o, gi))
        yellobj = argmin(bgobjs, leftmost)
        greenobj = argmax(bgobjs, rightmost)
        redobj = argmin(bgobjs, uppermost)
        blueobj = argmax(bgobjs, lowermost)
        go = fill(gi, 6, pinkobj)
        go = fill(go, 4, yellobj)
        go = fill(go, 3, greenobj)
        go = fill(go, 2, redobj)
        go = fill(go, 1, blueobj)
        return {'input': gi, 'output': go}

    def generate_5c0a986e(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2))    
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 10))
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        tr = 0
        maxtr = 5 * nobjs
        succ = 0
        inds = asindices(gi)
        fullinds = asindices(gi)
        while succ < nobjs and tr < maxtr:
            tr += 1
            cands = sfilter(inds, lambda ij: 0 < ij[0] <= h - 3 and 0 < ij[1] <= w - 3)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            col = choice((1, 2))
            sq = {(loc), add(loc, (0, 1)), add(loc, (1, 0)), add(loc, (1, 1))}
            if col == 1:
                obj = sq | (shoot(loc, (-1, -1)) & fullinds)
            else:
                obj = sq | (shoot(loc, (1, 1)) & fullinds)
            if obj.issubset(inds):
                succ += 1
                inds = (inds - obj) - mapply(dneighbors, sq)
                gi = fill(gi, col, sq)
                go = fill(go, col, obj)
        return {'input': gi, 'output': go}

    def generate_9af7a82c(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        prods = dict()
        for a in range(1, 31, 1):
            for b in range(1, 31, 1):
                prd = a*b
                if prd in prods:
                    prods[prd].append((a, b))
                else:
                    prods[prd] = [(a, b)]
        ncols = unifint(diff_lb, diff_ub, (2, 9))
        leastnc = sum(range(1, ncols + 1, 1))
        maxnc = sum(range(30, 30 - ncols, -1))
        cands = {k: v for k, v in prods.items() if leastnc <= k <= maxnc}
        options = set()
        for v in cands.values():
            for opt in v:
                options.add(opt)
        options = sorted(options, key=lambda ij: ij[0] * ij[1])
        idx = unifint(diff_lb, diff_ub, (0, len(options) - 1))
        h, w = options[idx]
        ccols = sample(cols, ncols)
        counts = list(range(1, ncols + 1, 1))
        eliginds = {ncols - 1}
        while sum(counts) < h * w:
            eligindss = sorted(eliginds, reverse=True)
            idx = unifint(diff_lb, diff_ub, (0, len(eligindss) - 1))
            idx = eligindss[idx]
            counts[idx] += 1
            if idx > 0:
                eliginds.add(idx - 1)
            if idx < ncols - 1:
                if counts[idx] == counts[idx+1] - 1:
                    eliginds = eliginds - {idx}
            if counts[idx] == 30:
                eliginds = eliginds - {idx}
        gi = canvas(-1, (h, w))
        go = canvas(0, (max(counts), ncols))
        inds = asindices(gi)
        counts = counts[::-1]
        for j, (col, cnt) in enumerate(zip(ccols, counts)):
            locs = sample(totuple(inds), cnt)
            gi = fill(gi, col, locs)
            inds = inds - set(locs)
            go = fill(go, col, connect((0, j), (cnt - 1, j)))
        return {'input': gi, 'output': go}

    def generate_d4469b4b(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 3))
        canv = canvas(5, (3, 3))
        A = fill(canv, 0, {(1, 0), (2, 0), (1, 2), (2, 2)})
        B = fill(canv, 0, corners(asindices(canv)))
        C = fill(canv, 0, {(0, 0), (0, 1), (1, 0), (1, 1)})
        colabc = ((2, A), (1, B), (3, C))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        col, go = choice(colabc)
        gi = canvas(col, (h, w))
        inds = asindices(gi)
        numc = unifint(diff_lb, diff_ub, (1, 7))
        ccols = sample(cols, numc)
        numcells = unifint(diff_lb, diff_ub, (0, h * w - 1))
        locs = sample(totuple(inds), numcells)
        otherobj = {(choice(ccols), ij) for ij in locs}
        gi = paint(gi, otherobj)
        return {'input': gi, 'output': go}

    def generate_bdad9b1f(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        numh = unifint(diff_lb, diff_ub, (1, h // 2 - 1))
        numw = unifint(diff_lb, diff_ub, (1, w // 2 - 1))
        hlocs = sample(interval(2, h - 1, 1), numh)
        wlocs = sample(interval(2, w - 1, 1), numw)
        numcols = unifint(diff_lb, diff_ub, (2, 8))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ccols = sample(remcols, numcols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        fc = -1
        for ii in sorted(hlocs):
            col = choice(remove(fc, ccols))
            fc = col
            objw = randint(2, ii)
            gi = fill(gi, col, connect((ii, 0), (ii, objw - 1)))
            go = fill(go, col, connect((ii, 0), (ii, w - 1)))
        fc = -1
        for jj in sorted(wlocs):
            col = choice(remove(fc, ccols))
            fc = col
            objh = randint(2, jj)
            gi = fill(gi, col, connect((0, jj), (objh - 1, jj)))
            go = fill(go, col, connect((0, jj), (h - 1, jj)))
        yells = product(set(hlocs), set(wlocs))
        go = fill(go, 4, yells)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_3345333e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        oh = unifint(diff_lb, diff_ub, (4, h - 2))
        ow = unifint(diff_lb, diff_ub, (4, (w - 2) // 2))
        nc = unifint(diff_lb, diff_ub, (min(oh, ow), (oh * ow) // 3 * 2))
        shp = {(0, 0)}
        bounds = asindices(canvas(-1, (oh, ow)))
        for j in range(nc):
            ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))
            shp.add(ij)
        while height(shp) < 3 or width(shp) < 3:
            ij = choice(totuple((bounds - shp) & mapply(neighbors, shp)))
            shp.add(ij)
        vmshp = vmirror(shp)
        if choice((True, False)):
            vmshp = sfilter(vmshp, lambda ij: ij[1] != width(shp) - 1)
        shp = normalize(combine(shp, shift(vmshp, (0, -width(vmshp)))))
        oh, ow = shape(shp)
        bgc, objc, occcol = sample(cols, 3)
        loci = randint(1, h - oh - 1)
        locj = randint(1, w - ow - 1)
        loc = (loci, locj)
        shp = shift(shp, loc)
        c = canvas(bgc, (h, w))
        go = fill(c, objc, shp)
        boxh = unifint(diff_lb, diff_ub, (2, oh - 1))
        boxw = unifint(diff_lb, diff_ub, (2, ow//2))
        ulci = randint(loci - 1, loci + oh - boxh + 1)
        ulcj = randint(locj + ow//2 + 1, locj + ow - boxw + 1)
        bx = backdrop(frozenset({(ulci, ulcj), (ulci + boxh - 1, ulcj + boxw - 1)}))
        gi = fill(go, occcol, bx)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_253bf280(diff_lb: float, diff_ub: float) -> dict:
        dim_bounds = (3, 30)
        colopts = remove(3, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, dim_bounds)
        w = unifint(diff_lb, diff_ub, dim_bounds)
        bgc = choice(colopts)
        c = canvas(bgc, (h, w))
        inds = totuple(asindices(c))
        card_bounds = (0, max(1, (h * w) // 4))
        num = unifint(diff_lb, diff_ub, card_bounds)
        s = sample(inds, num)
        fgcol = choice(remove(bgc, colopts))
        gi = fill(c, fgcol, s)
        resh = frozenset()
        for x, r in enumerate(gi):
            if r.count(fgcol) > 1:
                resh = combine(resh, connect((x, r.index(fgcol)), (x, -1 + w - r[::-1].index(fgcol))))
        go = fill(c, 3, resh)
        resv = frozenset()
        for x, r in enumerate(dmirror(gi)):
            if r.count(fgcol) > 1:
                resv = combine(resv, connect((x, r.index(fgcol)), (x, -1 + h - r[::-1].index(fgcol))))
        go = dmirror(fill(dmirror(go), 3, resv))
        go = fill(go, fgcol, s)
        return {'input': gi, 'output': go}

    def generate_5582e5ca(diff_lb: float, diff_ub: float) -> dict:
        colopts = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        numc = unifint(diff_lb, diff_ub, (2, min(10, h * w - 1)))
        ccols = sample(colopts, numc)
        mostc = ccols[0]
        remcols = ccols[1:]
        leastnummostcol = (h * w) // numc + 1
        maxnummostcol = h * w - numc + 1
        nummostcold = unifint(diff_lb, diff_ub, (0, maxnummostcol - leastnummostcol))
        nummostcol = min(max(leastnummostcol, maxnummostcol - nummostcold), maxnummostcol)
        kk = len(remcols)
        remcount = h * w - nummostcol - kk
        remcounts = [1 for k in range(kk)]
        for j in range(remcount):
            cands = [idx for idx, c in enumerate(remcounts) if c < nummostcol - 1]
            if len(cands) == 0:
                break
            idx = choice(cands)
            remcounts[idx] += 1
        nummostcol = h * w - sum(remcounts)
        gi = canvas(-1, (h, w))
        inds = asindices(gi)
        mclocs = sample(totuple(inds), nummostcol)
        gi = fill(gi, mostc, mclocs)
        go = canvas(mostc, (h, w))
        inds = inds - set(mclocs)
        for col, count in zip(remcols, remcounts):
            locs = sample(totuple(inds), count)
            inds = inds - set(locs)
            gi = fill(gi, col, locs)
        return {'input': gi, 'output': go}

    def generate_a1570a43(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        oh = unifint(diff_lb, diff_ub, (3, h))
        ow = unifint(diff_lb, diff_ub, (3, w))
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        crns = {(loci, locj), (loci + oh - 1, locj), (loci, locj + ow - 1), (loci + oh - 1, locj + ow - 1)}
        cands = shift(asindices(canvas(-1, (oh-2, ow-2))), (loci+1, locj+1))
        bgc, dotc = sample(cols, 2)
        remcols = remove(bgc, remove(dotc, cols))
        numc = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numc)
        gipro = canvas(bgc, (h, w))
        gipro = fill(gipro, dotc, crns)
        sp = choice(totuple(cands))
        obj = {sp}
        cands = remove(sp, cands)
        ncells = unifint(diff_lb, diff_ub, (oh + ow - 5, max(oh + ow - 5, ((oh - 2) * (ow - 2)) // 2)))
        for k in range(ncells - 1):
            obj.add(choice(totuple((cands - obj) & mapply(neighbors, obj))))
        while shape(obj) != (oh-2, ow-2):
            obj.add(choice(totuple((cands - obj) & mapply(neighbors, obj))))
        obj = {(choice(ccols), ij) for ij in obj}
        go = paint(gipro, obj)
        nperts = unifint(diff_lb, diff_ub, (1, max(h, w)))
        k = 0
        fullinds = asindices(go)
        while ulcorner(obj) == (loci+1, locj+1) or k < nperts:
            k += 1
            options = sfilter(
                neighbors((0, 0)),
                lambda ij: len(crns & shift(toindices(obj), ij)) == 0 and \
                    shift(toindices(obj), ij).issubset(fullinds)
            )
            direc = choice(totuple(options))
            obj = shift(obj, direc)
        gi = paint(gipro, obj)
        return {'input': gi, 'output': go}

    def generate_f5b8619d(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 15))
        w = unifint(diff_lb, diff_ub, (2, 15))
        ncells = unifint(diff_lb, diff_ub, (1, (h * w) // 2 - 1))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        inds = asindices(gi)
        locs = sample(totuple(inds), ncells)
        blockcol = randint(0, w - 1)
        locs = sfilter(locs, lambda ij: ij[1] != blockcol)
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numcols)
        obj = frozenset({(choice(ccols), ij) for ij in locs})
        gi = paint(gi, obj)
        go = fill(gi, 8, mapply(vfrontier, set(locs)) & (inds - set(locs)))
        go = hconcat(go, go)
        go = vconcat(go, go)
        return {'input': gi, 'output': go}

    def generate_444801d8(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 25))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, numcols)
        succ = 0
        tr = 0
        maxtr = 5 * nobjs
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while succ < nobjs and tr < maxtr:
            tr += 1
            oh = randint(4, 6)
            ow = 5
            bx = box({(1, 0), (oh - 1, 4)}) - {(1, 2)}
            fullobj = backdrop({(0, 0), (oh - 1, 4)})
            cands = backdrop(bx) - bx
            dot = choice(totuple(cands))
            dcol, bxcol = sample(ccols, 2)
            inobj = recolor(bxcol, bx) | recolor(dcol, {dot})
            outobj = recolor(bxcol, bx) | recolor(dcol, fullobj - bx)
            if choice((True, False)):
                inobj = shift(hmirror(inobj), UP)
                outobj = hmirror(outobj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            outplcd = shift(outobj, loc)
            outplcdi = toindices(outplcd)
            if outplcdi.issubset(inds):
                succ += 1
                inplcd = shift(inobj, loc)
                inds = (inds - outplcdi) - outbox(inplcd)
                gi = paint(gi, inplcd)
                go = paint(go, outplcd)
        return {'input': gi, 'output': go}

    def generate_00d62c1b(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        nblocks = unifint(diff_lb, diff_ub, (1, (h * w) // 20))
        succ = 0
        tr = 0
        maxtr = 5 * nblocks
        inds = asindices(gi)
        while succ < nblocks and tr < maxtr:
            tr += 1
            oh = randint(3, 8)
            ow = randint(3, 8)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            bx = bx - set(sample(totuple(corners(bx)), randint(0, 4)))
            if bx.issubset(inds) and len(inds - bx) > (h * w) // 2 + 1:
                gi = fill(gi, fgc, bx)
                succ += 1
                inds = inds - bx
        maxnnoise = max(0, (h * w) // 2 - 1 - colorcount(gi, fgc))
        namt = unifint(diff_lb, diff_ub, (0, maxnnoise))
        noise = sample(totuple(inds), namt)
        gi = fill(gi, fgc, noise)
        objs = objects(gi, T, F, F)
        cands = colorfilter(objs, bgc)
        res = mfilter(cands, compose(flip, rbind(bordering, gi)))
        go = fill(gi, 4, res)
        return {'input': gi, 'output': go}

    def generate_10fcaaa3(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (2, 15))
        w = unifint(diff_lb, diff_ub, (2, 15))
        ncells = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 6)))
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ccols = sample(remcols, ncols)
        c = canvas(bgc, (h, w))
        inds = asindices(c)
        locs = frozenset(sample(totuple(inds), ncells))
        obj = frozenset({(choice(ccols), ij) for ij in locs})
        gi = paint(c, obj)
        go = hconcat(gi, gi)
        go = vconcat(go, go)
        fullocs = locs | shift(locs, (0, w)) | shift(locs, (h, 0)) | shift(locs, (h, w))
        nbhs = mapply(ineighbors, fullocs)
        topaint = nbhs & ofcolor(go, bgc)
        go = fill(go, 8, topaint)
        return {'input': gi, 'output': go}

    def generate_1a07d186(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        nlines = unifint(diff_lb, diff_ub, (1, w // 5))
        linecols = sample(remcols, nlines)
        remcols = difference(remcols, linecols)
        nnoisecols = unifint(diff_lb, diff_ub, (0, len(remcols)))
        noisecols = sample(remcols, nnoisecols)
        locopts = interval(0, w, 1)
        locs = []
        for k in range(nlines):
            if len(locopts) == 0:
                break
            loc = choice(locopts)
            locopts = difference(locopts, interval(loc - 2, loc + 3, 1))
            locs.append(loc)
        locs = sorted(locs)
        nlines = len(locs)
        linecols = linecols[:nlines]
        gi = canvas(bgc, (h, w))
        for loc, col in zip(locs, linecols):
            gi = fill(gi, col, connect((0, loc), (h - 1, loc)))
        go = tuple(e for e in gi)
        nilocs = unifint(diff_lb, diff_ub, (1, h))
        ilocs = sample(interval(0, h, 1), nilocs)
        dotlocopts = difference(interval(0, w, 1), locs)
        for ii in ilocs:
            ndots = unifint(diff_lb, diff_ub, (1, min(nlines + nnoisecols, (w - nlines) // 2 - 1)))
            dotlocs = sample(dotlocopts, ndots)
            dotcols = sample(totuple(set(linecols) | set(noisecols)), ndots)
            for dotlocj, col in zip(dotlocs, dotcols):
                gi = fill(gi, col, {(ii, dotlocj)})
                if col in linecols:
                    idx = linecols.index(col)
                    linelocj = locs[idx]
                    if dotlocj > linelocj:
                        go = fill(go, col, {(ii, linelocj + 1)})
                    else:
                        go = fill(go, col, {(ii, linelocj - 1)})
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_83302e8f(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (3, 4))
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        nh = unifint(diff_lb, diff_ub, (3, 30 // (h + 1)))
        nw = unifint(diff_lb, diff_ub, (3, 30 // (w + 1)))
        bgc, linc = sample(cols, 2)
        fullh = h * nh + nh - 1
        fullw = w * nw + nw - 1
        gi = canvas(bgc, (fullh, fullw))
        for iloc in range(h, fullh, h+1):
            gi = fill(gi, linc, hfrontier((iloc, 0)))
        for jloc in range(w, fullw, w+1):
            gi = fill(gi, linc, vfrontier((0, jloc)))
        ofc = ofcolor(gi, linc)
        dots = sfilter(ofc, lambda ij: dneighbors(ij).issubset(ofc))
        tmp = fill(gi, bgc, dots)
        lns = apply(toindices, colorfilter(objects(tmp, T, F, F), linc))
        dts = apply(initset, dots)
        cands = lns | dts
        nbreaks = unifint(diff_lb, diff_ub, (0, len(cands) // 2))
        breaklocs = set()
        breakobjs = sample(totuple(cands), nbreaks)
        for breakobj in breakobjs:
            loc = choice(totuple(breakobj))
            breaklocs.add(loc)
        gi = fill(gi, bgc, breaklocs)
        objs = objects(gi, T, F, F)
        objs = colorfilter(objs, bgc)
        objs = sfilter(objs, lambda o: len(o) == h * w)
        res = toindices(merge(objs))
        go = fill(gi, 3, res)
        go = replace(go, bgc, 4)
        return {'input': gi, 'output': go}

    def generate_98cf29f8(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        objh = unifint(diff_lb, diff_ub, (2, h - 5))
        objw = unifint(diff_lb, diff_ub, (2, w - 5))
        loci = randint(0, h - objh)
        locj = randint(0, w - objw)
        loc = (loci, locj)
        obj = backdrop(frozenset({(loci, locj), (loci + objh - 1, locj + objw - 1)}))
        bgc, objc, otherc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        gi = fill(gi, objc, obj)
        bmarg = h - (loci + objh)
        rmarg = w - (locj + objw)
        tmarg = loci
        lmarg = locj
        margs = (bmarg, rmarg, tmarg, lmarg)
        options = [idx for idx, marg in enumerate(margs) if marg > 2]
        pos = choice(options)
        for k in range(pos):
            gi = rot90(gi)
        h, w = shape(gi)
        ofc = ofcolor(gi, objc)
        locis = randint(lowermost(ofc)+2, h-2)
        locie = randint(locis+1, h-1)
        locjs = randint(0, min(w - 2, rightmost(ofc)))
        locje = randint(max(locjs+1, leftmost(ofc)), w - 1)
        otherobj = backdrop(frozenset({(locis, locjs), (locie, locje)}))
        ub = min(rightmost(ofc), rightmost(otherobj))
        lb = max(leftmost(ofc), leftmost(otherobj))
        jloc = randint(lb, ub)
        ln = connect((lowermost(ofc)+1, jloc), (uppermost(otherobj)-1, jloc))
        gib = tuple(e for e in gi)
        gi = fill(gi, otherc, otherobj)
        gi = fill(gi, otherc, ln)
        go = fill(gib, otherc, shift(otherobj, (-len(ln), 0)))
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_1f85a75f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        oh = randint(3, min(8, h // 2))
        ow = randint(3, min(8, w // 2))
        bounds = asindices(canvas(-1, (oh, ow)))
        ncells = randint(max(oh, ow), oh * ow)
        sp = choice(totuple(bounds))
        obj = {sp}
        cands = remove(sp, bounds)
        for k in range(ncells - 1):
            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))
        obj = normalize(obj)
        oh, ow = shape(obj)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        bgc, objc = sample(cols, 2)
        remcols = remove(bgc, remove(objc, cols))
        numc = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numc)
        nnoise = unifint(diff_lb, diff_ub, (0, max(0, ((h * w) - len(backdrop(obj))) // 4)))
        gi = canvas(bgc, (h, w))
        obj = shift(obj, (loci, locj))
        gi = fill(gi, objc, obj)
        inds = asindices(gi)
        noisecells = sample(totuple(inds - backdrop(obj)), nnoise)
        noiseobj = frozenset({(choice(ccols), ij) for ij in noisecells})
        gi = paint(gi, noiseobj)
        go = fill(canvas(bgc, (oh, ow)), objc, normalize(obj))
        return {'input': gi, 'output': go}

    def generate_8eb1be9a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        oh = unifint(diff_lb, diff_ub, (2, h // 3))
        ow = unifint(diff_lb, diff_ub, (2, w))
        bounds = asindices(canvas(-1, (oh, ow)))
        ncells = unifint(diff_lb, diff_ub, (2, (oh * ow) // 3 * 2))
        obj = normalize(frozenset(sample(totuple(bounds), ncells)))
        oh, ow = shape(obj)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, ncols)
        obj = frozenset({(choice(ccols), ij) for ij in obj})
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        obj = shift(obj, (loci, locj))
        c = canvas(bgc, (h, w))
        gi = paint(c, obj)
        go = paint(c, obj)
        for k in range(h // oh + 1):
            go = paint(go, shift(obj, (-oh*k, 0)))
            go = paint(go, shift(obj, (oh*k, 0)))
        return {'input': gi, 'output': go}

    def generate_ba26e723(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (0, 6))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w = unifint(diff_lb, diff_ub, (2, 30))
        gi = canvas(0, (h, w))
        go = canvas(0, (h, w))
        opts = interval(0, h, 1)
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(cols, ncols)
        for j in range(w):
            nc = unifint(diff_lb, diff_ub, (1, h - 1))
            locs = sample(opts, nc)
            obj = frozenset({(choice(ccols), (ii, j)) for ii in locs})
            gi = paint(gi, obj)
            if j % 3 == 0:
                obj = recolor(6, obj)
            go = paint(go, obj)
        return {'input': gi, 'output': go}

    def generate_25d487eb(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (2, 8))
        ccols = sample(remcols, ncols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 30))
        succ = 0
        tr = 0
        maxtr = 10 * nobjs
        inds = asindices(go)
        while tr < maxtr and succ < nobjs:
            if len(inds) == 0:
                break
            tr += 1
            dim = randint(1, 3)
            obj = backdrop(frozenset({(0, 0), (dim, dim)}))
            obj = sfilter(obj, lambda ij: ij[0] <= ij[1])
            obj = obj | shift(vmirror(obj), (0, dim))
            mp = {(0, dim)}
            tric, linc = sample(ccols, 2)
            inobj = recolor(tric, obj - mp) | recolor(linc, mp)
            loc = choice(totuple(inds))
            iplcd = shift(inobj, loc)
            loci, locj = loc
            oplcd = iplcd | recolor(linc, connect((loci, locj + dim), (h - 1, locj + dim)) - toindices(iplcd))
            fullinds = asindices(gi)
            oplcdi = toindices(oplcd)
            if oplcdi.issubset(inds):
                succ += 1
                gi = paint(gi, iplcd)
                go = paint(go, oplcd)
            rotf = choice((identity, rot90, rot180, rot270))
            gi = rotf(gi)
            go = rotf(go)
            h, w = shape(gi)
            ofc = ofcolor(go, bgc)
            inds = ofc - mapply(dneighbors, asindices(go) - ofc)
        return {'input': gi, 'output': go}

    def generate_4be741c5(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        numcolors = unifint(diff_lb, diff_ub, (2, w // 3))
        ccols = sample(cols, numcolors)
        go = (tuple(ccols),)
        gi = merge(tuple(repeat(repeat(c, h), 3) for c in ccols))
        while len(gi) < w:
            idx = randint(0, len(gi) - 1)
            gi = gi[:idx] + gi[idx:idx+1] + gi[idx:]
        gi = dmirror(gi)
        ndisturbances = unifint(diff_lb, diff_ub, (0, 3 * h * numcolors))
        for k in range(ndisturbances):
            options = []
            for a in range(h):
                for b in range(w - 3):
                    if gi[a][b] == gi[a][b+1] and gi[a][b+2] == gi[a][b+3]:
                        options.append((a, b, gi[a][b], gi[a][b+2]))
            if len(options) == 0:
                break
            a, b, c1, c2 = choice(options)
            if choice((True, False)):
                gi = fill(gi, c2, {(a, b+1)})
            else:
                gi = fill(gi, c1, {(a, b+2)})
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_e509e548(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 6))
        getL = lambda h, w: connect((0, 0), (h - 1, 0)) | connect((0, 0), (0, w - 1))
        getU = lambda h, w: connect((0, 0), (0, w - 1)) | connect((0, 0), (randint(1, h - 1), 0)) | connect((0, w - 1), (randint(1, h - 1), w - 1))
        getH = lambda h, w: connect((0, 0), (0, w - 1)) | shift(connect((0, 0), (h - 1, 0)) | connect((h - 1, 0), (h - 1, randint(1, w - 1))), (0, randint(1, w - 2)))
        minshp_getter_pairs = ((2, 2, getL), (2, 3, getU), (3, 3, getH))
        colmapper = {getL: 1, getU: 6, getH: 2}
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (1, 6))
        ccols = sample(remcols, ncols)
        nobjs = unifint(diff_lb, diff_ub, (3, (h * w) // 10))
        succ = 0
        tr = 0
        maxtr = 5 * nobjs
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while succ < nobjs and tr < maxtr:
            tr += 1
            minh, minw, getter = choice(minshp_getter_pairs)
            oh = randint(minh, 6)
            ow = randint(minw, 6)
            obj = getter(oh, ow)
            mfs = (identity, dmirror, cmirror, vmirror, hmirror)
            nmfs = choice((1, 2))
            for fn in sample(mfs, nmfs):
                obj = fn(obj)
                obj = normalize(obj)
            oh, ow = shape(obj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            if plcd.issubset(inds):
                succ += 1
                inds = (inds - plcd) - mapply(dneighbors, plcd)
                col = choice(ccols)
                gi = fill(gi, col, plcd)
                go = fill(go, colmapper[getter], plcd)
        return {'input': gi, 'output': go}

    def generate_810b9b61(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (3,))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (1, 6))
        ccols = sample(remcols, ncols)
        nobjs = unifint(diff_lb, diff_ub, (3, (h * w) // 10))
        succ = 0
        tr = 0
        maxtr = 5 * nobjs
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while succ < nobjs and tr < maxtr:
            tr += 1
            oh = randint(3, 5)
            ow = randint(3, 5)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            obj = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1  )}))
            mfs = (identity, dmirror, cmirror, vmirror, hmirror)
            nmfs = choice((1, 2))
            for fn in sample(mfs, nmfs):
                obj = fn(obj)
                obj = normalize(obj)
            oh, ow = shape(obj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            if choice((True, False)):
                ninobjc = unifint(diff_lb, diff_ub, (1, len(plcd) - 1))
                inobj = frozenset(sample(totuple(plcd), ninobjc))
            else:
                inobj = plcd
            if inobj.issubset(inds):
                succ += 1
                inds = (inds - inobj) - mapply(dneighbors, inobj)
                col = choice(ccols)
                gi = fill(gi, col, inobj)
                go = fill(go, 3 if box(inobj) == inobj and min(shape(inobj)) > 2 else col, inobj)
        return {'input': gi, 'output': go}

    def generate_6d0160f0(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (4,))
        h = unifint(diff_lb, diff_ub, (2, 5))
        w = unifint(diff_lb, diff_ub, (2, 5))
        nh, nw = h, w
        bgc, linc = sample(cols, 2)
        fullh = h * nh + nh - 1
        fullw = w * nw + nw - 1
        gi = canvas(bgc, (fullh, fullw))
        for iloc in range(h, fullh, h+1):
            gi = fill(gi, linc, hfrontier((iloc, 0)))
        for jloc in range(w, fullw, w+1):
            gi = fill(gi, linc, vfrontier((0, jloc)))
        noccs = unifint(diff_lb, diff_ub, (1, h * w))
        denseinds = asindices(canvas(-1, (h, w)))
        sparseinds = {(a*(h+1), b*(w+1)) for a, b in denseinds}
        locs = sample(totuple(sparseinds), noccs)
        trgtl = choice(locs)
        remlocs = remove(trgtl, locs)
        ntrgt = unifint(diff_lb, diff_ub, (1, (h * w - 1)))
        place = choice(totuple(denseinds))
        ncols = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(cols, ncols)
        candss = totuple(remove(place, denseinds))
        trgrem = sample(candss, ntrgt)
        trgrem = {(choice(ccols), ij) for ij in trgrem}
        trgtobj = {(4, place)} | trgrem
        go = paint(gi, shift(sfilter(trgtobj, lambda cij: cij[0] != linc), multiply(place, increment((h, w)))))
        gi = paint(gi, shift(trgtobj, trgtl))
        toleaveout = ccols
        for rl in remlocs:
            tlo = choice(totuple(ccols))
            ncells = unifint(diff_lb, diff_ub, (1, h * w - 1))
            inds = sample(totuple(denseinds), ncells)
            obj = {(choice(remove(tlo, ccols) if len(ccols) > 1 else ccols), ij) for ij in inds}
            toleaveout = remove(tlo, toleaveout)
            gi = paint(gi, shift(obj, rl))
        return {'input': gi, 'output': go}

    def generate_63613498(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc, sepc = sample(cols, 2)
        remcols = remove(bgc, remove(sepc, cols))
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, ncols)
        objh = unifint(diff_lb, diff_ub, (1, h//3))
        objw = unifint(diff_lb, diff_ub, (1, w//3))
        bounds = asindices(canvas(-1, (objh, objw)))
        sp = choice(totuple(bounds))
        obj = {sp}
        ncells = unifint(diff_lb, diff_ub, (1, (objh * objw)))
        for k in range(ncells - 1):
            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))
        gi = canvas(bgc, (h, w))
        objc = choice(ccols)
        gi = fill(gi, objc, obj)
        sep = connect((objh+1, 0), (objh+1, objw+1)) | connect((0, objw+1), (objh+1, objw+1))
        gi = fill(gi, sepc, sep)
        inds = asindices(gi)
        inds -= backdrop(sep)
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 20))
        succ = 0
        tr = 0
        maxtr = 5 * nobjs
        baseobj = normalize(obj)
        obj = normalize(obj)
        go = tuple(e for e in gi)
        while (succ < nobjs and tr < maxtr) or succ == 0:
            tr += 1
            oh, ow = shape(obj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            if plcd.issubset(inds):
                col = choice(ccols)
                gi = fill(gi, col, plcd)
                go = fill(go, sepc if succ == 0 else col, plcd)
                succ += 1
                inds = (inds - plcd) - mapply(dneighbors, plcd)
            objh = randint(1, h // 3)
            objw = randint(2 if objh == 1 else 1, w // 3)
            if choice((True, False)):
                objh, objw = objw, objh
            bounds = asindices(canvas(-1, (objh, objw)))
            sp = choice(totuple(bounds))
            obj = {sp}
            ncells = unifint(diff_lb, diff_ub, (1, (objh * objw)))
            for k in range(ncells - 1):
                obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))
            obj = normalize(obj)
            obj = set(obj)
            if obj == baseobj:
                if len(obj) < objh * objw:
                    obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))
                else:
                    obj = remove(choice(totuple(corners(obj))), obj)
            obj = normalize(obj)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_e5062a87(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        eligcol, objc = sample(cols, 2)
        gi = canvas(eligcol, (h, w))
        inds = asindices(gi)
        sp = choice(totuple(inds))
        obj = {sp}
        ncells = unifint(diff_lb, diff_ub, (3, 9))
        for k in range(ncells - 1):
            obj.add(choice(totuple((inds - obj) & mapply(neighbors, obj))))
        obj = normalize(obj)
        nnoise = unifint(diff_lb, diff_ub, (int(0.2*h*w), int(0.5*h*w)))
        locs = sample(totuple(inds), nnoise)
        gi = fill(gi, 0, locs)
        noccs = unifint(diff_lb, diff_ub, (2, max(2, (h * w) // (len(obj) * 3))))
        oh, ow = shape(obj)
        for k in range(noccs):
            loci = randint(0, h - oh)
            locj = randint(0, w - ow)
            loc = (loci, locj)
            gi = fill(gi, objc if k == noccs - 1 else 0, shift(obj, loc))
        occs = occurrences(gi, recolor(0, obj))
        res = mapply(lbind(shift, obj), occs)
        go = fill(gi, objc, res)
        return {'input': gi, 'output': go}

    def generate_bc1d5164(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 15))
        w = unifint(diff_lb, diff_ub, (2, 14))
        fullh = 2 * h - 1
        fullw = 2 * w + 1
        bgc, objc = sample(cols, 2)
        inds = asindices(canvas(-1, (h, w)))
        nA = randint(1, (h - 1) * (w - 1) - 1)
        nB = randint(1, (h - 1) * (w - 1) - 1)
        nC = randint(1, (h - 1) * (w - 1) - 1)
        nD = randint(1, (h - 1) * (w - 1) - 1)
        A = sample(totuple(sfilter(inds, lambda ij: ij[0] < h - 1 and ij[1] < w - 1)), nA)
        B = sample(totuple(sfilter(inds, lambda ij: ij[0] < h - 1 and ij[1] > 0)), nB)
        C = sample(totuple(sfilter(inds, lambda ij: ij[0] > 0 and ij[1] < w - 1)), nC)
        D = sample(totuple(sfilter(inds, lambda ij: ij[0] > 0 and ij[1] > 0)), nD)
        gi = canvas(bgc, (fullh, fullw))
        gi = fill(gi, objc, A)
        gi = fill(gi, objc, shift(B, (0, fullw - w)))
        gi = fill(gi, objc, shift(C, (fullh - h, 0)))
        gi = fill(gi, objc, shift(D, (fullh - h, fullw - w)))
        go = canvas(bgc, (h, w))
        go = fill(go, objc, set(A) | set(B) | set(C) | set(D))
        return {'input': gi, 'output': go}

    def generate_11852cab(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        r1 = ((0, 0), (0, 4), (4, 0), (4, 4))
        r2 = ((2, 0), (0, 2), (4, 2), (2, 4))
        r3 = ((1, 1), (3, 1), (1, 3), (3, 3))
        r4 = ((2, 2),)
        rings = [r4, r3, r2, r1]
        bx = backdrop(frozenset(r1))
        h = unifint(diff_lb, diff_ub, (7, 30))
        w = unifint(diff_lb, diff_ub, (7, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, numc)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = shift(asindices(trim(gi)), UNITY)
        nobjs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // 36)))
        succ = 0
        tr = 0
        maxtr = 10 * nobjs
        while succ < nobjs and tr < maxtr:
            tr += 1
            cands = sfilter(inds, lambda ij: ij[0] <= h - 5 and ij[0] <= w - 5)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            plcd = shift(bx, loc)
            if plcd.issubset(inds):
                inds = (inds - plcd) - outbox(plcd)
                ringcols = [choice(ccols) for k in range(4)]
                plcdrings = [shift(r, loc) for r in rings]
                gi = fill(gi, ringcols[0], plcdrings[0])
                go = fill(go, ringcols[0], plcdrings[0])
                idx = randint(1, 3)
                gi = fill(gi, ringcols[idx], plcdrings[idx])
                go = fill(go, ringcols[idx], plcdrings[idx])
                remrings = plcdrings[1:idx] + plcdrings[idx+1:]
                remringcols = ringcols[1:idx] + ringcols[idx+1:]
                numrs = unifint(diff_lb, diff_ub, (1, 2))
                locs = sample((0, 1), numrs)
                remrings = [rr for j, rr in enumerate(remrings) if j in locs]
                remringcols = [rr for j, rr in enumerate(remringcols) if j in locs]
                tofillgi = merge(frozenset(
                    recolor(col, frozenset(sample(totuple(remring), 4 - unifint(diff_lb, diff_ub, (0, 3))))) for remring, col in zip(remrings, remringcols)
                ))
                tofillgo = merge(frozenset(
                    recolor(col, remring) for remring, col in zip(remrings, remringcols)
                ))
                if min(shape(tofillgi)) == 5:
                    succ += 1
                    gi = paint(gi, tofillgi)
                    go = paint(go, tofillgo)
        return {'input': gi, 'output': go}

    def generate_025d127b(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, numcols)
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 20))
        succ = 0
        tr = 0
        maxtr = 5 * nobjs
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while succ < nobjs and tr < maxtr:
            tr += 1
            oh = randint(3, 6)
            ow = randint(3, 6)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            topl = connect((0, 0), (0, ow - 1))
            leftl = connect((1, 0), (oh - 2, oh - 3))
            rightl = connect((1, ow), (oh - 2, ow + oh - 3))
            botl = connect((oh - 1, oh - 2), (oh - 1, oh - 3 + ow))
            inobj = topl | leftl | rightl | botl
            outobj = shift(topl, (0, 1)) | botl | shift(leftl, (0, 1)) | connect((1, ow+1), (oh - 3, ow + oh - 3)) | {(oh - 2, ow + oh - 3)}
            outobj = sfilter(outobj, lambda ij: ij[1] <= rightmost(inobj))
            fullobj = inobj | outobj
            inobj = shift(inobj, loc)
            outobj = shift(outobj, loc)
            fullobj = shift(fullobj, loc)
            if fullobj.issubset(inds):
                inds = (inds - fullobj) - mapply(neighbors, fullobj)
                succ += 1
                col = choice(ccols)
                gi = fill(gi, col, inobj)
                go = fill(go, col, outobj)
        return {'input': gi, 'output': go}

    def generate_045e512c(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (11, 30))
        w = unifint(diff_lb, diff_ub, (11, 30))
        while True:
            oh = unifint(diff_lb, diff_ub, (2, min(4, (h - 2) // 3)))
            ow = unifint(diff_lb, diff_ub, (2, min(4, (w - 2) // 3)))
            bounds = asindices(canvas(-1, (oh, ow)))
            c1 = choice(totuple(connect((0, 0), (oh - 1, 0))))
            c2 = choice(totuple(connect((0, 0), (0, ow - 1))))
            c3 = choice(totuple(connect((oh - 1, ow - 1), (oh - 1, 0))))
            c4 = choice(totuple(connect((oh - 1, ow - 1), (0, ow - 1))))
            obj = {c1, c2, c3, c4}
            remcands = totuple(bounds - obj)
            ncells = unifint(diff_lb, diff_ub, (0, len(remcands)))
            for k in range(ncells):
                loc = choice(remcands)
                obj.add(loc)
                remcands = remove(loc, remcands)
            objt = normalize(obj)
            cc = canvas(0, shape(obj))
            cc = fill(cc, 1, objt)
            if len(colorfilter(objects(cc, T, T, F), 1)) == 1:
                break
        loci = randint(oh + 1, h - 2 * oh - 1)
        locj = randint(ow + 1, w - 2 * ow - 1)
        loc = (loci, locj)
        bgc, objc = sample(cols, 2)
        remcols = remove(bgc, remove(objc, cols))
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, ncols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        obj = shift(recolor(objc, obj), loc)
        gi = paint(gi, obj)
        go = paint(go, obj)
        options = totuple(neighbors((0, 0)))
        ndirs = unifint(diff_lb, diff_ub, (1, 8))
        dirs = sample(options, ndirs)
        dcols = [choice(ccols) for k in range(ndirs)]
        hbars = hfrontier((loci - 2, 0)) | hfrontier((loci+oh+1, 0))
        vbars = vfrontier((0, locj - 2)) | vfrontier((0, locj+ow+1))
        bars = hbars | vbars
        ofs = increment((oh, ow))
        for direc, col in zip(dirs, dcols):
            indicatorobj = shift(obj, multiply(direc, increment((oh, ow))))
            indicatorobj = sfilter(indicatorobj, lambda cij: cij[1] in bars)
            nindsd = unifint(diff_lb, diff_ub, (0, len(indicatorobj) - 1))
            ninds = len(indicatorobj) - nindsd
            indicatorobj = set(sample(totuple(indicatorobj), ninds))
            if len(indicatorobj) > 0 and len(indicatorobj) < len(obj):
                gi = fill(gi, col, indicatorobj)
                for k in range(1, 10):
                    go = fill(go, col, shift(obj, multiply(multiply(k, direc), ofs)))
        return {'input': gi, 'output': go}

    def generate_1b60fb0c(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        odh = unifint(diff_lb, diff_ub, (2, min(h, w)//2))
        loci = randint(0, h - 2 * odh)
        locj = randint(0, w - 2 * odh)
        loc = (loci, locj)
        bgc, objc = sample(cols, 2)
        quad = canvas(bgc, (odh, odh))
        ncellsd = unifint(diff_lb, diff_ub, (0, odh ** 2 // 2))
        ncells = choice((ncellsd, odh ** 2 - ncellsd))
        ncells = min(max(1, ncells), odh ** 2 - 1)
        cells = sample(totuple(asindices(canvas(-1, (odh, odh)))), ncells)
        g1 = fill(quad, objc, cells)
        g2 = rot90(g1)
        g3 = rot90(g2)
        g4 = rot90(g3)
        c1 = shift(ofcolor(g1, objc), (0, 0))
        c2 = shift(ofcolor(g2, objc), (0, odh))
        c3 = shift(ofcolor(g3, objc), (odh, odh))
        c4 = shift(ofcolor(g4, objc), (odh, 0))
        shftamt = randint(0, odh)
        c1 = shift(c1, (0, shftamt))
        c2 = shift(c2, (shftamt, 0))
        c3 = shift(c3, (0, -shftamt))
        c4 = shift(c4, (-shftamt, 0))
        cs = (c1, c2, c3, c4)
        rempart = choice(cs)
        inobjparts = remove(rempart, cs)
        inobj = merge(set(inobjparts))
        rempart = rempart - inobj
        inobj = shift(inobj, loc)
        rempart = shift(rempart, loc)
        gi = canvas(bgc, (h, w))
        gi = fill(gi, objc, inobj)
        go = fill(gi, 2, rempart)
        return {'input': gi, 'output': go}

    def generate_1f0c79e5(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc, objc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 24))
        inds = asindices(gi)
        obj = ((0, 0), (0, 1), (1, 0), (1, 1))
        for k in range(nobjs):
            cands = sfilter(inds, lambda ij: shift(set(obj), ij).issubset(inds))
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            nred = unifint(diff_lb, diff_ub, (1, 3))
            reds = sample(totuple(plcd), nred)
            gi = fill(gi, objc, plcd)
            gi = fill(gi, 2, reds)
            for idx in reds:
                direc = decrement(multiply(2, add(idx, invert(loc))))
                go = fill(go, objc, mapply(rbind(shoot, direc), frozenset(plcd)))
            inds = (inds - plcd) - mapply(dneighbors, set(plcd))
        return {'input': gi, 'output': go}

    def generate_1f876c06(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        nlns = unifint(diff_lb, diff_ub, (1, min(min(h, w), 9)))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ccols = sample(remcols, nlns)
        succ = 0
        tr = 0
        maxtr = 10 * nlns
        direcs = ineighbors((0, 0))
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while succ < nlns and tr < maxtr:
            tr += 1
            if len(inds) == 0:
                break
            loc = choice(totuple(inds))
            lns = []
            for direc in direcs:
                ln = [loc]
                ofs = 1
                while True:
                    nextpix = add(loc, multiply(ofs, direc))
                    ofs += 1
                    if nextpix not in inds:
                        break
                    ln.append(nextpix)
                if len(ln) > 2:
                    lns.append(ln)
            if len(lns) > 0:
                succ += 1
                lns = sorted(lns, key=len)
                idx = unifint(diff_lb, diff_ub, (0, len(lns) - 1))
                ln = lns[idx]
                col = ccols[0]
                ccols = ccols[1:]
                gi = fill(gi, col, {ln[0], ln[-1]})
                go = fill(go, col, set(ln))
                inds = inds - set(ln)
        return {'input': gi, 'output': go}

    def generate_22233c11(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 10))
        succ = 0
        tr = 0
        maxtr = 10 * nobjs
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        fullinds = asindices(gi)
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, ncols)
        while succ < nobjs and tr < maxtr:
            if len(inds) == 0:
                break
            tr += 1
            od = randint(1, 3)
            fulld = 4 * od
            g = canvas(bgc, (4, 4))
            g = fill(g, 8, {(0, 3), (3, 0)})
            col = choice(ccols)
            g = fill(g, col, {(1, 1), (2, 2)})
            if choice((True, False)):
                g = hmirror(g)
            g = upscale(g, od)
            inobj = recolor(col, ofcolor(g, col))
            outobj = inobj | recolor(8, ofcolor(g, 8))
            loc = choice(totuple(inds))
            outobj = shift(outobj, loc)
            inobj = shift(inobj, loc)
            outobji = toindices(outobj)
            if toindices(inobj).issubset(inds) and (outobji & fullinds).issubset(inds):
                succ += 1
                inds = (inds - outobji) - mapply(neighbors, outobji)
                gi = paint(gi, inobj)
                go = paint(go, outobj)
        return {'input': gi, 'output': go}

    def generate_264363fd(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        cp = (2, 2)
        neighs = neighbors(cp)
        o1 = shift(frozenset({(0, 1), (-1, 1)}), (1, 1))
        o2 = shift(frozenset({(1, 0), (1, -1)}), (1, 1))
        o3 = shift(frozenset({(2, 1), (3, 1)}), (1, 1))
        o4 = shift(frozenset({(1, 2), (1, 3)}), (1, 1))
        mpr = {o1: (-1, 0), o2: (0, -1), o3: (1, 0), o4: (0, 1)}
        h = unifint(diff_lb, diff_ub, (15, 30))
        w = unifint(diff_lb, diff_ub, (15, 30))
        bgc, sqc, linc = sample(cols, 3)
        remcols = difference(cols, (bgc, sqc, linc))
        cpcol = choice(remcols)
        nbhcol = choice(remcols)
        nspikes = randint(1, 4)
        spikes = sample((o1, o2, o3, o4), nspikes)
        lns = merge(set(spikes))
        obj = {(cpcol, cp)} | recolor(linc, lns) | recolor(nbhcol, neighs - lns)
        loci = randint(0, h - 5)
        locj = randint(0, w - 5)
        loc = (loci, locj)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        gi = paint(gi, shift(obj, loc))
        numsq = unifint(diff_lb, diff_ub, (1, (h * w) // 100))
        succ = 0
        tr = 0
        maxtr = 10 * numsq
        inds = ofcolor(gi, bgc) - mapply(neighbors, toindices(shift(obj, loc)))
        while succ < numsq and tr < maxtr:
            tr += 1
            gh = randint(5, h//2+1)
            gw = randint(5, w//2+1)
            cands = sfilter(inds, lambda ij: ij[0] <= h - gh and ij[1] <= w - gw)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            g1 = canvas(sqc, (gh, gw))
            g2 = canvas(sqc, (gh, gw))
            ginds = asindices(g1)
            gindsfull = asindices(g1)
            bck = shift(ginds, loc)
            if bck.issubset(inds):
                noccs = unifint(diff_lb, diff_ub, (1, (gh * gw) // 25))
                succ2 = 0
                tr2 = 0
                maxtr2 = 5 * noccs
                while succ2 < noccs and tr2 < maxtr2:
                    tr2 += 1
                    cands2 = sfilter(ginds, lambda ij: ij[0] <= gh - 5 and ij[1] <= gw - 5)
                    if len(cands2) == 0:
                        break
                    loc2 = choice(totuple(cands2))
                    lns2 = merge(frozenset({shoot(add(cp, add(loc2, mpr[spike])), mpr[spike]) for spike in spikes}))
                    lns2 = lns2 & gindsfull
                    plcd2 = shift(obj, loc2)
                    plcd2i = toindices(plcd2)
                    if plcd2i.issubset(ginds) and lns2.issubset(ginds | ofcolor(g2, linc)) and len(lns2 - plcd2i) > 0:
                        succ2 += 1
                        ginds = ((ginds - plcd2i) - mapply(neighbors, plcd2i)) - lns2
                        g1 = fill(g1, cpcol, {add(cp, loc2)})
                        g2 = paint(g2, plcd2)
                        g2 = fill(g2, linc, lns2)
                if succ2 > 0:
                    succ += 1
                    inds = (inds - bck) - outbox(bck)
                    objfull1 = shift(asobject(g1), loc)
                    objfull2 = shift(asobject(g2), loc)
                    gi = paint(gi, objfull1)
                    go = paint(go, objfull2)
        return {'input': gi, 'output': go}

    def generate_29ec7d0e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        hp = unifint(diff_lb, diff_ub, (2, h//2-1))
        wp = unifint(diff_lb, diff_ub, (2, w//2-1))
        pinds = asindices(canvas(-1, (hp, wp)))
        bgc, noisec = sample(cols, 2)
        remcols = remove(noisec, cols)
        numc = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, numc)
        pobj = frozenset({(choice(ccols), ij) for ij in pinds})
        go = canvas(bgc, (h, w))
        locs = set()
        for a in range(h//hp+1):
            for b in range(w//wp+1):
                loci = (a+1) + hp * a
                locj = (b+1) + wp * b
                locs.add((loci, locj))
                go = paint(go, shift(pobj, (loci, locj)))
        numpatches = unifint(diff_lb, diff_ub, (1, (h * w) // 20))
        gi = tuple(e for e in go)
        places = apply(lbind(shift, pinds), locs)
        succ = 0
        tr = 0
        maxtr = 5 * numpatches
        while succ < numpatches and tr < maxtr:
            tr += 1
            ph = randint(2, 6)
            pw = randint(2, 6)
            loci = randint(0, h - ph)
            locj = randint(0, w - pw)
            ptch = backdrop(frozenset({(loci, locj), (loci + ph - 1, locj + pw - 1)}))
            gi2 = fill(gi, noisec, ptch)
            if pobj in apply(normalize, apply(rbind(toobject, gi2), places)):
                if len(sfilter(gi2, lambda r: noisec not in r)) >= 2 and len(sfilter(dmirror(gi2), lambda r: noisec not in r)) >= 2:
                    succ += 1
                    gi = gi2
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_3bd67248(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 4))
        h = unifint(diff_lb, diff_ub, (3, 15))
        w = unifint(diff_lb, diff_ub, (3, 15))
        bgc, linc = sample(cols, 2)
        fac = unifint(diff_lb, diff_ub, (1, 30 // max(h, w)))
        gi = canvas(bgc, (h, w))
        gi = fill(gi, linc, connect((0, 0), (h - 1, 0)))
        go = fill(gi, 4, connect((h - 1, 1), (h - 1, w - 1)))
        go = fill(go, 2, shoot((h - 2, 1), (-1, 1)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        gi = upscale(gi, fac)
        go = upscale(go, fac)
        return {'input': gi, 'output': go}

    def generate_484b58aa(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        hp = unifint(diff_lb, diff_ub, (2, h//2-1))
        wp = unifint(diff_lb, diff_ub, (2, w//2-1))
        pinds = asindices(canvas(-1, (hp, wp)))
        noisec = choice(cols)
        remcols = remove(noisec, cols)
        numc = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, numc)
        pobj = frozenset({(choice(ccols), ij) for ij in pinds})
        go = canvas(-1, (h, w))
        locs = set()
        ofs = randint(1, hp - 1)
        for a in range(2*(h//hp+1)):
            for b in range(w//wp+1):
                loci = hp * a - ofs * b
                locj = wp * b
                locs.add((loci, locj))
                go = paint(go, shift(pobj, (loci, locj)))
        numpatches = unifint(diff_lb, diff_ub, (1, (h * w) // 20))
        gi = tuple(e for e in go)
        places = apply(lbind(shift, pinds), locs)
        succ = 0
        tr = 0
        maxtr = 5 * numpatches
        while succ < numpatches and tr < maxtr:
            tr += 1
            ph = randint(2, 6)
            pw = randint(2, 6)
            loci = randint(0, h - ph)
            locj = randint(0, w - pw)
            ptch = backdrop(frozenset({(loci, locj), (loci + ph - 1, locj + pw - 1)}))
            gi2 = fill(gi, noisec, ptch)
            if pobj in apply(normalize, apply(rbind(toobject, gi2), places)):
                if len(sfilter(gi2, lambda r: noisec not in r)) >= 2 and len(sfilter(dmirror(gi2), lambda r: noisec not in r)) >= 2:
                    succ += 1
                    gi = gi2
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_6aa20dc0(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        od = unifint(diff_lb, diff_ub, (2, 4))
        ncellsextra = randint(1, max(1, (od ** 2 - 2) // 2))
        sinds = asindices(canvas(-1, (od, od)))
        extracells = set(sample(totuple(sinds - {(0, 0), (od - 1, od - 1)}), ncellsextra))
        extracells.add(choice(totuple(dneighbors((0, 0)) & sinds)))
        extracells.add(choice(totuple(dneighbors((od - 1, od - 1)) & sinds)))
        extracells = frozenset(extracells)
        bgc, fgc, c1, c2 = sample(cols, 4)
        obj = frozenset({(c1, (0, 0)), (c2, (od - 1, od - 1))}) | recolor(fgc, extracells)
        obj = obj | dmirror(obj)
        if choice((True, False)):
            obj = hmirror(obj)
        gi = canvas(bgc, (h, w))
        loci = randint(0, h - od)
        locj = randint(0, w - od)
        plcd = shift(obj, (loci, locj))
        gi = paint(gi, plcd)
        go = tuple(e for e in gi)
        inds = asindices(gi)
        inds = inds - backdrop(outbox(plcd))
        nocc = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // (od ** 2 * 2))))
        succ = 0
        tr = 0
        maxtr = 4 * nocc
        while succ < nocc and tr < maxtr:
            tr += 1
            fac = randint(1, 4)
            mf1 = choice((identity, dmirror, vmirror, cmirror, hmirror))
            mf2 = choice((identity, dmirror, vmirror, cmirror, hmirror))
            mf = compose(mf2, mf1)
            cobj = normalize(upscale(mf(obj), fac))
            ohx, owx = shape(cobj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - ohx and ij[1] <= w - owx)
            if len(cands) == 0:
                continue
            locc = choice(totuple(cands))
            cobjo = shift(cobj, locc)
            cobji = sfilter(cobjo, lambda cij: cij[0] != fgc)
            cobjoi = toindices(cobjo)
            if cobjoi.issubset(inds):
                succ += 1
                inds = inds - backdrop(outbox(cobjoi))
                gi = paint(gi, cobji)
                go = paint(go, cobjo)
        return {'input': gi, 'output': go}

    def generate_6855a6e4(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        fullh = unifint(diff_lb, diff_ub, (10, h))
        fullw = unifint(diff_lb, diff_ub, (3, w))
        bgc, objc, boxc = sample(cols, 3)
        bcanv = canvas(bgc, (h, w))
        loci = randint(0, h - fullh)
        locj = randint(0, w - fullw)
        loc = (loci, locj)
        canvi = canvas(bgc, (fullh, fullw))
        canvo = canvas(bgc, (fullh, fullw))
        objh = (fullh // 2 - 3) // 2
        br = connect((objh + 1, 0), (objh + 1, fullw - 1))
        br = br | {(objh + 2, 0), (objh + 2, fullw - 1)}
        cands = backdrop(frozenset({(0, 1), (objh - 1, fullw - 2)}))
        for k in range(2):
            canvi = fill(canvi, boxc, br)
            canvo = fill(canvo, boxc, br)
            ncellsd = unifint(diff_lb, diff_ub, (0, (objh * (fullw - 2)) // 2))
            ncells = choice((ncellsd, objh * (fullw - 2) - ncellsd))
            ncells = min(max(1, ncells), objh * (fullw - 2))
            cells = frozenset(sample(totuple(cands), ncells))
            canvi = fill(canvi, objc, cells)
            canvo = fill(canvo, objc, shift(hmirror(cells), (objh + 3, 0)))
            canvi = hmirror(canvi)
            canvo = hmirror(canvo)
        gi = paint(bcanv, shift(asobject(canvi), loc))
        go = paint(bcanv, shift(asobject(canvo), loc))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        return {'input': gi, 'output': go}

    def generate_39a8645d(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (15, 30))
        w = unifint(diff_lb, diff_ub, (15, 30))
        oh = randint(2, 4)
        ow = randint(2, 4)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        nobjs = unifint(diff_lb, diff_ub, (1, oh + ow))
        ccols = sample(remcols, nobjs+1)
        mxcol = ccols[0]
        rcols = ccols[1:]
        maxnocc = unifint(diff_lb, diff_ub, (nobjs + 2, max(nobjs + 2, (h * w) // 16)))
        tr = 0
        maxtr = 10 * maxnocc
        succ = 0
        allobjs = []
        bounds = asindices(canvas(-1, (oh, ow)))
        for k in range(nobjs + 1):
            while True:
                ncells = randint(oh + ow - 1, oh * ow)
                cobj = {choice(totuple(bounds))}
                while shape(cobj) != (oh, ow) and len(cobj) < ncells:
                    cobj.add(choice(totuple((bounds - cobj) & mapply(neighbors, cobj))))
                if cobj not in allobjs:
                    break
            allobjs.append(frozenset(cobj))
        mcobj = normalize(allobjs[0])
        remobjs = apply(normalize, allobjs[1:])
        mxobjcounter = 0
        remobjcounter = {robj: 0 for robj in remobjs}
        gi = canvas(bgc, (h, w))
        inds = asindices(gi)
        while tr < maxtr and succ < maxnocc:
            tr += 1
            candobjs = [robj for robj, cnt in remobjcounter.items() if cnt + 1 < mxobjcounter]
            if len(candobjs) == 0 or randint(0, 100) / 100 > diff_lb:
                obj = mcobj
                col = mxcol
            else:
                obj = choice(candobjs)
                col = rcols[remobjs.index(obj)]
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            if plcd.issubset(inds - mapply(neighbors, ofcolor(gi, col))):
                succ += 1
                inds = (inds - plcd) - mapply(dneighbors, plcd)
                gi = fill(gi, col, plcd)
                if obj in remobjcounter:
                    remobjcounter[obj] += 1
                else:
                    mxobjcounter += 1
        go = fill(canvas(bgc, shape(mcobj)), mxcol, mcobj)
        return {'input': gi, 'output': go}

    def generate_150deff5(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 8))
        bo = {(0, 0), (0, 1), (1, 0), (1, 1)}
        ro1 = {(0, 0), (0, 1), (0, 2)}
        ro2 = {(0, 0), (1, 0), (2, 0)}
        boforb = set()
        reforb = set()
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        noccs = unifint(diff_lb, diff_ub, (2, (h * w) // 10))
        inds = asindices(gi)
        needsbgc = []
        for k in range(noccs):
            obj, col = choice(((bo, 8), (choice((ro1, ro2)), 2)))
            oh, ow = shape(obj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow and shift(obj, ij).issubset(inds))
            if col == 8:
                cands = sfilter(cands, lambda ij: ij not in boforb)
            else:
                cands = sfilter(cands, lambda ij: ij not in reforb)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            if col == 8:
                boforb.add(add(loc, (-2, 0)))
                boforb.add(add(loc, (2, 0)))
                boforb.add(add(loc, (0, 2)))
                boforb.add(add(loc, (0, -2)))
            if col == 2:
                if obj == ro1:
                    reforb.add(add(loc, (0, 3)))
                    reforb.add(add(loc, (0, -3)))
                else:
                    reforb.add(add(loc, (1, 0)))
                    reforb.add(add(loc, (-1, 0)))
            plcd = shift(obj, loc)
            gi = fill(gi, fgc, plcd)
            go = fill(go, col, plcd)
            inds = inds - plcd
        return {'input': gi, 'output': go}

    def generate_239be575(diff_lb: float, diff_ub: float) -> dict:
        sq = {(0, 0), (1, 1), (0, 1), (1, 0)}
        cols = interval(1, 10, 1)
        while True:
            h = unifint(diff_lb, diff_ub, (6, 30))
            w = unifint(diff_lb, diff_ub, (6, 30))
            c = canvas(0, (h, w))
            fullcands = totuple(asindices(canvas(0, (h - 1, w - 1))))
            a = choice(fullcands)
            b = choice(remove(a, fullcands))
            mindist = unifint(diff_lb, diff_ub, (3, min(h, w) - 3))
            while not manhattan({a}, {b}) > mindist:
                a = choice(fullcands)
                b = choice(remove(a, fullcands))
            markcol, sqcol = sample(cols, 2)
            aset = shift(sq, a)
            bset = shift(sq, b)
            gi = fill(c, sqcol, aset | bset)
            cands = totuple(ofcolor(gi, 0))
            num = unifint(diff_lb, diff_ub, (int(0.25 * len(cands)), int(0.75 * len(cands))))
            mc = sample(cands, num)
            gi = fill(gi, markcol, mc)
            bobjs = colorfilter(objects(gi, T, F, F), markcol)
            ss = sfilter(bobjs, fork(both, rbind(adjacent, aset), rbind(adjacent, bset)))
            shoudlhaveconn = choice((True, False))
            if shoudlhaveconn and len(ss) == 0:
                while len(ss) == 0:
                    opts2 = totuple(ofcolor(gi, 0))
                    if len(opts2) == 0:
                        break
                    gi = fill(gi, markcol, {choice(opts2)})
                    bobjs = colorfilter(objects(gi, T, F, F), markcol)
                    ss = sfilter(bobjs, fork(both, rbind(adjacent, aset), rbind(adjacent, bset)))
            elif not shoudlhaveconn and len(ss) > 0:
                while len(ss) > 0:
                    opts2 = totuple(ofcolor(gi, markcol))
                    if len(opts2) == 0:
                        break
                    gi = fill(gi, 0, {choice(opts2)})
                    bobjs = colorfilter(objects(gi, T, F, F), markcol)
                    ss = sfilter(bobjs, fork(both, rbind(adjacent, aset), rbind(adjacent, bset)))
            if len(palette(gi)) == 3:
                break
        oc = markcol if shoudlhaveconn else 0
        go = canvas(oc, (1, 1))
        return {'input': gi, 'output': go}

    def generate_0dfd9992(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        hp = unifint(diff_lb, diff_ub, (2, h//2-1))
        wp = unifint(diff_lb, diff_ub, (2, w//2-1))
        pinds = asindices(canvas(-1, (hp, wp)))
        bgc, noisec = sample(cols, 2)
        remcols = remove(noisec, cols)
        numc = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, numc)
        pobj = frozenset({(choice(ccols), ij) for ij in pinds})
        go = canvas(bgc, (h, w))
        locs = set()
        for a in range(h//hp+1):
            for b in range(w//wp+1):
                loci = hp * a
                locj = wp * b
                locs.add((loci, locj))
                mf1 = identity if a % 2 == 0 else hmirror
                mf2 = identity if b % 2 == 0 else vmirror
                mf = compose(mf1, mf2)
                go = paint(go, shift(mf(pobj), (loci, locj)))
        numpatches = unifint(diff_lb, diff_ub, (1, int((h * w) ** 0.5 // 2)))
        gi = tuple(e for e in go)
        places = apply(lbind(shift, pinds), locs)
        succ = 0
        tr = 0
        maxtr = 5 * numpatches
        while succ < numpatches and tr < maxtr:
            tr += 1
            ph = randint(2, 6)
            pw = randint(2, 6)
            loci = randint(0, h - ph)
            locj = randint(0, w - pw)
            ptch = backdrop(frozenset({(loci, locj), (loci + ph - 1, locj + pw - 1)}))
            gi2 = fill(gi, noisec, ptch)
            candset = apply(normalize, apply(rbind(toobject, gi2), places))
            if len(sfilter(gi2, lambda r: noisec not in r)) >= 2 and len(sfilter(dmirror(gi2), lambda r: noisec not in r)) >= 2 and (pobj in candset or hmirror(pobj) in candset or vmirror(pobj) in candset or hmirror(vmirror(pobj)) in candset):
                succ += 1
                gi = gi2
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_d06dbe63(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(5, interval(0, 10, 1))
        obj1 = mapply(lbind(shift, frozenset({(-1, 0), (-2, 0), (-2, 1), (-2, 2)})), {(-k * 2, 2 * k) for k in range(15)})
        obj2 = mapply(lbind(shift, frozenset({(1, 0), (2, 0), (2, -1), (2, -2)})), {(2 * k, -k * 2) for k in range(15)})
        obj = obj1 | obj2
        objf = lambda ij: shift(obj, ij)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        ndots = unifint(diff_lb, diff_ub, (1, min(h, w)))
        succ = 0
        tr = 0
        maxtr = 4 * ndots
        bgc, dotc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        fullinds = asindices(gi)
        while tr < maxtr and succ < ndots:
            tr += 1
            if len(inds) == 0:
                break
            loc = choice(totuple(inds))
            objx = objf(loc)
            if (objx & fullinds).issubset(inds):
                succ += 1
                inds = (inds - objx) - {loc}
                gi = fill(gi, dotc, {loc})
                go = fill(go, dotc, {loc})
                go = fill(go, 5, objx)
        return {'input': gi, 'output': go}

    def generate_a3325580(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nobjs = unifint(diff_lb, diff_ub, (1, 9))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ccols = sample(remcols, nobjs)
        gi = canvas(bgc, (h, w))
        lmocc = set()
        inds = asindices(gi)
        succ = 0
        tr = 0
        maxtr = 4 * nobjs
        seenobjs = set()
        mxncells = randint(nobjs+1, 30)
        while succ < nobjs and tr < maxtr:
            tr += 1
            oh = randint(1, 6)
            ow = randint(1, 6)
            while oh * ow < mxncells:
                oh = randint(1, 6)
                ow = randint(1, 6)
            bounds = asindices(canvas(-1, (oh, ow)))
            ncells = randint(1, oh * ow)
            ncells = unifint(diff_lb, diff_ub, (1, min(oh * ow, mxncells)))
            ncells = unifint(diff_lb, diff_ub, (ncells, min(oh * ow, mxncells)))
            sp = choice(totuple(bounds))
            obj = {sp}
            for k in range(ncells - 1):
                obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))
            if obj in seenobjs:
                continue
            obj = normalize(obj)
            oh, ow = shape(obj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow and ij[1] not in lmocc)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            if plcd.issubset(inds):
                inds = (inds - plcd) - mapply(dneighbors, plcd)
                gi = fill(gi, ccols[succ], plcd)
                succ += 1
                lmocc.add(loc[1])
        objs = objects(gi, T, F, T)
        mxncells = valmax(objs, size)
        objs = sfilter(objs, matcher(size, mxncells))
        objs = order(objs, leftmost)
        go = canvas(-1, (mxncells, len(objs)))
        for idx, o in enumerate(objs):
            go = fill(go, color(o), connect((0, idx), (mxncells - 1, idx)))
        return {'input': gi, 'output': go}

    def generate_1fad071e(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(1, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nbl = randint(0, 5)
        nobjs = unifint(diff_lb, diff_ub, (nbl, max(nbl, (h * w) // 10)))
        bgc, otherc = sample(cols, 2)
        succ = 0
        tr = 0
        maxtr = 5 * nobjs
        bcount = 0
        gi = canvas(bgc, (h, w))
        inds = asindices(gi)
        ofcfrbinds = {1: set(), otherc: set()}
        while succ < nobjs and tr < maxtr:
            tr += 1
            col = choice((1, otherc))
            oh = randint(1, 3)
            ow = randint(1, 3)
            if bcount < nbl:
                col = 1
                oh, ow = 2, 2
            else:
                while col == 1 and oh == ow == 2:
                    col = choice((1, otherc))
                    oh = randint(1, 3)
                    ow = randint(1, 3)
            bd = backdrop(frozenset({(0, 0), (oh - 1, ow - 1)}))
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            bd = shift(bd, loc)
            if bd.issubset(inds) and len(mapply(dneighbors, bd) & ofcfrbinds[col]) == 0:
                succ += 1
                inds = inds - bd
                ofcfrbinds[col] = ofcfrbinds[col] | mapply(dneighbors, bd) | bd
                gi = fill(gi, col, bd)
                if col == 1 and oh == ow == 2:
                    bcount += 1
        go = (repeat(1, bcount) + repeat(bgc, 5 - bcount),)
        return {'input': gi, 'output': go}

    def generate_27a28665(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        mapping = [
        (1, {(0, 0), (0, 1), (1, 0), (1, 2), (2, 1)}),
        (2, {(0, 0), (1, 1), (2, 0), (0, 2), (2, 2)}),
        (3, {(2, 0), (0, 1), (0, 2), (1, 1), (1, 2)}),
        (6, {(1, 1), (0, 1), (1, 0), (1, 2), (2, 1)})
        ]
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        col, obj = choice(mapping)
        bgc, objc = sample(cols, 2)
        fac = unifint(diff_lb, diff_ub, (1, min(h, w) // 3))
        go = canvas(col, (1, 1))
        gi = canvas(bgc, (h, w))
        canv = canvas(bgc, (3, 3))
        canv = fill(canv, objc, obj)
        canv = upscale(canv, fac)
        obj = asobject(canv)
        loci = randint(0, h - 3 * fac)
        locj = randint(0, w - 3 * fac)
        loc = (loci, locj)
        gi = paint(gi, shift(obj, loc))
        return {'input': gi, 'output': go}

    def generate_b775ac94(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        gi = canvas(0, (1, 1))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 25))
        succ = 0
        tr = 0
        maxtr = 5 * nobjs
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while succ < nobjs and tr < maxtr:
            tr += 1
            oh = randint(2, 5)
            ow = randint(2, 5)
            canv = canvas(bgc, (oh, ow))
            c1, c2, c3, c4 = sample(remcols, 4)
            obj = {(0, 0)}
            ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))
            ncells = choice((ncellsd, oh * ow - ncellsd))
            ncells = min(max(1, ncells), oh * ow - 1)
            bounds = asindices(canv)
            for k in range(ncells):
                obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))
            gLR = fill(canv, c1, obj)
            gLL = replace(vmirror(gLR), c1, c2)
            gUR = replace(hmirror(gLR), c1, c3)
            gUL = replace(vmirror(hmirror(gLR)), c1, c4)
            gU = hconcat(gUL, gUR)
            gL = hconcat(gLL, gLR)
            g = vconcat(gU, gL)
            g2 = canvas(bgc, (oh * 2, ow * 2))
            g2 = fill(g2, c1, shift(obj, (oh, ow)))
            nkeepcols = unifint(diff_lb, diff_ub, (1, 3))
            keepcols = sample((c2, c3, c4), nkeepcols)
            for cc in (c2, c3, c4):
                if cc not in keepcols:
                    g = replace(g, cc, bgc)
                else:
                    ofsi = -1 if cc in (c3, c4) else 0
                    ofsj = -1 if cc in (c2, c4) else 0
                    g2 = fill(g2, cc, {(oh + ofsi, ow + ofsj)})
            rotf = choice((identity, rot90, rot180, rot270))
            g = rotf(g)
            g2 = rotf(g2)
            obji = asobject(g2)
            objo = asobject(g)
            objo = sfilter(objo, lambda cij: cij[0] != bgc)
            obji = sfilter(obji, lambda cij: cij[0] != bgc)
            tonorm = invert(ulcorner(objo))
            obji = shift(obji, tonorm)
            objo = shift(objo, tonorm)
            oh, ow = shape(objo)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            plcdi = shift(obji, loc)
            plcdo = shift(objo, loc)
            plcdoi = toindices(plcdo)
            if plcdoi.issubset(inds):
                succ += 1
                inds = (inds - plcdoi) - mapply(neighbors, plcdoi)
                gi = paint(gi, plcdi)
                go = paint(go, plcdo)
        return {'input': gi, 'output': go}

    def generate_6f8cd79b(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, ncols)
        ncells = unifint(diff_lb, diff_ub, (0, h * w))
        inds = asindices(gi)
        cells = sample(totuple(inds), ncells)
        obj = {(choice(ccols), ij) for ij in cells}
        gi = paint(gi, obj)
        brd = box(inds)
        go = fill(gi, 8, brd)
        return {'input': gi, 'output': go}

    def generate_de1cd16c(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        noisec = choice(cols)
        remcols = remove(noisec, cols)
        ncols = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, ncols)
        starterc = ccols[0]
        ccols = ccols[1:]
        gi = canvas(starterc, (h, w))
        for k in range(ncols - 1):
            objs = objects(gi, T, F, F)
            objs = sfilter(objs, lambda o: height(o) > 5 or width(o) > 5)
            if len(objs) == 0:
                break
            objs = totuple(objs)
            obj = choice(objs)
            if height(obj) > 5 and width(obj) > 5:
                ax = choice((0, 1))
            elif height(obj) > 5:
                ax = 0
            elif width(obj) > 5:
                ax = 1
            if ax == 0:
                loci = randint(uppermost(obj)+3, lowermost(obj)-2)
                newobj = sfilter(toindices(obj), lambda ij: ij[0] >= loci)
            elif ax == 1:
                locj = randint(leftmost(obj)+3, rightmost(obj)-2)
                newobj = sfilter(toindices(obj), lambda ij: ij[1] >= locj)
            gi = fill(gi, ccols[k], newobj)
        objs = order(objects(gi, T, F, F), size)
        allowances = [max(1, ((height(o) - 2) * (width(o) - 2)) // 2) for o in objs]
        meann = max(1, int(sum(allowances) / len(allowances)))
        chosens = [randint(0, min(meann, allowed)) for allowed in allowances]
        while max(chosens) == 0:
            chosens = [randint(0, min(meann, allowed)) for allowed in allowances]
        mx = max(chosens)
        fixinds = [idx for idx, cnt in enumerate(chosens) if cnt == mx]
        gogoind = fixinds[0]
        gogocol = color(objs[gogoind])
        fixinds = fixinds[1:]
        for idx in fixinds:
            chosens[idx] -= 1
        for obj, cnt in zip(objs, chosens):
            locs = sample(totuple(backdrop(inbox(toindices(obj)))), cnt)
            gi = fill(gi, noisec, locs)
        go = canvas(gogocol, (1, 1))
        return {'input': gi, 'output': go}

    def generate_6cf79266(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (0, 1))
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        nfgcs = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(cols, nfgcs)
        gi = canvas(-1, (h, w))
        fgcobj = {(choice(ccols), ij) for ij in asindices(gi)}
        gi = paint(gi, fgcobj)
        num = unifint(diff_lb, diff_ub, (int(0.25 * h * w), int(0.6 * h * w)))
        inds = asindices(gi)
        locs = sample(totuple(inds), num)
        gi = fill(gi, 0, locs)
        noccs = unifint(diff_lb, diff_ub, (1, (h * w) // 16))
        cands = asindices(canvas(-1, (h - 2, w - 2)))
        locs = sample(totuple(cands), noccs)
        mini = asindices(canvas(-1, (3, 3)))
        for ij in locs:
            gi = fill(gi, 0, shift(mini, ij))
        trg = recolor(0, mini)
        occs = occurrences(gi, trg)
        go = tuple(e for e in gi)
        for occ in occs:
            go = fill(go, 1, shift(mini, occ))
        return {'input': gi, 'output': go}

    def generate_a85d4709(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 3, 4))
        h = unifint(diff_lb, diff_ub, (2, 30))
        w3 = unifint(diff_lb, diff_ub, (1, 10))
        w = w3 * 3
        bgc, dotc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        for ii in range(h):
            loc = randint(0, w3 - 1)
            dev = unifint(diff_lb, diff_ub, (0, w3 // 2 + 1))
            loc = w3 // 3 + choice((+dev, -dev))
            loc = min(max(0, loc), w3 - 1)
            ofs, col = choice(((0, 2), (1, 4), (2, 3)))
            loc += ofs * w3
            gi = fill(gi, dotc, {(ii, loc)})
            ln = connect((ii, 0), (ii, w - 1))
            go = fill(go, col, ln)
        return {'input': gi, 'output': go}

    def generate_f8a8fe49(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        fullh = unifint(diff_lb, diff_ub, (10, h))
        fullw = unifint(diff_lb, diff_ub, (3, w))
        bgc, objc, boxc = sample(cols, 3)
        bcanv = canvas(bgc, (h, w))
        loci = randint(0, h - fullh)
        locj = randint(0, w - fullw)
        loc = (loci, locj)
        canvi = canvas(bgc, (fullh, fullw))
        canvo = canvas(bgc, (fullh, fullw))
        objh = (fullh // 2 - 3) // 2
        br = connect((objh + 1, 0), (objh + 1, fullw - 1))
        br = br | {(objh + 2, 0), (objh + 2, fullw - 1)}
        cands = backdrop(frozenset({(0, 1), (objh - 1, fullw - 2)}))
        for k in range(2):
            canvi = fill(canvi, boxc, br)
            canvo = fill(canvo, boxc, br)
            ncellsd = unifint(diff_lb, diff_ub, (0, (objh * (fullw - 2)) // 2))
            ncells = choice((ncellsd, objh * (fullw - 2) - ncellsd))
            ncells = min(max(1, ncells), objh * (fullw - 2))
            cells = frozenset(sample(totuple(cands), ncells))
            cells = insert(choice(totuple(sfilter(cands, lambda ij: ij[0] == lowermost(cands)))), cells)
            canvi = fill(canvi, objc, cells)
            canvo = fill(canvo, objc, shift(hmirror(cells), (objh + 3, 0)))
            canvi = hmirror(canvi)
            canvo = hmirror(canvo)
        gi = paint(bcanv, shift(asobject(canvi), loc))
        go = paint(bcanv, shift(asobject(canvo), loc))
        if choice((True, False)):
            gi = dmirror(gi)
            go = dmirror(go)
        go, gi = gi, go
        return {'input': gi, 'output': go}

    def generate_f8c80d96(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(5, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        ow = randint(1, 3 if h > 10 else 2)
        oh = randint(1, 3 if w > 10 else 2)
        loci = randint(-oh+1, h-1)
        locj = randint(-ow+1, w-1)
        obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
        bgc, linc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(5, (h, w))
        ln1 = outbox(obj)
        ulci, ulcj = decrement(ulcorner(obj))
        lrci, lrcj = increment(lrcorner(obj))
        hoffs = randint(2, 4 if h > 12 else 3)
        woffs = randint(2, 4 if w > 12 else 3)
        lns = []
        for k in range(max(h, w) // min(hoffs, woffs) + 1):
            lnx = box(frozenset({(ulci - hoffs * k, ulcj - woffs * k), (lrci + hoffs * k, lrcj + woffs * k)}))
            lns.append(lnx)
        inds = asindices(gi)
        lns = sfilter(lns, lambda ln: len(ln & inds) > 0)
        nlns = len(lns)
        nmissing = unifint(diff_lb, diff_ub, (0, nlns - 2))
        npresent = nlns - nmissing
        for k in range(npresent):
            gi = fill(gi, linc, lns[k])
        for ln in lns:
            go = fill(go, linc, ln)
        return {'input': gi, 'output': go}

    def generate_f35d900a(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(5, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (4, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        bgc, c1, c2 = sample(cols, 3)
        oh = unifint(diff_lb, diff_ub, (4, h))
        ow = unifint(diff_lb, diff_ub, (4, w))
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        gi = fill(gi, c1, {ulcorner(bx), lrcorner(bx)})
        gi = fill(gi, c2, {urcorner(bx), llcorner(bx)})
        go = fill(go, c1, {ulcorner(bx), lrcorner(bx)})
        go = fill(go, c2, {urcorner(bx), llcorner(bx)})
        go = fill(go, c1, neighbors(urcorner(bx)) | neighbors(llcorner(bx)))
        go = fill(go, c2, neighbors(ulcorner(bx)) | neighbors(lrcorner(bx)))
        crns = corners(bx)
        for c in crns:
            cobj = {c}
            remcorns = remove(c, crns)
            belongto = sfilter(bx, lambda ij: manhattan(cobj, {ij}) <= valmin(remcorns, lambda cc: manhattan({ij}, {cc})))
            valids = sfilter(belongto, lambda ij: manhattan(cobj, {ij}) > 1 and manhattan(cobj, {ij}) % 2 == 0)
            go = fill(go, 5, valids)
        return {'input': gi, 'output': go}

    def generate_ec883f72(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        ohi = unifint(diff_lb, diff_ub, (0, h - 6))
        owi = unifint(diff_lb, diff_ub, (0, w - 6))
        oh = h - 5 - ohi
        ow = w - 5 - owi
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        bgc, sqc, linc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        obj = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
        gi = fill(gi, sqc, obj)
        obob = outbox(outbox(obj))
        gi = fill(gi, linc, obob)
        ln1 = shoot(lrcorner(obob), (1, 1))
        ln2 = shoot(ulcorner(obob), (-1, -1))
        ln3 = shoot(llcorner(obob), (1, -1))
        ln4 = shoot(urcorner(obob), (-1, 1))
        lns = (ln1 | ln2 | ln3 | ln4) & ofcolor(gi, bgc)
        go = fill(gi, sqc, lns)
        return {'input': gi, 'output': go}

    def generate_ea786f4a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (1, 14))
        w = unifint(diff_lb, diff_ub, (1, 14))
        mp = (h, w)
        h = 2 * h + 1
        w = 2 * w + 1
        linc = choice(cols)
        remcols = remove(linc, cols)
        gi = canvas(linc, (h, w))
        inds = remove(mp, asindices(gi))
        ncols = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, ncols)
        obj = {(choice(ccols), ij) for ij in inds}
        gi = paint(gi, obj)
        ln1 = shoot(mp, (-1, -1))
        ln2 = shoot(mp, (1, 1))
        ln3 = shoot(mp, (-1, 1))
        ln4 = shoot(mp, (1, -1))
        go = fill(gi, linc, ln1 | ln2 | ln3 | ln4)
        return {'input': gi, 'output': go}

    def generate_ded97339(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc, linc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        ndots = unifint(diff_lb, diff_ub, (2, (h * w) // 9))
        inds = asindices(gi)
        dots = set()
        if choice((True, False)):
            idxi = randint(0, h - 1)
            locj1 = randint(0, w - 3)
            locj2 = randint(locj1 + 2, w - 1)
            dots.add((idxi, locj1))
            dots.add((idxi, locj2))
        else:
            idxj = randint(0, w - 1)
            loci1 = randint(0, h - 3)
            loci2 = randint(loci1 + 2, h - 1)
            dots.add((loci1, idxj))
            dots.add((loci2, idxj))
        for k in range(ndots - 2):
            if len(inds) == 0:
                break
            loc = choice(totuple(inds))
            dots.add(loc)
            inds = (inds - {loc}) - neighbors(loc)
        gi = fill(gi, linc, dots)
        go = tuple(e for e in gi)
        for ii, r in enumerate(gi):
            if r.count(linc) > 1:
                a = r.index(linc)
                b = w - r[::-1].index(linc) - 1
                go = fill(go, linc, connect((ii, a), (ii, b)))
        go = dmirror(go)
        gi = dmirror(gi)
        for ii, r in enumerate(gi):
            if r.count(linc) > 1:
                a = r.index(linc)
                b = h - r[::-1].index(linc) - 1
                go = fill(go, linc, connect((ii, a), (ii, b)))
        return {'input': gi, 'output': go}

    def generate_d687bc17(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        bgc, c1, c2, c3, c4 = sample(cols, 5)
        gi = canvas(bgc, (h, w))
        gi = fill(gi, c1, connect((0, 0), (0, w - 1)))
        gi = fill(gi, c2, connect((0, 0), (h - 1, 0)))
        gi = fill(gi, c3, connect((h - 1, w - 1), (0, w - 1)))
        gi = fill(gi, c4, connect((h - 1, w - 1), (h - 1, 0)))
        inds = asindices(gi)
        gi = fill(gi, bgc, corners(inds))
        go = tuple(e for e in gi)
        cands = backdrop(inbox(inbox(inds)))
        ndots = unifint(diff_lb, diff_ub, (1, min(len(cands), h + h + w + w)))
        dots = sample(totuple(cands), ndots)
        dots = {(choice((c1, c2, c3, c4)), ij) for ij in dots}
        n1 = toindices(sfilter(dots, lambda cij: cij[0] == c1))
        n1coverage = apply(last, n1)
        if len(n1coverage) == w - 4 and w > 5:
            n1coverage = remove(choice(totuple(n1coverage)), n1coverage)
        for jj in n1coverage:
            loci = choice([ij[0] for ij in sfilter(n1, lambda ij: ij[1] == jj)])
            gi = fill(gi, c1, {(loci, jj)})
            go = fill(go, c1, {(1, jj)})
        n2 = toindices(sfilter(dots, lambda cij: cij[0] == c2))
        n2coverage = apply(first, n2)
        if len(n2coverage) == h - 4 and h > 5:
            n2coverage = remove(choice(totuple(n2coverage)), n2coverage)
        for ii in n2coverage:
            locj = choice([ij[1] for ij in sfilter(n2, lambda ij: ij[0] == ii)])
            gi = fill(gi, c2, {(ii, locj)})
            go = fill(go, c2, {(ii, 1)})
        n3 = toindices(sfilter(dots, lambda cij: cij[0] == c4))
        n3coverage = apply(last, n3)
        if len(n3coverage) == w - 4 and w > 5:
            n3coverage = remove(choice(totuple(n3coverage)), n3coverage)
        for jj in n3coverage:
            loci = choice([ij[0] for ij in sfilter(n3, lambda ij: ij[1] == jj)])
            gi = fill(gi, c4, {(loci, jj)})
            go = fill(go, c4, {(h - 2, jj)})
        n4 = toindices(sfilter(dots, lambda cij: cij[0] == c3))
        n4coverage = apply(first, n4)
        if len(n4coverage) == h - 4 and h > 5:
            n4coverage = remove(choice(totuple(n4coverage)), n4coverage)
        for ii in n4coverage:
            locj = choice([ij[1] for ij in sfilter(n4, lambda ij: ij[0] == ii)])
            gi = fill(gi, c3, {(ii, locj)})
            go = fill(go, c3, {(ii, w - 2)})
        noisecands = ofcolor(gi, bgc)
        noisecols = difference(cols, (bgc, c1, c2, c3, c4))
        nnoise = unifint(diff_lb, diff_ub, (0, len(noisecands)))
        ub = ((h * w) - 2 * h - 2 * (w - 2)) // 2 - ndots - 1
        nnoise = unifint(diff_lb, diff_ub, (0, max(0, ub)))
        noise = sample(totuple(noisecands), nnoise)
        noiseobj = {(choice(noisecols), ij) for ij in noise}
        gi = paint(gi, noiseobj)
        return {'input': gi, 'output': go}

    def generate_d90796e8(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (8, 2, 3))
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc, noisec = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        nocc = unifint(diff_lb, diff_ub, (1, (h * w) // 3))
        inds = asindices(gi)
        locs = sample(totuple(inds), nocc)
        obj = frozenset({(choice((noisec, 2, 3)), ij) for ij in locs})
        gi = paint(gi, obj)
        fixloc = choice(totuple(inds))
        fixloc2 = choice(totuple(dneighbors(fixloc) & inds))
        gi = fill(gi, 2, {fixloc})
        gi = fill(gi, 3, {fixloc2})
        go = tuple(e for e in gi)
        reds = ofcolor(gi, 2)
        greens = ofcolor(gi, 3)
        tocover = set()
        tolblue = set()
        for r in reds:
            inters = dneighbors(r) & greens
            if len(inters) > 0:
                tocover.add(r)
                tolblue = tolblue | inters
        go = fill(go, bgc, tocover)
        go = fill(go, 8, tolblue)
        return {'input': gi, 'output': go}

    def generate_a68b268e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 14))
        w = unifint(diff_lb, diff_ub, (2, 4))
        bgc, linc, c1, c2, c3, c4 = sample(cols, 6)
        canv = canvas(bgc, (h, w))
        inds = asindices(canv)
        nc1d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        nc1 = choice((nc1d, h * w - nc1d))
        nc1 = min(max(1, nc1), h * w - 1)
        nc2d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        nc2 = choice((nc2d, h * w - nc2d))
        nc2 = min(max(1, nc2), h * w - 1)
        nc3d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        nc3 = choice((nc3d, h * w - nc3d))
        nc3 = min(max(1, nc3), h * w - 1)
        nc4d = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        nc4 = choice((nc4d, h * w - nc4d))
        nc4 = min(max(1, nc4), h * w - 1)
        ofc1 = sample(totuple(inds), nc1)
        ofc2 = sample(totuple(inds), nc2)
        ofc3 = sample(totuple(inds), nc3)
        ofc4 = sample(totuple(inds), nc4)
        go = fill(canv, c1, ofc1)
        go = fill(go, c2, ofc2)
        go = fill(go, c3, ofc3)
        go = fill(go, c4, ofc4)
        LR = asobject(fill(canv, c1, ofc1))
        LL = asobject(fill(canv, c2, ofc2))
        UR = asobject(fill(canv, c3, ofc3))
        UL = asobject(fill(canv, c4, ofc4))
        gi = canvas(linc, (2*h+1, 2*w+1))
        gi = paint(gi, shift(LR, (h+1, w+1)))
        gi = paint(gi, shift(LL, (h+1, 0)))
        gi = paint(gi, shift(UR, (0, w+1)))
        gi = paint(gi, shift(UL, (0, 0)))
        return {'input': gi, 'output': go}

    def generate_ea32f347(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 4))
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        a = unifint(diff_lb, diff_ub, (3, 30))
        b = unifint(diff_lb, diff_ub, (2, a))
        c = unifint(diff_lb, diff_ub, (1, b))
        if c - a == 2:
            if a > 1:
                a -= 1
            elif c < min(h, w):
                c += 1
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        for col, l in zip((1, 4, 2), (a, b, c)):
            ln1 = connect((0, 0), (0, l - 1))
            ln2 = connect((0, 0), (l - 1, 0))
            tmpg = fill(gi, -1, asindices(gi) - inds)
            occs1 = occurrences(tmpg, recolor(bgc, ln1))
            occs2 = occurrences(tmpg, recolor(bgc, ln2))
            pool = []
            if len(occs1) > 0:
                pool.append((ln1, occs1))
            if len(occs2) > 0:
                pool.append((ln2, occs2))
            ln, occs = choice(pool)
            loc = choice(totuple(occs))
            plcd = shift(ln, loc)
            gi = fill(gi, choice(remcols), plcd)
            go = fill(go, col, plcd)
            inds = (inds - plcd) - mapply(dneighbors, plcd)
        return {'input': gi, 'output': go}

    def generate_e179c5f4(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        w = unifint(diff_lb, diff_ub, (2, 10))
        h = unifint(diff_lb, diff_ub, (w+1, 30))
        bgc, linc = sample(cols, 2)
        c = canvas(bgc, (h, w))
        sp = (h - 1, 0)
        gi = fill(c, linc, {sp})
        go = tuple(e for e in gi)
        changing = True
        direc = 1
        while True:
            sp = add(sp, (-1, direc))
            if sp[1] == w - 1 or sp[1] == 0:
                direc *= -1
            go2 = fill(go, linc, {sp})
            if go2 == go:
                break
            go = go2
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        gix = tuple(e for e in gi)
        gox = tuple(e for e in go)
        numlins = unifint(diff_lb, diff_ub, (1, 4))
        if numlins > 1:
            gi = fill(gi, linc, ofcolor(hmirror(gix), linc))
            go = fill(go, linc, ofcolor(hmirror(gox), linc))
        if numlins > 2:
            gi = fill(gi, linc, ofcolor(vmirror(gix), linc))
            go = fill(go, linc, ofcolor(vmirror(gox), linc))
        if numlins > 3:
            gi = fill(gi, linc, ofcolor(hmirror(vmirror(gix)), linc))
            go = fill(go, linc, ofcolor(hmirror(vmirror(gox)), linc))
        go = replace(go, bgc, 8)
        return {'input': gi, 'output': go}

    def generate_aba27056(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        bgc, sqc = sample(cols, 2)
        canv = canvas(bgc, (h, w))
        oh = randint(3, h)
        ow = unifint(diff_lb, diff_ub, (5, w - 1))
        loci = unifint(diff_lb, diff_ub, (0, h - oh))
        locj = randint(0, w - ow)
        bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
        maxk = (ow - 4) // 2
        k = randint(0, maxk)
        hole = connect((loci, locj + 2 + k), (loci, locj + ow - 3 - k))
        gi = fill(canv, sqc, bx)
        gi = fill(gi, bgc, hole)
        go = fill(canv, 4, backdrop(bx))
        go = fill(go, sqc, bx)
        bar = mapply(rbind(shoot, (-1, 0)), hole)
        go = fill(go, 4, bar)
        go = fill(go, 4, shoot(add((-1, 1), urcorner(hole)), (-1, 1)))
        go = fill(go, 4, shoot(add((-1, -1), ulcorner(hole)), (-1, -1)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_e40b9e2f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)  
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        d = unifint(diff_lb, diff_ub, (4, min(h, w) - 2))
        loci = randint(0, h - d)
        locj = randint(0, w - d)
        loc = (loci, locj)
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, numcols)
        subg = canvas(bgc, (d, d))
        inds = asindices(subg)
        if d % 2 == 0:
            q = sfilter(inds, lambda ij: ij[0] < d//2 and ij[1] < d//2)
            cp = {(d//2-1, d//2-1), (d//2, d//2-1), (d//2-1, d//2), (d//2, d//2)}
        else:
            q = sfilter(inds, lambda ij: ij[0] < d//2 and ij[1] <= d//2)
            cp = {(d//2, d//2)} | ineighbors((d//2, d//2))
        nrings = unifint(diff_lb, diff_ub, (1, max(1, (d-2)//2)))
        rings = set()
        for k in range(nrings):
            ring = box({(k, k), (d-k-1, d-k-1)})
            rings = rings | ring
        qin = q - rings
        qout = rings & q
        ntailobjcells = unifint(diff_lb, diff_ub, (1, len(q)))
        tailobjcells = sample(totuple(q), ntailobjcells)
        tailobjcells = set(tailobjcells) | {choice(totuple(qin))} | {choice(totuple(qout))}
        tailobj = {(choice(ccols), ij) for ij in tailobjcells}
        while hmirror(tailobj) == tailobj and vmirror(tailobj) == tailobj:
            ntailobjcells = unifint(diff_lb, diff_ub, (1, len(q)))
            tailobjcells = sample(totuple(q), ntailobjcells)
            tailobjcells = set(tailobjcells) | {choice(totuple(qin))} | {choice(totuple(qout))}
            tailobj = {(choice(ccols), ij) for ij in tailobjcells}
        for k in range(4):
            subg = paint(subg, tailobj)
            subg = rot90(subg)
        fxobj = recolor(choice(ccols), cp)
        subg = paint(subg, fxobj)
        subgi = subg
        subgo = tuple(e for e in subgi)
        subgi = fill(subgi, bgc, rings)
        nsplits = unifint(diff_lb, diff_ub, (1, 4))
        splits = [set() for k in range(nsplits)]
        for idx, cel in enumerate(tailobj):
            splits[idx%nsplits].add(cel)
        for jj in range(4):
            if jj < len(splits):
                subgi = paint(subgi, splits[jj])
            subgi = rot90(subgi)
        subgi = paint(subgi, fxobj)
        rotf = choice((identity, rot90, rot180, rot270))
        subgi = rotf(subgi)
        subgo = rotf(subgo)
        gi = paint(canvas(bgc, (h, w)), shift(asobject(subgi), loc))
        go = paint(canvas(bgc, (h, w)), shift(asobject(subgo), loc))
        return {'input': gi, 'output': go}

    def generate_e8dc4411(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)  
        h = unifint(diff_lb, diff_ub, (9, 30))
        w = unifint(diff_lb, diff_ub, (9, 30))
        d = unifint(diff_lb, diff_ub, (3, min(h, w)//2-1))
        bgc, objc, remc = sample(cols, 3)
        c = canvas(bgc, (d, d))
        inds = sfilter(asindices(c), lambda ij: ij[0]>=d//2 and ij[1]>=d//2)
        ncd = unifint(diff_lb, diff_ub, (1, len(inds)//2))
        nc = choice((ncd, len(inds)-ncd))
        nc = min(max(2, nc), len(inds) - 1)
        cells = sample(totuple(inds), nc)
        cells = set(cells) | {choice(((d//2, d//2), (d//2, d//2-1)))}
        cells = cells | {(jj, ii) for ii, jj in cells}
        for k in range(4):
            c = fill(c, objc, cells)
            c = rot90(c)
        while palette(toobject(box(asindices(c)), c)) == frozenset({bgc}) and height(c) > 3:
            c = trim(c)
        obj = ofcolor(c, objc)
        od = height(obj)
        loci = randint(1, h - 2*od)
        locj = randint(1, w - 2*od)
        obj = shift(obj, (loci, locj))
        bd = backdrop(obj)
        p = 0
        while len(shift(obj, (p, p)) & bd) > 0:
            p += 1
        obj2 = shift(obj, (p, p))
        nbhs = mapply(neighbors, obj)
        while len(obj2 & nbhs) == 0:
            nbhs = mapply(neighbors, nbhs)
        indic = obj2 & nbhs
        gi = canvas(bgc, (h, w))
        gi = fill(gi, objc, obj)
        gi = fill(gi, remc, indic)
        go = tuple(e for e in gi)
        for k in range(30):
            newg = fill(go, remc, shift(obj, (p*(k+1), p*(k+1))))
            if newg == go:
                break
            go = newg
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_ddf7fa4f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)  
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nocc = unifint(diff_lb, diff_ub, (1, min(w // 3, (h * w) // 36)))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        succ = 0
        tr = 0
        maxtr = 10 * nocc
        inds = asindices(gi)
        inds = sfilter(inds, lambda ij: ij[0] > 1)
        while succ < nocc and tr < maxtr:
            tr += 1
            oh = randint(2, 7)
            ow = randint(2, 7)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            hastobein = {cidx for cidx, col in enumerate(gi[0]) if col == bgc}
            cantbein = {cidx for cidx, col in enumerate(gi[0]) if col != bgc}
            jopts = [j for j in range(w) if \
                len(set(interval(j, j + ow, 1)) & hastobein) > 0 and len(set(interval(j, j + ow, 1)) & cantbein) == 0
            ]
            cands = sfilter(cands, lambda ij: ij[1] in jopts)
            if len(cands) == 0:
                continue
            loci, locj = choice(totuple(cands))
            locat = choice(sfilter(interval(locj, locj + ow, 1), lambda jj: jj in hastobein))
            sq = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            if sq.issubset(inds):
                succ += 1
                inds = (inds - sq) - mapply(dneighbors, sq)
                col = choice(remcols)
                gr = choice(remove(col, remcols))
                gi = fill(gi, col, {(0, locat)})
                go = fill(go, col, {(0, locat)})
                gi = fill(gi, gr, sq)
                go = fill(go, col, sq)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_d07ae81c(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        lnf = lambda ij: shoot(ij, (1, 1)) | shoot(ij, (-1, -1)) | shoot(ij, (-1, 1)) | shoot(ij, (1, -1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        c1, c2, c3, c4 = sample(cols, 4)
        magiccol = 0
        gi = canvas(0, (h, w))
        ndivi = unifint(diff_lb, diff_ub, (1, (h * w) // 10))
        for k in range(ndivi):
            objs = objects(gi, T, F, F)
            objs = sfilter(objs, lambda o: min(shape(o)) > 3 and max(shape(o)) > 4)
            objs = sfilter(objs, lambda o: height(o) * width(o) == len(o))
            if len(objs) == 0:
                break
            obj = choice(totuple(objs))
            if choice((True, False)):
                loci = randint(uppermost(obj)+2, lowermost(obj)-1)
                newobj = backdrop(frozenset({(loci, leftmost(obj)), lrcorner(obj)}))
            else:
                locj = randint(leftmost(obj)+2, rightmost(obj)-1)
                newobj = backdrop(frozenset({(uppermost(obj), locj), lrcorner(obj)}))
            magiccol += 1
            gi = fill(gi, magiccol, newobj)
        objs = objects(gi, T, F, F)
        for ii, obj in enumerate(objs):
            col = c1 if ii == 0 else (c2 if ii == 1 else choice((c1, c2)))
            gi = fill(gi, col, toindices(obj))
        ofc1 = ofcolor(gi, c1)
        ofc2 = ofcolor(gi, c2)
        mn = min(len(ofc1), len(ofc2))
        n1 = unifint(diff_lb, diff_ub, (1, max(1, int(mn ** 0.5))))
        n2 = unifint(diff_lb, diff_ub, (1, max(1, int(mn ** 0.5))))
        srcs1 = set()
        for k in range(n1):
            cands = totuple((ofc1 - srcs1) - mapply(neighbors, srcs1))
            if len(cands) == 0:
                break
            srcs1.add(choice(cands))
        srcs2 = set()
        for k in range(n2):
            cands = totuple((ofc2 - srcs2) - mapply(neighbors, srcs2))
            if len(cands) == 0:
                break
            srcs2.add(choice(cands))
        gi = fill(gi, c3, srcs1)
        gi = fill(gi, c4, srcs2)
        lns = mapply(lnf, srcs1) | mapply(lnf, srcs2)
        ofc3 = ofc1 & lns
        ofc4 = ofc2 & lns
        go = fill(gi, c3, ofc3)
        go = fill(go, c4, ofc4)
        return {'input': gi, 'output': go}

    def generate_b2862040(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (8,))
        while True:
            h = unifint(diff_lb, diff_ub, (10, 30))
            w = unifint(diff_lb, diff_ub, (10, 30))
            nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 16))
            succ = 0
            tr = 0
            maxtr = 10 * nobjs
            bgc = choice(cols)
            remcols = remove(bgc, cols)
            gi = canvas(bgc, (h, w))
            inds = asindices(gi)
            while succ < nobjs and tr < maxtr:
                tr += 1
                oh = randint(3, 6)
                ow = randint(3, 6)
                obj = box(frozenset({(0, 0), (oh - 1, ow - 1)}))
                if choice((True, False)):
                    nkeep = unifint(diff_lb, diff_ub, (2, len(obj) - 1))
                    nrem = len(obj) - nkeep
                    obj = remove(choice(totuple(obj - corners(obj))), obj)
                    for k in range(nrem - 1):
                        xx = sfilter(obj, lambda ij: len(dneighbors(ij) & obj) == 1)
                        if len(xx) == 0:
                            break
                        obj = remove(choice(totuple(xx)), obj)
                npert = unifint(diff_lb, diff_ub, (0, oh + ow))
                objcands = outbox(obj) | outbox(outbox(obj)) | outbox(outbox(outbox(obj)))
                obj = set(obj)
                for k in range(npert):
                    obj.add(choice(totuple((objcands - obj) & (mapply(dneighbors, obj) & objcands))))
                obj = normalize(obj)
                oh, ow = shape(obj)
                cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
                if len(cands) == 0:
                    continue
                loc = choice(totuple(cands))
                plcd = shift(obj, loc)
                if plcd.issubset(inds):
                    gi = fill(gi, choice(remcols), plcd)
                    succ += 1
                    inds = (inds - plcd) - mapply(neighbors, plcd)
            objs = objects(gi, T, F, F)
            bobjs = colorfilter(objs, bgc)
            objsm = mfilter(bobjs, compose(flip, rbind(bordering, gi)))
            if len(objsm) > 0:
                res = mfilter(objs - bobjs, rbind(adjacent, objsm))
                go = fill(gi, 8, res)
                break
        return {'input': gi, 'output': go}

    def generate_a61ba2ce(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (4, 15))
        w = unifint(diff_lb, diff_ub, (4, 15))
        lociL = randint(2, h - 2)
        lociR = randint(2, h - 2)
        locjT = randint(2, w - 2)
        locjB = randint(2, w - 2)
        bgc, c1, c2, c3, c4 = sample(cols, 5)
        ulco = connect((0, 0), (lociL - 1, 0)) | connect((0, 0), (0, locjT - 1))
        urco = connect((0, w - 1), (0, locjT)) | connect((0, w - 1), (lociR - 1, w - 1))
        llco = connect((h - 1, 0), (lociL, 0)) | connect((h - 1, 0), (h - 1, locjB - 1))
        lrco = connect((h - 1, w - 1), (h - 1, locjB)) | connect((h - 1, w - 1), (lociR, w - 1))
        go = canvas(bgc, (h, w))
        go = fill(go, c1, ulco)
        go = fill(go, c2, urco)
        go = fill(go, c3, llco)
        go = fill(go, c4, lrco)
        fullh = unifint(diff_lb, diff_ub, (2 * h, 30))
        fullw = unifint(diff_lb, diff_ub, (2 * w, 30))
        gi = canvas(bgc, (fullh, fullw))
        objs = (ulco, urco, llco, lrco)
        ocols = (c1, c2, c3, c4)
        while True:
            inds = asindices(gi)
            locs = []
            for o, c in zip(objs, ocols):
                cands = sfilter(inds, lambda ij: shift(o, ij).issubset(inds))
                if len(cands) == 0:
                    break
                loc = choice(totuple(cands))
                locs.append(loc)
                inds = inds - shift(o, loc)
            if len(locs) == 4:
                break
        for o, c, l in zip(objs, ocols, locs):
            gi = fill(gi, c, shift(o, l))
        return {'input': gi, 'output': go}

    def generate_bbc9ae5d(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        w = unifint(diff_lb, diff_ub, (2, 15))
        w = w * 2
        locinv = unifint(diff_lb, diff_ub, (2, w))
        locj = w - locinv
        loc = (0, locj)
        c1 = choice(cols)
        remcols = remove(c1, cols)
        ln1 = connect((0, 0), (0, locj))
        remobj = connect((0, locj+1), (0, w - 1))
        numc = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, numc)
        remobj = {(choice(ccols), ij) for ij in remobj}
        gi = canvas(-1, (1, w))
        go = canvas(-1, (w//2, w))
        ln2 = shoot(loc, (1, 1))
        gi = fill(gi, c1, ln1)
        gi = paint(gi, remobj)
        go = fill(go, c1, mapply(rbind(shoot, (0, -1)), ln2))
        for c, ij in remobj:
            go = fill(go, c, shoot(ij, (1, 1)))
        return {'input': gi, 'output': go}

    def generate_9edfc990(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(2, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        namt = unifint(diff_lb, diff_ub, (int(0.4 * h * w), int(0.7 * h * w)))
        gi = canvas(0, (h, w))
        inds = asindices(gi)
        locs = sample(totuple(inds), namt)
        noise = {(choice(cols), ij) for ij in locs}
        gi = paint(gi, noise)
        remlocs = inds - set(locs)
        numc = unifint(diff_lb, diff_ub, (1, max(1, len(remlocs) // 10)))
        blocs = sample(totuple(remlocs), numc)
        gi = fill(gi, 1, blocs)
        objs = objects(gi, T, F, F)
        objs = colorfilter(objs, 0)
        res = mfilter(objs, rbind(adjacent, blocs))
        go = fill(gi, 1, res)
        return {'input': gi, 'output': go}

    def generate_a78176bb(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 30))
        w = unifint(diff_lb, diff_ub, (6, 30))
        nlns = unifint(diff_lb, diff_ub, (1, (h + w) // 8))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        succ = 0
        tr = 0
        maxtr = 10 * nlns
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))       
        inds = asindices(gi)
        fullinds = asindices(gi)
        spopts = []
        for idx in range(h - 5, -1, -1):
            spopts.append((idx, 0))
        for idx in range(1, w - 4, 1):
            spopts.append((0, idx))
        while succ < nlns and tr < maxtr:
            tr += 1
            if len(spopts) == 0:
                break
            sp = choice(spopts)
            ln = shoot(sp, (1, 1)) & fullinds
            if not ln.issubset(inds):
                continue
            lno = sorted(ln, key=lambda x: x[0])
            trid1 = randint(2, min(5, len(lno)-3))
            trid2 = randint(2, min(5, len(lno)-3))
            tri1 = sfilter(asindices(canvas(-1, (trid1, trid1))), lambda ij: ij[1] >= ij[0])
            triloc1 = add(choice(lno[1:-trid1-1]), (0, 1))
            tri2 = dmirror(sfilter(asindices(canvas(-1, (trid2, trid2))), lambda ij: ij[1] >= ij[0]))
            triloc2 = add(choice(lno[1:-trid2-1]), (1, 0))
            spo2 = add(sp, (0, -trid2-2))
            nexlin2 = {add(spo2, (k, k)) for k in range(max(h, w))} & fullinds
            spo1 = add(sp, (-trid1-2, 0))
            nexlin1 = {add(spo1, (k, k)) for k in range(max(h, w))} & fullinds
            for idx, (tri, triloc, nexlin) in enumerate(sample([
                (tri1, triloc1, nexlin1),
                (tri2, triloc2, nexlin2)
            ], 2)):
                tri = shift(tri, triloc)
                fullobj = ln | tri | nexlin
                if idx == 0:
                    lncol, tricol = sample(remcols, 2)
                else:
                    tricol = choice(remove(lncol, remcols))
                if (
                    fullobj.issubset(inds) if idx == 0 else (tri | nexlin).issubset(fullobj)
                ):
                    succ += 1
                    inds = (inds - fullobj) - mapply(neighbors, fullobj)
                    gi = fill(gi, tricol, tri)
                    gi = fill(gi, lncol, ln)
                    go = fill(go, lncol, ln)
                    go = fill(go, lncol, nexlin)
        if choice((True, False)):
            gi = hmirror(gi)
            go = hmirror(go)
        return {'input': gi, 'output': go}

    def generate_995c5fa3(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        o1 = asindices(canvas(-1, (4, 4)))
        o2 = box(asindices(canvas(-1, (4, 4))))
        o3 = asindices(canvas(-1, (4, 4))) - {(1, 0), (2, 0), (1, 3), (2, 3)}
        o4 = o1 - shift(asindices(canvas(-1, (2, 2))), (2, 1))
        mpr = [(o1, 2), (o2, 8), (o3, 3), (o4, 4)]
        num = unifint(diff_lb, diff_ub, (1, 6))
        h = 4
        w = 4 * num + num - 1
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        gi = canvas(bgc, (h, w))
        ccols = []
        for k in range(num):
            col = choice(remcols)
            obj, outcol = choice(mpr)
            locj = 5 * k
            gi = fill(gi, col, shift(obj, (0, locj)))
            ccols.append(outcol)
        go = tuple(repeat(c, num) for c in ccols)
        return {'input': gi, 'output': go}

    def generate_9aec4887(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (12, 30))
        w = unifint(diff_lb, diff_ub, (12, 30))
        oh = unifint(diff_lb, diff_ub, (4, h//2-2))
        ow = unifint(diff_lb, diff_ub, (4, w//2-2))
        bgc, pc, c1, c2, c3, c4 = sample(cols, 6)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (oh, ow))
        ln1 = connect((1, 0), (oh - 2, 0))
        ln2 = connect((1, ow - 1), (oh - 2, ow - 1))
        ln3 = connect((0, 1), (0, ow - 2))
        ln4 = connect((oh - 1, 1), (oh - 1, ow - 2))
        go = fill(go, c1, ln1)
        go = fill(go, c2, ln2)
        go = fill(go, c3, ln3)
        go = fill(go, c4, ln4)
        objB = asobject(go)
        bounds = asindices(canvas(-1, (oh - 2, ow - 2)))
        objA = {choice(totuple(bounds))}
        ncells = unifint(diff_lb, diff_ub, (1, ((oh - 2) * (ow - 2)) // 2))
        for k in range(ncells - 1):
            objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))
        while shape(objA) != (oh - 2, ow - 2):
            objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))
        fullinds = asindices(gi)
        loci = randint(0, h - 2 * oh + 2)
        locj = randint(0, w - ow)
        plcdB = shift(objB, (loci, locj))
        plcdi = toindices(plcdB)
        rems = sfilter(fullinds - plcdi, lambda ij: loci + oh <= ij[0] <= h - oh + 2 and ij[1] <= w - ow + 2)
        loc = choice(totuple(rems))
        plcdA = shift(objA, loc)
        gi = paint(gi, plcdB)
        gi = fill(gi, pc, plcdA)
        objA = shift(objA, (1, 1))
        objs = objects(go, T, F, T)
        for ij in objA:
            manhs = {obj: manhattan(obj, {ij}) for obj in objs}
            manhsl = list(manhs.values())
            mmh = min(manhsl)
            if manhsl.count(mmh) == 1:
                col = color([o for o, mnh in manhs.items() if mmh == mnh][0])
            else:
                col = pc
            go = fill(go, col, {ij})
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_846bdb03(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (12, 30))
        w = unifint(diff_lb, diff_ub, (12, 30))
        oh = unifint(diff_lb, diff_ub, (4, h//2-2))
        ow = unifint(diff_lb, diff_ub, (4, w//2-2))
        bgc, dotc, c1, c2 = sample(cols, 4)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (oh, ow))
        ln1 = connect((1, 0), (oh - 2, 0))
        ln2 = connect((1, ow - 1), (oh - 2, ow - 1))
        go = fill(go, c1, ln1)
        go = fill(go, c2, ln2)
        go = fill(go, dotc, corners(asindices(go)))
        objB = asobject(go)
        bounds = asindices(canvas(-1, (oh - 2, ow - 2)))
        objA = {choice(totuple(bounds))}
        ncells = unifint(diff_lb, diff_ub, (1, ((oh - 2) * (ow - 2)) // 2))
        for k in range(ncells - 1):
            objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))
        while shape(objA) != (oh - 2, ow - 2):
            objA.add(choice(totuple((bounds - objA) & mapply(neighbors, objA))))
        fullinds = asindices(gi)
        loci = randint(0, h - 2 * oh + 2)
        locj = randint(0, w - ow)
        plcdB = shift(objB, (loci, locj))
        plcdi = toindices(plcdB)
        rems = sfilter(fullinds - plcdi, lambda ij: loci + oh <= ij[0] <= h - oh + 2 and ij[1] <= w - ow + 2)
        loc = choice(totuple(rems))
        plcdA = shift(objA, loc)
        mp = center(plcdA)[1]
        plcdAL = sfilter(plcdA, lambda ij: ij[1] < mp)
        plcdAR = plcdA - plcdAL
        plcdA = recolor(c1, plcdAL) | recolor(c2, plcdAR)
        gi = paint(gi, plcdB)
        ism = choice((True, False))
        gi = paint(gi, vmirror(plcdA) if ism else plcdA)
        objA = shift(normalize(plcdA), (1, 1))
        objs = objects(go, T, F, T)
        go = paint(go, objA)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_2dd70a9a(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 3))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        if choice((True, False)):
            oh = unifint(diff_lb, diff_ub, (5, h - 2))
            ow = unifint(diff_lb, diff_ub, (3, w - 2))
            loci = randint(1, h - oh - 1)
            locj = randint(1, w - ow - 1)
            hli = randint(loci+2, loci+oh-3)
            sp = {(loci+oh-1, locj), (loci+oh-2, locj)}
            ep = {(loci, locj+ow-1), (loci+1, locj+ow-1)}
            bp1 = (hli-1, locj)
            bp2 = (hli, locj+ow)
            ln1 = connect((loci+oh-1, locj), (hli, locj))
            ln2 = connect((hli, locj), (hli, locj+ow-1))
            ln3 = connect((hli, locj+ow-1), (loci+2, locj+ow-1))
        else:
            oh = unifint(diff_lb, diff_ub, (3, h-2))
            ow = unifint(diff_lb, diff_ub, (3, w-2))
            loci = randint(1, h - oh - 1)
            locj = randint(1, w - ow - 1)
            if choice((True, False)):
                sp1j = randint(locj, locj+ow-3)
                ep1j = locj
            else:
                ep1j = randint(locj, locj+ow-3)
                sp1j = locj
            sp = {(loci, sp1j), (loci, sp1j+1)}
            ep = {(loci+oh-1, ep1j), (loci+oh-1, ep1j+1)}
            bp1 = (loci, locj+ow)
            bp2 = (loci+oh, locj+ow-1)
            ln1 = connect((loci, sp1j+2), (loci, locj+ow-1))
            ln2 = connect((loci, locj+ow-1), (loci+oh-1, locj+ow-1))
            ln3 = connect((loci+oh-1, ep1j+2), (loci+oh-1, locj+ow-1))
        gi = fill(gi, 3, sp)
        gi = fill(gi, 2, ep)
        go = fill(go, 3, sp)
        go = fill(go, 2, ep)
        lns = ln1 | ln2 | ln3
        bps = {bp1, bp2}
        gi = fill(gi, fgc, bps)
        go = fill(go, fgc, bps)
        go = fill(go, 3, lns)
        inds = ofcolor(go, bgc)
        namt = unifint(diff_lb, diff_ub, (0, len(inds) // 2))
        noise = sample(totuple(inds), namt)
        gi = fill(gi, fgc, noise)
        go = fill(go, fgc, noise)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_36fdfd69(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (4,))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nobjs = unifint(diff_lb, diff_ub, (1, (h * w) // 30))
        bgc, fgc, objc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        inds = asindices(gi)
        succ = 0
        tr = 0
        maxtr = 5 * nobjs
        namt = randint(int(0.35 * h * w), int(0.65 * h * w))
        noise = sample(totuple(inds), namt)
        gi = fill(gi, fgc, noise)
        go = tuple(e for e in gi)
        while succ < nobjs and tr < maxtr:
            tr += 1
            oh = randint(2, 7)
            ow = randint(2, 7)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            if bd.issubset(inds):
                ncells = randint(2, oh * ow - 1)
                obj = {choice(totuple(bd))}
                for k in range(ncells - 1):
                    obj.add(choice(totuple((bd - obj) & mapply(neighbors, mapply(dneighbors, obj)))))
                while len(obj) == height(obj) * width(obj):
                    obj = {choice(totuple(bd))}
                    for k in range(ncells - 1):
                        obj.add(choice(totuple((bd - obj) & mapply(neighbors, mapply(dneighbors, obj)))))
                obj = normalize(obj)
                oh, ow = shape(obj)
                obj = shift(obj, loc)
                bd = backdrop(obj)
                gi2 = fill(gi, fgc, bd)
                gi2 = fill(gi2, objc, obj)
                if colorcount(gi2, objc) < min(colorcount(gi2, fgc), colorcount(gi2, bgc)):
                    succ += 1
                    inds = (inds - bd) - (outbox(bd) | outbox(outbox(bd)))
                    gi = gi2
                    go = fill(go, 4, bd)
                    go = fill(go, objc, obj)
        return {'input': gi, 'output': go}

    def generate_28e73c20(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (3,))
        direcmapper = {(0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0), (-1, 0): (0, 1)}
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (4, 30))
        sp = (0, w - 1)
        direc = (1, 0)
        ncols = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(cols, ncols)
        gi = canvas(-1, (h, w))
        inds = asindices(gi)
        obj = {(choice(ccols), ij) for ij in inds}
        gi = paint(gi, obj)
        go = fill(gi, 3, connect((0, 0), sp))
        lw = w
        lh = h
        ld = h
        isverti = False
        while ld > 0:
            lw -= 1
            lh -= 1
            ep = add(sp, multiply(direc, ld - 1))
            ln = connect(sp, ep)
            go = fill(go, 3, ln)
            direc = direcmapper[direc]
            if isverti:
                ld = lh
            else:
                ld = lw
            isverti = not isverti
            sp = ep
        gi = dmirror(dmirror(gi)[1:])
        go = dmirror(dmirror(go)[1:])
        return {'input': gi, 'output': go}

    def generate_3eda0437(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(1, 10, 1), (6,))
        h = unifint(diff_lb, diff_ub, (3, 8))
        w = unifint(diff_lb, diff_ub, (3, 30))
        if choice((True, False)):
            h, w = w, h
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        fgcs = sample(cols, ncols)
        gi = canvas(-1, (h, w))
        gi = paint(gi, {(choice(fgcs), ij) for ij in asindices(gi)})
        spac = unifint(diff_lb, diff_ub, (1, (h * w) // 3 * 2))
        inds = asindices(gi)
        obj = sample(totuple(inds), spac)
        gi = fill(gi, 0, obj)
        locx = (randint(0, h-1), randint(0, w-1))
        gi = fill(gi, 0, {locx, add(locx, RIGHT), add(locx, DOWN), add(locx, UNITY)})
        maxsiz = -1
        mapper = dict()
        maxpossw = max([r.count(0) for r in gi])
        maxpossh = max([c.count(0) for c in dmirror(gi)])
        for a in range(2, maxpossh+1):
            for b in range(2, maxpossw+1):
                siz = a * b
                if siz < maxsiz:
                    continue
                objx = recolor(0, asindices(canvas(-1, (a, b))))
                occs = occurrences(gi, objx)
                if len(occs) > 0:
                    if siz == maxsiz:
                        mapper[objx] = occs
                    elif siz > maxsiz:
                        mapper = {objx: occs}
                        maxsiz = siz
        go = tuple(e for e in gi)
        for obj, locs in mapper.items():
            go = fill(go, 6, mapply(lbind(shift, obj), locs))
        return {'input': gi, 'output': go}

    def generate_7447852a(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        w = unifint(diff_lb, diff_ub, (2, 8))
        h = unifint(diff_lb, diff_ub, (w+1, 30))
        bgc, linc = sample(cols, 2)
        remcols = remove(bgc, remove(linc, cols))
        c = canvas(bgc, (h, w))
        sp = (h - 1, 0)
        gi = fill(c, linc, {sp})
        direc = 1
        while True:
            sp = add(sp, (-1, direc))
            if sp[1] == w - 1 or sp[1] == 0:
                direc *= -1
            gi2 = fill(gi, linc, {sp})
            if gi2 == gi:
                break
            gi = gi2
        gi = rot90(gi)
        objs = objects(gi, T, F, F)
        inds = ofcolor(gi, bgc)
        numcols = unifint(diff_lb, diff_ub, (1, 7))
        ccols = sample(remcols, numcols)
        ncells = unifint(diff_lb, diff_ub, (0, len(inds)))
        locs = sample(totuple(inds), ncells)
        obj = {(choice(ccols), ij) for ij in locs}
        gi = paint(gi, obj)
        go = tuple(e for e in gi)
        objs = order(colorfilter(objs, bgc), leftmost)
        objs = merge(set(objs[0::3]))
        go = fill(go, 4, objs)
        return {'input': gi, 'output': go}

    def generate_6b9890af(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        oh = unifint(diff_lb, diff_ub, (2, 5))
        ow = unifint(diff_lb, diff_ub, (2, 5))
        h = unifint(diff_lb, diff_ub, (2*oh+2, 30))
        w = unifint(diff_lb, diff_ub, (2*ow+2, 30))
        bounds = asindices(canvas(-1, (oh, ow)))
        obj = {choice(totuple(bounds))}
        while shape(obj) != (oh, ow):
            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))
        maxfac = 1
        while oh * maxfac + 2 <= h - oh and ow * maxfac + 2 <= w - ow:
            maxfac += 1
        maxfac -= 1
        fac = unifint(diff_lb, diff_ub, (1, maxfac))
        bgc, sqc = sample(cols, 2)
        remcols = remove(bgc, remove(sqc, cols))
        numc = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numc)
        obj = {(choice(ccols), ij) for ij in obj}
        gi = canvas(bgc, (h, w))
        sq = box(frozenset({(0, 0), (oh * fac + 1, ow * fac + 1)}))
        loci = randint(0, h - (oh * fac + 2) - oh)
        locj = randint(0, w - (ow * fac + 2))
        gi = fill(gi, sqc, shift(sq, (loci, locj)))
        loci = randint(loci+oh*fac+2, h - oh)
        locj = randint(0, w - ow)
        objp = shift(obj, (loci, locj))
        gi = paint(gi, objp)
        go = canvas(bgc, (oh * fac + 2, ow * fac + 2))
        go = fill(go, sqc, sq)
        go2 = paint(canvas(bgc, (oh, ow)), obj)
        upscobj = asobject(upscale(go2, fac))
        go = paint(go, shift(upscobj, (1, 1)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_963e52fc(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (6, 15))
        p = unifint(diff_lb, diff_ub, (2, w // 2))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, numc)
        obj = set()
        for j in range(p):
            ub = unifint(diff_lb, diff_ub, (0, h//2))
            ub = h//2-ub
            lb = unifint(diff_lb, diff_ub, (ub, h-1))
            numcells = unifint(diff_lb, diff_ub, (1, lb-ub+1))
            for ii in sample(interval(ub, lb+1, 1), numcells):
                loc = (ii, j)
                col = choice(ccols)
                cell = (col, loc)
                obj.add(cell)
        go = canvas(bgc, (h, w*2))
        minobj = obj | shift(obj, (0, p))
        addonw = randint(0, p)
        addon = sfilter(obj, lambda cij: cij[1][1] < addonw)
        fullobj = minobj | addon
        leftshift = randint(0, addonw)
        fullobj = shift(fullobj, (0, -leftshift))
        go = paint(go, fullobj)
        for j in range((2*w)//(2*p)+1):
            go = paint(go, shift(fullobj, (0, j * 2 * p)))
        gi = lefthalf(go)
        return {'input': gi, 'output': go}

    def generate_3e980e27(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (2, 3))
        h = unifint(diff_lb, diff_ub, (11, 30))
        w = unifint(diff_lb, diff_ub, (11, 30))
        bgc, rcol, gcol = sample(cols, 3)
        objs = []
        for (fixc, remc) in ((2, rcol), (3, gcol)):
            oh = unifint(diff_lb, diff_ub, (2, 5))
            ow = unifint(diff_lb, diff_ub, (2, 5))
            bounds = asindices(canvas(-1, (oh, ow)))
            obj = {choice(totuple(bounds))}
            ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))
            ncells = choice((ncellsd, oh * ow - ncellsd))
            ncells = min(max(2, ncells), oh * ow)
            for k in range(ncells - 1):
                obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))
            obj = normalize(obj)
            fixp = choice(totuple(obj))
            rem = remove(fixp, obj)
            obj = {(fixc, fixp)} | recolor(remc, rem)
            objs.append(obj)
        robj, gobj = objs
        obj1, obj2 = sample(objs, 2)
        loci1 = randint(0, h - height(obj1) - height(obj2) - 1)
        locj1 = randint(0, w - width(obj1))
        loci2 = randint(loci1+height(obj1)+1, h - height(obj2))
        locj2 = randint(0, w - width(obj2))
        gi = canvas(bgc, (h, w))
        obj1p = shift(obj1, (loci1, locj1))
        obj2p = shift(obj2, (loci2, locj2))
        gi = paint(gi, obj1p)
        gi = paint(gi, obj2p)
        noccs = unifint(diff_lb, diff_ub, (1, (h * w) // int(1.5 * (len(robj) + len(gobj)))))
        succ = 0
        tr = 0
        maxtr = 5 * noccs
        robj = vmirror(robj)
        inds = ofcolor(gi, bgc) - (mapply(neighbors, toindices(obj1p)) | mapply(neighbors, toindices(obj2p)))
        go = tuple(e for e in gi)
        objopts = [robj, gobj]
        while tr < maxtr and succ < noccs:
            tr += 1
            obj = choice(objopts)
            oh, ow = shape(obj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            plcdi = toindices(plcd)
            if plcdi.issubset(inds):
                succ += 1
                inds = (inds - plcdi) - mapply(neighbors, plcdi)
                gi = paint(gi, sfilter(plcd, lambda cij: cij[0] in (2, 3)))
                go = paint(go, plcd)
        if unifint(diff_lb, diff_ub, (1, 100)) < 30:
            c = choice((2, 3))
            giobjs = objects(gi, F, T, T)
            goobjs = objects(go, F, T, T)
            gi = fill(gi, bgc, mfilter(giobjs, lambda o: c in palette(o)))
            go = fill(go, bgc, mfilter(goobjs, lambda o: c in palette(o)))
        return {'input': gi, 'output': go}

    def generate_a8c38be5(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        goh = unifint(diff_lb, diff_ub, (9, 20))
        gow = unifint(diff_lb, diff_ub, (9, 20))
        h = unifint(diff_lb, diff_ub, (goh+4, 30))
        w = unifint(diff_lb, diff_ub, (gow+4, 30))
        bgc, sqc = sample(cols, 2)
        remcols = remove(bgc, remove(sqc, cols))
        numc = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numc)
        go = canvas(sqc, (goh, gow))
        go = fill(go, bgc, box(asindices(go)))
        loci1 = randint(2, goh-7)
        loci2 = randint(loci1+4, goh-3)
        locj1 = randint(2, gow-7)
        locj2 = randint(locj1+4, gow-3)
        f1 = hfrontier((loci1, 0))
        f2 = hfrontier((loci2, 0))
        f3 = vfrontier((0, locj1))
        f4 = vfrontier((0, locj2))
        fs = f1 | f2 | f3 | f4
        go = fill(go, sqc, fs)
        go = fill(go, bgc, {((loci1 + loci2) // 2, 1)})
        go = fill(go, bgc, {((loci1 + loci2) // 2, gow - 2)})
        go = fill(go, bgc, {(1, (locj1 + locj2) // 2)})
        go = fill(go, bgc, {(goh - 2, (locj1 + locj2) // 2)})
        objs = objects(go, T, F, T)
        objs = merge(set(recolor(choice(ccols), obj) for obj in objs))
        go = paint(go, objs)
        gi = go
        hdelt = h - goh
        hdelt1 = randint(1, hdelt - 3)
        hdelt2 = randint(1, hdelt - hdelt1 - 2)
        hdelt3 = randint(1, hdelt - hdelt1 - hdelt2 - 1)
        hdelt4 = hdelt - hdelt1 - hdelt2 - hdelt3
        wdelt = w - gow
        wdelt1 = randint(1, wdelt - 3)
        wdelt2 = randint(1, wdelt - wdelt1 - 2)
        wdelt3 = randint(1, wdelt - wdelt1 - wdelt2 - 1)
        wdelt4 = wdelt - wdelt1 - wdelt2 - wdelt3
        gi = gi[:loci2] + repeat(repeat(bgc, gow), hdelt2) + gi[loci2:]
        gi = gi[:loci1+1] + repeat(repeat(bgc, gow), hdelt3) + gi[loci1+1:]
        gi = repeat(repeat(bgc, gow), hdelt1) + gi + repeat(repeat(bgc, gow), hdelt4)
        gi = dmirror(gi)
        gi = gi[:locj2] + repeat(repeat(bgc, h), wdelt2) + gi[locj2:]
        gi = gi[:locj1+1] + repeat(repeat(bgc, h), wdelt3) + gi[locj1+1:]
        gi = repeat(repeat(bgc, h), wdelt1) + gi + repeat(repeat(bgc, h), wdelt4)
        gi = dmirror(gi)
        nswitcheroos = unifint(diff_lb, diff_ub, (0, 10))
        if choice((True, False)):
            gi = gi[loci1+hdelt1+1:] + gi[:loci1+hdelt1+1]
        if choice((True, False)):
            gi = dmirror(gi)
            gi = gi[locj1+wdelt1+1:] + gi[:locj1+wdelt1+1]
            gi = dmirror(gi)
        for k in range(nswitcheroos):
            o = asobject(gi)
            tmpc = canvas(bgc, (h+12, w+12))
            tmpc = paint(tmpc, shift(o, (6, 6)))
            objs = objects(tmpc, F, T, T)
            objs = apply(rbind(shift, (-6, -6)), objs)
            mpr = dict()
            for obj in objs:
                shp = shape(obj)
                if shp in mpr:
                    mpr[shp].append(obj)
                else:
                    mpr[shp] = [obj]
            if max([len(x) for x in mpr.values()]) == 1:
                break
            ress = [(kk, v) for kk, v in mpr.items() if len(v) > 1]
            res, abc = choice(ress)
            a, b = sample(abc, 2)
            ulca = ulcorner(a)
            ulcb = ulcorner(b)
            ap = shift(normalize(a), ulcb)
            bp = shift(normalize(b), ulca)
            gi = paint(gi, ap | bp)
        nshifts = unifint(diff_lb, diff_ub, (0, 30))
        for k in range(nshifts):
            o = asobject(gi)
            tmpc = canvas(bgc, (h+12, w+12))
            tmpc = paint(tmpc, shift(o, (6, 6)))
            objs = objects(tmpc, F, F, T)
            objs = apply(rbind(shift, (-6, -6)), objs)
            objs = sfilter(objs, compose(flip, rbind(bordering, gi)))
            if len(objs) == 0:
                break
            obj = choice(totuple(objs))
            direc1 = (randint(-1, 1), randint(-1, 1))
            direc2 = position({(h//2, w//2)}, {center(obj)})
            direc = choice((direc1, direc2))
            gi = fill(gi, bgc, obj)
            gi = paint(gi, shift(obj, direc))
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_6c434453(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, ncols)
        nobjs = unifint(diff_lb, diff_ub, (2, (h * w) // 16))
        succ = 0
        tr = 0
        maxtr = 5 * nobjs
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        while succ < nobjs and tr < maxtr:
            tr += 1
            if choice((True, False)):
                oh = choice((3, 5))
                ow = choice((3, 5))
                obji = box(frozenset({(0, 0), (oh - 1, ow - 1)}))
            else:
                oh = randint(1, 5)
                ow = randint(1, 5)
                bounds = asindices(canvas(-1, (oh, ow)))
                ncells = randint(1, oh * ow)
                obji = {choice(totuple(bounds))}
                for k in range(ncells - 1):
                    obji.add(choice(totuple((bounds - obji) & mapply(dneighbors, obji))))
                obji = normalize(obji)
            oh, ow = shape(obji)
            flag = obji == box(obji) and set(shape(obji)).issubset({3, 5})
            if flag:
                objo = connect((0, ow//2), (oh - 1, ow//2)) | connect((oh//2, 0), (oh//2, ow - 1))
                tocover = backdrop(obji)
            else:
                objo = obji
                tocover = obji
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            loc = choice(totuple(cands))
            plcdi = shift(obji, loc)
            if plcdi.issubset(inds):
                plcdo = shift(objo, loc)
                succ += 1
                tocoveri = shift(tocover, loc)
                inds = (inds - tocoveri) - mapply(dneighbors, tocoveri)
                col = choice(ccols)
                gi = fill(gi, col, plcdi)
                go = fill(go, 2 if flag else col, plcdo)
        return {'input': gi, 'output': go}

    def generate_7837ac64(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        oh = unifint(diff_lb, diff_ub, (2, 6))
        ow = unifint(diff_lb, diff_ub, (2, 6))
        bgc, linc = sample(cols, 2)
        remcols = remove(bgc, remove(linc, cols))
        numcols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, numcols)
        go = canvas(bgc, (oh, ow))
        inds = asindices(go)
        fullinds = asindices(go)
        nocc = unifint(diff_lb, diff_ub, (1, oh * ow))
        for k in range(nocc):
            mpr = {
                cc: sfilter(
                    inds | mapply(neighbors, ofcolor(go, cc)),
                    lambda ij: (neighbors(ij) & fullinds).issubset(inds | ofcolor(go, cc))
                ) for cc in ccols
            }
            mpr = [(kk, vv) for kk, vv in mpr.items() if len(vv) > 0]
            if len(mpr) == 0:
                break
            col, locs = choice(mpr)
            loc = choice(totuple(locs))
            go = fill(go, col, {loc})
            inds = remove(loc, inds)
        obj = fullinds - ofcolor(go, bgc)
        go = subgrid(obj, go)
        oh, ow = shape(go)
        sqsizh = unifint(diff_lb, diff_ub, (2, (30 - oh - 1) // oh))
        sqsizw = unifint(diff_lb, diff_ub, (2, (30 - ow - 1) // ow))
        fullh = oh + 1 + oh * sqsizh
        fullw = ow + 1 + ow * sqsizw
        gi = canvas(linc, (fullh, fullw))
        sq = backdrop(frozenset({(0, 0), (sqsizh - 1, sqsizw - 1)}))
        obj = asobject(go)
        for col, ij in obj:
            plcd = shift(sq, add((1, 1), multiply(ij, (sqsizh+1, sqsizw+1))))
            gi = fill(gi, bgc, plcd)
            if col != bgc:
                gi = fill(gi, col, corners(outbox(plcd)))
        gih = unifint(diff_lb, diff_ub, (fullh, 30))
        giw = unifint(diff_lb, diff_ub, (fullw, 30))
        loci = randint(0, gih - fullh)
        locj = randint(0, giw - fullw)
        gigi = canvas(bgc, (gih, giw))
        plcd = shift(asobject(gi), (loci, locj))
        gigi = paint(gigi, plcd)
        ulci, ulcj = ulcorner(plcd)
        lrci, lrcj = lrcorner(plcd)
        for a in range(ulci, gih+1, sqsizh+1):
            gigi = fill(gigi, linc, hfrontier((a, 0)))
        for a in range(ulci, -1, -sqsizh-1):
            gigi = fill(gigi, linc, hfrontier((a, 0)))
        for b in range(ulcj, giw+1, sqsizw+1):
            gigi = fill(gigi, linc, vfrontier((0, b)))
        for b in range(ulcj, -1, -sqsizw-1):
            gigi = fill(gigi, linc, vfrontier((0, b)))
        gi = paint(gigi, plcd)
        gop = palette(go)
        while True:
            go2 = identity(go)
            for c in set(ccols) & gop:
                o1 = frozenset({(c, ORIGIN), (bgc, RIGHT), (c, (0, 2))})
                o2 = dmirror(o1)
                go2 = fill(go2, c, combine(
                    shift(occurrences(go, o1), RIGHT),
                    shift(occurrences(go, o2), DOWN)
                ))
            if go2 == go:
                break
            go = go2
        return {'input': gi, 'output': go}

    def generate_5ad4f10b(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        nbh = {(0, 0), (1, 0), (0, 1), (1, 1)}
        nbhs = apply(lbind(shift, nbh), {(0, 0), (-1, 0), (0, -1), (-1, -1)})
        oh = unifint(diff_lb, diff_ub, (2, 6))
        ow = unifint(diff_lb, diff_ub, (2, 6))
        bounds = asindices(canvas(-1, (oh, ow)))
        ncellsd = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2))
        ncells = choice((ncellsd, oh * ow - ncellsd))
        ncells = min(max(1, ncells), oh * ow - 1)
        obj = set(sample(totuple(bounds), ncells))
        while len(sfilter(obj, lambda ij: sum([len(obj & shift(nbh, ij)) < 4 for nbh in nbhs]) > 0)) == 0:
            ncellsd = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2))
            ncells = choice((ncellsd, oh * ow - ncellsd))
            ncells = min(max(1, ncells), oh * ow)
            obj = set(sample(totuple(bounds), ncells))
        obj = normalize(obj)
        oh, ow = shape(obj)
        bgc, noisec, objc = sample(cols, 3)
        go = canvas(bgc, (oh, ow))
        go = fill(go, noisec, obj)
        fac = unifint(diff_lb, diff_ub, (2, min(28//oh, 28//ow)))
        gobj = asobject(upscale(replace(go, noisec, objc), fac))
        oh, ow = shape(gobj)
        h = unifint(diff_lb, diff_ub, (oh+2, 30))
        w = unifint(diff_lb, diff_ub, (ow+2, 30))
        loci = randint(1, h - oh-1)
        locj = randint(1, w - ow-1)
        gi = canvas(bgc, (h, w))
        gi = paint(gi, shift(gobj, (loci, locj)))
        cands = ofcolor(gi, bgc)
        namt = unifint(diff_lb, diff_ub, (2, max(1, len(cands) // 4)))
        noise = sample(totuple(cands), namt)
        gi = fill(gi, noisec, noise)
        return {'input': gi, 'output': go}

    def generate_7df24a62(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (12, 32))
        w = unifint(diff_lb, diff_ub, (12, 32))
        oh = unifint(diff_lb, diff_ub, (3, min(7, h//3)))
        ow = unifint(diff_lb, diff_ub, (3, min(7, w//3)))
        bgc, noisec, sqc = sample(cols, 3)
        tmpg = canvas(sqc, (oh, ow))
        inbounds = backdrop(inbox(asindices(tmpg)))
        obj = {choice(totuple(inbounds))}
        while shape(obj) != (oh - 2, ow - 2):
            obj.add(choice(totuple(inbounds - obj)))
        pat = fill(tmpg, noisec, obj)
        targ = asobject(fill(canvas(bgc, (oh, ow)), noisec, obj))
        sour = asobject(pat)
        gi = canvas(bgc, (h, w))
        loci = randint(1, h - oh - 1)
        locj = randint(1, w - ow - 1)
        plcddd = shift(sour, (loci, locj))
        gi = paint(gi, plcddd)
        inds = ofcolor(gi, bgc) & shift(asindices(canvas(-1, (h-2, w-2))), (1, 1))
        inds = inds - (toindices(plcddd) | mapply(dneighbors, toindices(plcddd)))
        namt = unifint(diff_lb, diff_ub, (1, max(1, len(inds) // 4)))
        noise = sample(totuple(inds), namt)
        gi = fill(gi, noisec, noise)
        targs = []
        sours = []
        for fn1 in (identity, dmirror, cmirror, hmirror, vmirror):
            for fn2 in (identity, dmirror, cmirror, hmirror, vmirror):
                targs.append(normalize(fn1(fn2(targ))))
                sours.append(normalize(fn1(fn2(sour))))
        noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // ((oh * ow * 4)))))
        succ = 0
        tr = 0
        maxtr = 5 * noccs
        while succ < noccs and tr < maxtr:
            tr += 1
            t = choice(targs)
            hh, ww = shape(t)
            cands = sfilter(inds, lambda ij: 1 <= ij[0] <= h - hh - 1 and 1 <= ij[1] <= w - ww - 1)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            tp = shift(t, loc)
            tpi = toindices(tp)
            if tpi.issubset(inds):
                succ += 1
                inds = inds - tpi
                gi = paint(gi, tp)
        go = replace(gi, sqc, bgc)
        go = paint(go, plcddd)
        res = set()
        for t, s in zip(targs, sours):
            res |= mapply(lbind(shift, s), occurrences(go, t))
        go = paint(go, res)
        gi = trim(gi)
        go = trim(go)
        return {'input': gi, 'output': go}

    def generate_539a4f51(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        d = unifint(diff_lb, diff_ub, (2, 15))
        h, w = d, d
        gi = canvas(0, (h, w))
        numc = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(cols, numc)
        numocc = unifint(diff_lb, diff_ub, (1, d))
        arr = [choice(ccols) for k in range(numocc)]
        while len(set(arr)) == 1:
            arr = [choice(ccols) for k in range(d)]
        for j, col in enumerate(arr):
            gi = fill(gi, col, connect((j, 0), (j, j)) | connect((0, j), (j, j)))
        go = canvas(0, (2*d, 2*d))
        for j in range(2*d):
            col = arr[j % len(arr)]
            go = fill(go, col, connect((j, 0), (j, j)) | connect((0, j), (j, j)))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_ce602527(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (12, 30))
        w = unifint(diff_lb, diff_ub, (12, 30))
        bgc, c1, c2, c3 = sample(cols, 4)
        while True:
            objs = []
            for k in range(2):
                oh1 = unifint(diff_lb, diff_ub, (3, h//3-1))
                ow1 = unifint(diff_lb, diff_ub, (3, w//3-1))
                cc1 = canvas(bgc, (oh1, ow1))
                bounds1 = asindices(cc1)
                numcd1 = unifint(diff_lb, diff_ub, (0, (oh1 * ow1) // 2 - 4))
                numc1 = choice((numcd1, oh1 * ow1 - numcd1))
                numc1 = min(max(3, numc1), oh1 * ow1 - 3)
                obj1 = {choice(totuple(bounds1))}
                while len(obj1) < numc1 or shape(obj1) != (oh1, ow1):
                    obj1.add(choice(totuple((bounds1 - obj1) & mapply(dneighbors, obj1))))
                objs.append(normalize(obj1))
            a, b = objs
            ag = fill(canvas(0, shape(a)), 1, a)
            bg = fill(canvas(0, shape(b)), 1, b)
            maxinh = min(height(a), height(b)) // 2 + 1
            maxinw = min(width(a), width(b)) // 2 + 1
            maxshp = (maxinh, maxinw)
            ag = crop(ag, (0, 0), maxshp)
            bg = crop(bg, (0, 0), maxshp)
            if ag != bg:
                break
        a, b = objs
        trgo = choice(objs)
        trgo2 = ofcolor(upscale(fill(canvas(0, shape(trgo)), 1, trgo), 2), 1)
        staysinh = unifint(diff_lb, diff_ub, (maxinh * 2, height(trgo) * 2))
        nout = height(trgo2) - staysinh
        loci = h - height(trgo2) + nout
        locj = randint(0, w - maxinw * 2)
        gi = canvas(bgc, (h, w))
        gi = fill(gi, c3, shift(trgo2, (loci, locj)))
        (lcol, lobj), (rcol, robj) = sample([(c1, a), (c2, b)], 2)
        cands = ofcolor(gi, bgc) - box(asindices(gi))
        lca = sfilter(cands, lambda ij: ij[1] < w//3*2)
        rca = sfilter(cands, lambda ij: ij[1] > w//3)
        lcands = sfilter(lca, lambda ij: shift(lobj, ij).issubset(lca))
        rcands = sfilter(rca, lambda ij: shift(robj, ij).issubset(rca))
        while True:
            lloc = choice(totuple(lcands))
            rloc = choice(totuple(lcands))
            lplcd = shift(lobj, lloc)
            rplcd = shift(robj, rloc)
            if lplcd.issubset(cands) and rplcd.issubset(cands) and len(lplcd & rplcd) == 0:
                break
        gi = fill(gi, lcol, shift(lobj, lloc))
        gi = fill(gi, rcol, shift(robj, rloc))
        go = fill(canvas(bgc, shape(trgo)), c1 if trgo == a else c2, trgo)
        mfs = (identity, rot90, rot180, rot270, cmirror, dmirror, hmirror, vmirror)
        mf = choice(mfs)
        gi, go = mf(gi), mf(go)
        return {'input': gi, 'output': go}

    def generate_c8cbb738(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        gh = unifint(diff_lb, diff_ub, (3, 10))
        gw = unifint(diff_lb, diff_ub, (3, 10))
        h = unifint(diff_lb, diff_ub, (gh*2, 30))
        w = unifint(diff_lb, diff_ub, (gw*2, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, ncols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (gh, gw))
        goinds = asindices(go)
        ring = box(goinds)
        crns = corners(ring)
        remring = ring - crns
        nrr = len(remring)
        sc = ccols[0]
        go = fill(go, sc, crns)
        loci = randint(0, h - gh)
        locj = randint(0, w - gw)
        gi = fill(gi, sc, shift(crns, (loci, locj)))
        ccols = ccols[1:]
        issucc = True
        bL = connect((0, 0), (gh - 1, 0))
        bR = connect((0, gw - 1), (gh - 1, gw - 1))
        bT = connect((0, 0), (0, gw - 1))
        bB = connect((gh - 1, 0), (gh - 1, gw - 1))
        validpairs = [(bL, bT), (bL, bB), (bR, bT), (bR, bB)]
        for c in ccols:
            if len(remring) < 3:
                break
            obj = set(sample(totuple(remring), unifint(diff_lb, diff_ub, (3, max(3, min(len(remring), nrr//len(ccols)))))))
            flag = False
            for b1, b2 in validpairs:
                if len(obj & b1) > 0 and len(obj & b2) > 0:
                    flag = True
                    break
            if flag:
                oh, ow = shape(obj)
                locs = ofcolor(gi, bgc)
                cands = sfilter(locs, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
                if len(cands) > 0:
                    objn = normalize(obj)
                    cands2 = sfilter(cands, lambda ij: shift(objn, ij).issubset(locs))
                    if len(cands2) > 0:
                        loc = choice(totuple(cands2))
                        gi = fill(gi, c, shift(objn, loc))
                        go = fill(go, c, obj)
                        remring -= obj
        return {'input': gi, 'output': go}

    def generate_b527c5c6(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (2, 9))
        ccols = sample(remcols, ncols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        fullinds = asindices(gi)
        noccs = unifint(diff_lb, diff_ub, (1, 10))
        tr = 0
        succ = 0
        maxtr = 10 * noccs
        while succ < noccs and tr < maxtr:
            tr += 1
            d1 = randint(3, randint(3, (min(h, w)) // 2 - 1))
            d2 = randint(d1*2+1, randint(d1*2+1, min(h, w) - 1))
            oh, ow = sample([d1, d2], 2)
            cands = sfilter(inds, lambda ij: 1 <= ij[0] <= h - oh - 1 and 1 <= ij[1] <= w - ow - 1)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            bx = box(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            bd = backdrop(bx)
            if ow < oh:
                lrflag = True
                dcands1 = connect((loci+ow-1, locj), (loci+oh-1-ow+1, locj))
                dcands2 = shift(dcands1, (0, ow-1))
            else:
                lrflag = False
                dcands1 = connect((loci, locj+oh-1), (loci, locj+ow-1-oh+1))
                dcands2 = shift(dcands1, (oh-1, 0))
            dcands = dcands1 | dcands2
            loc = choice(totuple(dcands))
            sgnflag = -1 if loc in dcands1 else 1
            direc = (sgnflag * (0 if lrflag else 1), sgnflag * (0 if not lrflag else 1))
            ln = shoot(loc, direc)
            shell = set()
            for k in range(min(oh, ow)-1):
                shell |= power(outbox, k+1)(ln)
            sqc, dotc = sample(ccols, 2)
            giobj = recolor(sqc, remove(loc, bd)) | {(dotc, loc)}
            goobj = recolor(sqc, (bd | shell) - ln) | recolor(dotc, ln)
            goobj = sfilter(goobj, lambda cij: cij[1] in fullinds)
            goobji = toindices(goobj)
            if goobji.issubset(inds):
                succ += 1
                inds = (inds - goobji) - mapply(dneighbors, bd)
                gi = paint(gi, giobj)
                go = paint(go, goobj)
        return {'input': gi, 'output': go}

    def generate_228f6490(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        nsq = unifint(diff_lb, diff_ub, (1, (h * w) // 50))
        succ = 0
        tr = 0
        maxtr = 5 * nsq
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        sqc = choice(remcols)
        remcols = remove(sqc, remcols)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        forbidden = []
        while tr < maxtr and succ < nsq:
            tr += 1
            oh = randint(3, 6)
            ow = randint(3, 6)
            bd = asindices(canvas(-1, (oh, ow)))
            bounds = shift(asindices(canvas(-1, (oh-2, ow-2))), (1, 1))
            obj = {choice(totuple(bounds))}
            ncells = randint(1, (oh-2) * (ow-2))
            for k in range(ncells - 1):
                obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))
            sqcands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(sqcands) == 0:
                continue
            loc = choice(totuple(sqcands))
            bdplcd = shift(bd, loc)
            if bdplcd.issubset(inds):
                tmpinds = inds - bdplcd
                inobjn = normalize(obj)
                oh, ow = shape(obj)
                inobjcands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
                if len(inobjcands) == 0:
                    continue
                loc2 = choice(totuple(inobjcands))
                inobjplcd = shift(inobjn, loc2)
                bdnorm = bd - obj
                if inobjplcd.issubset(tmpinds) and bdnorm not in forbidden and inobjn not in forbidden:
                    forbidden.append(bdnorm)
                    forbidden.append(inobjn)
                    succ += 1
                    inds = (inds - (bdplcd | inobjplcd)) - mapply(dneighbors, inobjplcd)
                    col = choice(remcols)
                    oplcd = shift(obj, loc)
                    gi = fill(gi, sqc, bdplcd - oplcd)
                    go = fill(go, sqc, bdplcd)
                    go = fill(go, col, oplcd)
                    gi = fill(gi, col, inobjplcd)
        nremobjs = unifint(diff_lb, diff_ub, (0, len(inds) // 25))
        succ = 0
        tr = 0
        maxtr = 10 * nremobjs
        while tr < maxtr and succ < nremobjs:
            tr += 1
            oh = randint(1, 4)
            ow = randint(1, 4)
            bounds = asindices(canvas(-1, (oh, ow)))
            obj = {choice(totuple(bounds))}
            ncells = randint(1, oh * ow)
            for k in range(ncells - 1):
                obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))
            obj = normalize(obj)
            if obj in forbidden:
                continue
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            if plcd.issubset(inds):
                succ += 1
                inds = (inds - plcd) - mapply(dneighbors, plcd)
                col = choice(remcols)
                gi = fill(gi, col, plcd)
                go = fill(go, col, plcd)
        return {'input': gi, 'output': go}

    def generate_93b581b8(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        numcols = unifint(diff_lb, diff_ub, (1, 9))
        ccols = sample(remcols, numcols)
        numocc = unifint(diff_lb, diff_ub, (1, (h * w) // 50))
        succ = 0
        tr = 0
        maxtr = 10 * numocc
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        inds = asindices(gi)
        fullinds = asindices(gi)
        while tr < maxtr and succ < numocc:
            tr += 1
            cands = sfilter(inds, lambda ij: ij[0] <= h - 2 and ij[1] <= w - 2)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            c1, c2, c3, c4 = [choice(ccols) for k in range(4)]
            q = {(0, 0), (0, 1), (1, 0), (1, 1)}
            inobj = {(c1, (0, 0)), (c2, (0, 1)), (c3, (1, 0)), (c4, (1, 1))}
            outobj = inobj | recolor(c4, shift(q, (-2, -2))) | recolor(c3, shift(q, (-2, 2))) | recolor(c2, shift(q, (2, -2))) | recolor(c1, shift(q, (2, 2)))
            inobjplcd = shift(inobj, loc)
            outobjplcd = shift(outobj, loc)
            outobjplcd = sfilter(outobjplcd, lambda cij: cij[1] in fullinds)
            outobjplcdi = toindices(outobjplcd)
            if outobjplcdi.issubset(inds):
                succ += 1
                inds = (inds - outobjplcdi) - mapply(dneighbors, toindices(inobjplcd))
                gi = paint(gi, inobjplcd)
                go = paint(go, outobjplcd)
        return {'input': gi, 'output': go}

    def generate_447fd412(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (12, 30))
        w = unifint(diff_lb, diff_ub, (12, 30))
        bgc, indic, mainc = sample(cols, 3)
        oh = unifint(diff_lb, diff_ub, (1, 4))
        ow = unifint(diff_lb, diff_ub, (1, 4))
        if oh * ow < 3:
            if choice((True, False)):
                oh = unifint(diff_lb, diff_ub, (3, 4))
            else:
                ow = unifint(diff_lb, diff_ub, (3, 4))
        bounds = asindices(canvas(-1, (oh, ow)))
        ncells = unifint(diff_lb, diff_ub, (3, oh * ow))
        obj = {choice(totuple(bounds))}
        for k in range(ncells - 1):
            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))
        obj = normalize(obj)
        oh, ow = shape(obj)
        objt = totuple(obj)
        kk = len(obj)
        nindic = randint(1, kk // 2 if kk % 2 == 1 else kk // 2 - 1)
        indicobj = set(sample(objt, nindic))
        mainobj = obj - indicobj
        obj = recolor(indic, indicobj) | recolor(mainc, mainobj)
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (h, w))
        plcd = shift(obj, (loci, locj))
        gi = paint(gi, plcd)
        go = paint(go, plcd)
        inds = ofcolor(gi, bgc) - mapply(neighbors, toindices(plcd))
        fullinds = asindices(gi)
        noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // (4 * len(plcd)))))
        tr = 0
        maxtr = 5 * noccs
        succ = 0
        while succ < noccs and tr < maxtr:
            tr += 1
            fac = randint(1, min(5, min(h, w) // max(oh, ow) - 1))
            outobj = upscale(obj, fac)
            inobj = sfilter(outobj, lambda cij: cij[0] == indic)
            hh, ww = shape(outobj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - hh and ij[1] <= w - ww)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            inobjp = shift(inobj, loc)
            outobjp = shift(outobj, loc)
            outobjp = sfilter(outobjp, lambda cij: cij[1] in fullinds)
            outobjpi = toindices(outobjp)
            if outobjpi.issubset(inds):
                succ += 1
                inds = (inds - outobjpi) - mapply(neighbors, toindices(inobjp))
                gi = paint(gi, inobjp)
                go = paint(go, outobjp)
        return {'input': gi, 'output': go}

    def generate_50846271(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(8, interval(0, 10, 1))
        cf1 = lambda d: {(d//2, 0), (d//2, d-1)} | set(sample(totuple(connect((d//2, 0), (d//2, d-1))), randint(1, d)))
        cf2 = lambda d: {(0, d//2), (d - 1, d//2)} | set(sample(totuple(connect((0, d//2), (d-1, d//2))), randint(1, d)))
        cf3 = lambda d: set(sample(totuple(remove((d//2, d//2), connect((d//2, 0), (d//2, d-1)))), randint(1, d-1))) | set(sample(totuple(remove((d//2, d//2), connect((0, d//2), (d - 1, d//2)))), randint(1, d-1)))
        cf = lambda d: choice((cf1, cf2, cf3))(d)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        dim = unifint(diff_lb, diff_ub, (1, 3))
        dim = 2 * dim + 1
        cross = connect((dim//2, 0), (dim//2, dim - 1)) | connect((0, dim//2), (dim - 1, dim//2))
        bgc, crossc, noisec = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        namt = unifint(diff_lb, diff_ub, (int(0.35 * h * w), int(0.65 * h * w)))
        inds = asindices(gi)
        noise = sample(totuple(inds), namt)
        gi = fill(gi, noisec, noise)
        initcross = choice((cf1, cf2))(dim)
        loci = randint(0, h - dim)
        locj = randint(0, w - dim)
        delt = shift(cross - initcross, (loci, locj))
        gi = fill(gi, crossc, shift(initcross, (loci, locj)))
        gi = fill(gi, noisec, delt)
        go = fill(gi, 8, delt)
        plcd = shift(cross, (loci, locj))
        bd = backdrop(plcd)
        nbhs = mapply(neighbors, plcd)
        inds = (inds - plcd) - nbhs
        nbhs2 = mapply(neighbors, nbhs)
        inds = inds - nbhs2
        inds = inds - mapply(neighbors, nbhs2)
        noccs = unifint(diff_lb, diff_ub, (1, (h * w) / (10 * dim)))
        succ = 0
        tr = 0
        maxtr = 5 * noccs
        while succ < noccs and tr < maxtr:
            tr += 1
            cands = sfilter(inds, lambda ij: ij[0] <= h - dim and ij[1] <= w - dim)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            marked = shift(cf(dim), loc)
            full = shift(cross, loc)
            unmarked = full - marked
            inobj = recolor(noisec, unmarked) | recolor(crossc, marked)
            outobj = recolor(8, unmarked) | recolor(crossc, marked)
            outobji = toindices(outobj)
            if outobji.issubset(inds):
                dnbhs = mapply(neighbors, outobji)
                dnbhs2 = mapply(neighbors, dnbhs)
                inds = (inds - outobji) - (dnbhs | dnbhs2 | mapply(neighbors, dnbhs2))
                succ += 1
                gi = paint(gi, inobj)
                go = paint(go, outobj)
        return {'input': gi, 'output': go}

    def generate_ae3edfdc(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2, 3, 7))
        h = unifint(diff_lb, diff_ub, (8, 30))
        w = unifint(diff_lb, diff_ub, (8, 30))
        bgc = choice(cols)
        go = canvas(bgc, (h, w))
        inds = asindices(go)
        rdi = randint(1, h - 2)
        rdj = randint(1, w - 2)
        rd = (rdi, rdj)
        reminds = inds - ({rd} | neighbors(rd))
        reminds = sfilter(reminds, lambda ij: 1 <= ij[0] <= h - 2 and 1 <= ij[1] <= w - 2)
        bd = choice(totuple(reminds))
        bdi, bdj = bd
        go = fill(go, 2, {rd})
        go = fill(go, 1, {bd})
        ngd = unifint(diff_lb, diff_ub, (1, 8))
        gd = sample(totuple(neighbors(rd)), ngd)
        nod = unifint(diff_lb, diff_ub, (1, 8))
        od = sample(totuple(neighbors(bd)), nod)
        go = fill(go, 3, gd)
        go = fill(go, 7, od)
        gdmapper = {d: (3, position({rd}, {d})) for d in gd}
        odmapper = {d: (7, position({bd}, {d})) for d in od}
        mpr = {**gdmapper, **odmapper}
        ub = (len(gd) + len(od)) * ((h + w) // 5)
        ndist = unifint(diff_lb, diff_ub, (1, ub))
        gi = tuple(e for e in go)
        fullinds = asindices(gi)
        for k in range(ndist):
            options = []
            for loc, (col, direc) in mpr.items():
                ii, jj = add(loc, direc)
                if (ii, jj) in fullinds and gi[ii][jj] == bgc:
                    options.append((loc, col, direc))
            if len(options) == 0:
                break
            loc, col, direc = choice(options)
            del mpr[loc]
            newloc = add(loc, direc)
            mpr[newloc] = (col, direc)
            gi = fill(gi, bgc, {loc})
            gi = fill(gi, col, {newloc})
        return {'input': gi, 'output': go}

    def generate_469497ad(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(2, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (3, 6))
        w = unifint(diff_lb, diff_ub, (3, 6))
        bgc, sqc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        sqh = randint(1, h - 2)
        sqw = randint(1, w - 2)
        sqloci = randint(0, h - sqh - 2)
        sqlocj = randint(0, w - sqw - 2)
        sq = backdrop(frozenset({(sqloci, sqlocj), (sqloci + sqh - 1, sqlocj + sqw - 1)}))
        gi = fill(gi, sqc, sq)
        numcub = min(min(min(h, w)+1, 30//(max(h, w))), 7)
        numc = unifint(diff_lb, diff_ub, (2, numcub))
        numaccc = numc - 1
        remcols = remove(bgc, remove(sqc, cols))
        ccols = sample(remcols, numaccc)
        gi = rot180(gi)
        locs = sample(interval(1, min(h, w), 1), numaccc - 1)
        locs = [0] + sorted(locs)
        for c, l in zip(ccols, locs):
            gi = fill(gi, c, shoot((0, l), (0, 1)))
            gi = fill(gi, c, shoot((l, 0), (1, 0)))
        gi = rot180(gi)
        go = upscale(gi, numc)
        rect = ofcolor(go, sqc)
        l1 = shoot(lrcorner(rect), (1, 1))
        l2 = shoot(ulcorner(rect), (-1, -1))
        l3 = shoot(urcorner(rect), (-1, 1))
        l4 = shoot(llcorner(rect), (1, -1))
        ll = l1 | l2 | l3 | l4
        go = fill(go, 2, ll & ofcolor(go, bgc))
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_97a05b5b(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (15, 30))
        w = unifint(diff_lb, diff_ub, (15, 30))
        sgh = randint(h//3, h//3*2)
        sgw = randint(w//3, w//3*2)
        bgc, sqc = sample(cols, 2)
        remcols = remove(bgc, remove(sqc, cols))
        gi = canvas(bgc, (h, w))
        oh = randint(2, sgh//2)
        ow = randint(2, sgw//2)
        nobjs = unifint(diff_lb, diff_ub, (1, 8))
        objs = set()
        cands = asindices(canvas(-1, (oh, ow)))
        forbidden = set()
        tr = 0
        maxtr = 4 * nobjs
        while len(objs) != nobjs and tr < maxtr:
            tr += 1
            obj = {choice(totuple(cands))}
            ncells = randint(1, oh * ow - 1)
            for k in range(ncells - 1):
                obj.add(choice(totuple((cands - obj) & mapply(neighbors, obj))))
            obj |= choice((dmirror, cmirror, vmirror, hmirror))(obj)
            if len(obj) == height(obj) * width(obj):
                continue
            obj = frozenset(obj)
            objn = normalize(obj)
            if objn not in forbidden:
                objs.add(objn)
            for augmf1 in (identity, dmirror, cmirror, hmirror, vmirror):
                for augmf2 in (identity, dmirror, cmirror, hmirror, vmirror):
                    forbidden.add(augmf1(augmf2(objn)))
        tr = 0
        maxtr = 5 * nobjs
        succ = 0
        loci = randint(0, h - sgh)
        locj = randint(0, w - sgw)
        bd = backdrop(frozenset({(loci, locj), (loci + sgh - 1, locj + sgw - 1)}))
        gi = fill(gi, sqc, bd)
        go = canvas(sqc, (sgh, sgw))
        goinds = asindices(go)
        giinds = asindices(gi) - shift(goinds, (loci, locj))
        giinds = giinds - mapply(neighbors, shift(goinds, (loci, locj)))
        while succ < nobjs and tr < maxtr and len(objs) > 0:
            tr += 1
            obj = choice(totuple(objs))
            col = choice(remcols)
            subgi = fill(canvas(col, shape(obj)), sqc, obj)
            if len(palette(subgi)) == 1:
                continue
            f1 = choice((identity, dmirror, vmirror, cmirror, hmirror))
            f2 = choice((identity, dmirror, vmirror, cmirror, hmirror))
            f = compose(f1, f2)
            subgo = f(subgi)
            giobj = asobject(subgi)
            goobj = asobject(subgo)
            ohi, owi = shape(giobj)
            oho, owo = shape(goobj)
            gocands = sfilter(goinds, lambda ij: ij[0] <= sgh - oho and ij[1] <= sgw - owo)
            if len(gocands) == 0:
                continue
            goloc = choice(totuple(gocands))
            goplcd = shift(goobj, goloc)
            goplcdi = toindices(goplcd)
            if goplcdi.issubset(goinds):
                gicands = sfilter(giinds, lambda ij: ij[0] <= h - ohi and ij[1] <= owi)
                if len(gicands) == 0:
                    continue
                giloc = choice(totuple(gicands))
                giplcd = shift(giobj, giloc)
                giplcdi = toindices(giplcd)
                if giplcdi.issubset(giinds):
                    succ += 1
                    remcols = remove(col, remcols)
                    objs = remove(obj, objs)
                    goinds = goinds - goplcdi
                    giinds = (giinds - giplcdi) - mapply(neighbors, giplcdi)
                    gi = paint(gi, giplcd)
                    gi = fill(gi, bgc, sfilter(shift(goplcd, (loci, locj)), lambda cij: cij[0] == sqc))
                    go = paint(go, goplcd)
        return {'input': gi, 'output': go}

    def generate_a5313dff(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(1, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc, fgc = sample(cols, 2)
        gi = canvas(bgc, (h, w))
        noccs = unifint(diff_lb, diff_ub, (1, (h * w) // 20))
        succ = 0
        tr = 0
        maxtr = 10 * noccs
        inds = shift(asindices(canvas(-1, (h+2, w+2))), (-1, -1))
        while (tr < maxtr and succ < noccs) or len(sfilter(colorfilter(objects(gi, T, F, F), bgc), compose(flip, rbind(bordering, gi)))) == 0:
            tr += 1
            oh = randint(3, 8)
            ow = randint(3, 8)
            bx = box(frozenset({(0, 0), (oh - 1, ow - 1)}))
            ins = backdrop(inbox(bx))
            loc = choice(totuple(inds))
            plcdins = shift(ins, loc)
            if len(plcdins & ofcolor(gi, fgc)) == 0:
                succ += 1
                gi = fill(gi, fgc, shift(bx, loc))
                if choice((True, True, False)):
                    ss = sample(totuple(plcdins), randint(1, max(1, len(ins) // 2)))
                    gi = fill(gi, fgc, ss)
        res = mfilter(colorfilter(objects(gi, T, F, F), bgc), compose(flip, rbind(bordering, gi)))
        go = fill(gi, 1, res)
        return {'input': gi, 'output': go}

    def generate_780d0b14(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        nh = unifint(diff_lb, diff_ub, (2, 6))
        nw = unifint(diff_lb, diff_ub, (2, 6))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        ncols = unifint(diff_lb, diff_ub, (3, 9))
        ccols = sample(remcols, ncols)
        go = canvas(-1, (nh, nw))
        obj = {(choice(ccols), ij) for ij in asindices(go)}
        go = paint(go, obj)
        while len(dedupe(go)) < nh or len(dedupe(dmirror(go))) < nw:
            obj = {(choice(ccols), ij) for ij in asindices(go)}
            go = paint(go, obj)
        h = unifint(diff_lb, diff_ub, (2*nh+nh-1, 30))
        w = unifint(diff_lb, diff_ub, (2*nw+nw-1, 30))
        hdist = [2 for k in range(nh)]
        for k in range(h - 2 * nh - nh + 1):
            idx = randint(0, nh - 1)
            hdist[idx] += 1
        wdist = [2 for k in range(nw)]
        for k in range(w - 2 * nw - nw + 1):
            idx = randint(0, nw - 1)
            wdist[idx] += 1
        gi = merge(tuple(repeat(r, c) + (repeat(bgc, nw),) for r, c in zip(go, hdist)))[:-1]
        gi = dmirror(merge(tuple(repeat(r, c) + (repeat(bgc, h),) for r, c in zip(dmirror(gi), wdist)))[:-1])
        objs = objects(gi, T, F, F)
        bgobjs = colorfilter(objs, bgc)
        objs = objs - bgobjs
        for obj in objs:
            gi = fill(gi, bgc, sample(totuple(toindices(obj)), unifint(diff_lb, diff_ub, (1, len(obj) // 2))))
        return {'input': gi, 'output': go}

    def generate_57aa92db(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        oh = randint(2, 5)
        ow = randint(2, 5)
        bounds = asindices(canvas(-1, (oh, ow)))
        obj = {choice(totuple(bounds))}
        ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))
        ncells = choice((ncellsd, oh * ow - ncellsd))
        ncells = min(max(3, ncells), oh * ow)
        for k in range(ncells - 1):
            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))
        obj = normalize(obj)
        oh, ow = shape(obj)
        fixp = choice(totuple(obj))
        bgc, fixc, mainc = sample(cols, 3)
        remcols = difference(cols, (bgc, fixc, mainc))
        gi = canvas(bgc, (h, w))
        obj = {(fixc, fixp)} | recolor(mainc, remove(fixp, obj))
        loci = randint(0, h - oh)
        locj = randint(0, w - ow)
        plcd = shift(obj, (loci, locj))
        gi = paint(gi, plcd)
        go = tuple(e for e in gi)
        inds = ofcolor(gi, bgc) - mapply(neighbors, toindices(plcd))
        nocc = unifint(diff_lb, diff_ub, (1, (h * w) // (4 * len(obj))))
        tr = 0
        succ = 0
        maxtr = 5 * nocc
        while succ < nocc and tr < maxtr:
            tr += 1
            fac = randint(1, 4)
            objups = upscale(obj, fac)
            hh, ww = shape(objups)
            cands = sfilter(inds, lambda ij: ij[0] <= h - hh and ij[1] <= w - ww)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            objupsplcd = shift(objups, loc)
            objupsplcdi = toindices(objupsplcd)
            if objupsplcdi.issubset(inds):
                succ += 1
                newc = choice(remcols)
                fixp2 = sfilter(objupsplcd, lambda cij: cij[0] == fixc)
                inds = inds - mapply(neighbors, objupsplcdi)
                gi = paint(gi, fixp2)
                go = paint(go, fixp2)
                remobjfull = toindices(objupsplcd - fixp2)
                ntorem = unifint(diff_lb, diff_ub, (0, max(0, len(remobjfull) - 1)))
                ntokeep = len(remobjfull) - ntorem
                tokeep = {choice(totuple(remobjfull & outbox(fixp2)))}
                fixp2i = toindices(fixp2)
                for k in range(ntokeep - 1):
                    fullopts = remobjfull & mapply(neighbors, tokeep | fixp2i)
                    remopts = fullopts - tokeep
                    tokeep.add(choice(totuple(remopts)))
                gi = fill(gi, newc, tokeep)
                go = fill(go, newc, remobjfull)
        return {'input': gi, 'output': go}

    def generate_53b68214(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        while True:
            h = unifint(diff_lb, diff_ub, (2, 6))
            w = unifint(diff_lb, diff_ub, (8, 30))
            bgc = choice(cols)
            remcols = remove(bgc, cols)
            ncols = unifint(diff_lb, diff_ub, (1, 9))
            ccols = sample(remcols, ncols)
            oh = unifint(diff_lb, diff_ub, (1, h//2))
            ow = unifint(diff_lb, diff_ub, (1, w//2-1))
            bounds = asindices(canvas(-1, (oh, ow)))
            ncells = unifint(diff_lb, diff_ub, (1, oh * ow))
            obj = sample(totuple(bounds), ncells)
            obj = {(choice(ccols), ij) for ij in obj}
            obj = normalize(obj)
            oh, ow = shape(obj)
            locj = randint(0, w//2)
            plcd = shift(obj, (0, locj))
            go = canvas(bgc, (10, w))
            hoffs = randint(0, ow//2 + 1)
            for k in range(10//oh+1):
                go = paint(go, shift(plcd, (k*oh, k*hoffs)))
            if len(palette(go[h:])) > 1:
                break
        gi = go[:h]
        if choice((True, False)):
            gi = vmirror(gi)
            go = vmirror(go)
        return {'input': gi, 'output': go}

    def generate_39e1d7f9(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (5, 10))
        w = unifint(diff_lb, diff_ub, (5, 10))
        bgc, linc, dotc = sample(cols, 3)
        remcols = difference(cols, (bgc, linc, dotc))
        gi = canvas(bgc, (h, w))
        loci = randint(1, h - 2)
        locj = randint(1, w - 2)
        if h == 5:
            loci = choice((1, h - 2))
        if w == 5:
            locj = choice((1, w - 2))
        npix = unifint(diff_lb, diff_ub, (1, 8))
        ncols = unifint(diff_lb, diff_ub, (1, 7))
        ccols = sample(remcols, ncols)
        candsss = neighbors((loci, locj))
        pixs = {(loci, locj)}
        for k in range(npix):
            pixs.add(choice(totuple((mapply(dneighbors, pixs) & candsss) - pixs)))
        pixs = totuple(remove((loci, locj), pixs))
        obj = {(choice(ccols), ij) for ij in pixs}
        gi = fill(gi, dotc, {(loci, locj)})
        gi = paint(gi, obj)
        go = tuple(e for e in gi)
        noccs = unifint(diff_lb, diff_ub, (1, (h * w) // (2 * len(pixs) + 1)))
        succ = 0
        tr = 0
        maxtr = 6 * noccs
        inds = ofcolor(gi, bgc) - mapply(dneighbors, neighbors((loci, locj)))
        objn = shift(obj, (-loci, -locj))
        triedandfailed = set()
        while (tr < maxtr and succ < noccs) or succ == 0:
            lopcands = totuple(inds - triedandfailed)
            if len(lopcands) == 0:
                break
            tr += 1
            loci, locj = choice(lopcands)
            plcd = shift(objn, (loci, locj))
            plcdi = toindices(plcd)
            if plcdi.issubset(inds):
                inds = inds - (plcdi | {(loci, locj)})
                succ += 1
                gi = fill(gi, dotc, {(loci, locj)})
                go = fill(go, dotc, {(loci, locj)})
                go = paint(go, plcd)
            else:
                triedandfailed.add((loci, locj))
        hfac = unifint(diff_lb, diff_ub, (1, (30 - h + 1) // h))
        wfac = unifint(diff_lb, diff_ub, (1, (30 - w + 1) // w))
        fullh = hfac * h + h - 1
        fullw = wfac * w + w - 1
        gi2 = canvas(linc, (fullh, fullw))
        go2 = canvas(linc, (fullh, fullw))
        bd = asindices(canvas(-1, (hfac, wfac)))
        for a in range(h):
            for b in range(w):
                c = gi[a][b]
                gi2 = fill(gi2, c, shift(bd, (a * (hfac + 1), b * (wfac + 1))))
        for a in range(h):
            for b in range(w):
                c = go[a][b]
                go2 = fill(go2, c, shift(bd, (a * (hfac + 1), b * (wfac + 1))))
        gi, go = gi2, go2
        return {'input': gi, 'output': go}

    def generate_017c7c7b(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (0, 2))
        h = unifint(diff_lb, diff_ub, (3, 10))
        w = unifint(diff_lb, diff_ub, (2, 30))
        h += h
        fgc = choice(cols)
        go = canvas(0, (h + h // 2, w))
        oh = unifint(diff_lb, diff_ub, (1, h//3*2))
        ow = unifint(diff_lb, diff_ub, (1, w))
        locj = randint(0, w - ow)
        bounds = asindices(canvas(-1, (oh, ow)))
        ncellsd = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        ncells = choice((ncellsd, oh * ow - ncellsd))
        ncells = min(max(1, ncells), oh * ow)
        obj = sample(totuple(bounds), ncells)
        for k in range((2*h)//oh):
            go = fill(go, 2, shift(obj, (k*oh, 0)))
        gi = replace(go[:h], 2, fgc)
        return {'input': gi, 'output': go}

    def generate_8a004b2b(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        oh = unifint(diff_lb, diff_ub, (2, h//5))
        ow = unifint(diff_lb, diff_ub, (2, w//5))
        bounds = asindices(canvas(-1, (oh, ow)))
        bgc, cornc, ac1, ac2, objc = sample(cols, 5)
        gi = canvas(bgc, (h, w))
        obj = {choice(totuple(bounds))}
        ncellsd = unifint(diff_lb, diff_ub, (0, (oh * ow) // 2))
        ncells = choice((ncellsd, oh * ow - ncellsd))
        ncells = min(max(3, ncells), oh * ow)
        for k in range(ncells - 1):
            obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))
        obj = normalize(obj)
        oh, ow = shape(obj)
        fp1 = choice(totuple(obj))
        fp2 = choice(remove(fp1, totuple(obj)))
        remobj = obj - {fp1, fp2}
        obj = recolor(objc, remobj) | {(ac1, fp1), (ac2, fp2)}
        maxhscf = (h - oh - 4) // oh
        maxwscf = (w - ow - 4) // ow
        hscf = unifint(diff_lb, diff_ub, (1, maxhscf))
        wscf = unifint(diff_lb, diff_ub, (1, maxwscf))
        loci = randint(0, 2)
        locj = randint(0, 2)
        oplcd = shift(obj, (loci, locj))
        gi = paint(gi, oplcd)
        inh = hscf * oh
        inw = wscf * ow
        sqh = unifint(diff_lb, diff_ub, (inh + 2, h - oh - 2))
        sqw = unifint(diff_lb, diff_ub, (inw + 2, w))
        sqloci = randint(loci+oh, h - sqh)
        sqlocj = randint(0, w - sqw)
        crns = corners(frozenset({(sqloci, sqlocj), (sqloci + sqh - 1, sqlocj + sqw - 1)}))
        gi = fill(gi, cornc, crns)
        gomini = subgrid(oplcd, gi)
        goo = vupscale(hupscale(gomini, wscf), hscf)
        goo = asobject(goo)
        gloci = randint(sqloci+1, sqloci+sqh-1-height(goo))
        glocj = randint(sqlocj+1, sqlocj+sqw-1-width(goo))
        gooplcd = shift(goo, (gloci, glocj))
        go = paint(gi, gooplcd)
        go = subgrid(crns, go)
        indic = sfilter(gooplcd, lambda cij: cij[0] in (ac1, ac2))
        gi = paint(gi, indic)
        if choice((True, False)) and len(obj) > 3:
            idx = choice(totuple(toindices(sfilter(obj, lambda cij: cij[0] == objc))))
            idxi, idxj = idx
            xx = shift(asindices(canvas(-1, (hscf, wscf))), (gloci+idxi*hscf, glocj+idxj*wscf))
            gi = fill(gi, objc, xx)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_49d1d64f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (2, 28))
        w = unifint(diff_lb, diff_ub, (2, 28))
        ncols = unifint(diff_lb, diff_ub, (1, 10))
        ccols = sample(cols, ncols)
        gi = canvas(-1, (h, w))
        obj = {(choice(ccols), ij) for ij in asindices(gi)}
        gi = paint(gi, obj)
        go = canvas(0, (h+2, w+2))
        go = paint(go, shift(asobject(gi), (1, 1)))
        ts = sfilter(obj, lambda cij: cij[1][0] == 0)
        bs = sfilter(obj, lambda cij: cij[1][0] == h - 1)
        ls = sfilter(obj, lambda cij: cij[1][1] == 0)
        rs = sfilter(obj, lambda cij: cij[1][1] == w - 1)
        ts = shift(ts, (1, 1))
        bs = shift(bs, (1, 1))
        ls = shift(ls, (1, 1))
        rs = shift(rs, (1, 1))
        go = paint(go, shift(ts, (-1, 0)))
        go = paint(go, shift(bs, (1, 0)))
        go = paint(go, shift(ls, (0, -1)))
        go = paint(go, shift(rs, (0, 1)))
        return {'input': gi, 'output': go}

    def generate_890034e9(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(1, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        oh = randint(2, h//4)
        ow = randint(2, w//4)
        markercol = choice(cols)
        remcols = remove(markercol, cols)
        numbgc = unifint(diff_lb, diff_ub, (1, 8))
        bgcols = sample(remcols, numbgc)
        gi = canvas(0, (h, w))
        inds = asindices(gi)
        obj = {(choice(bgcols), ij) for ij in inds}
        gi = paint(gi, obj)
        numbl = unifint(diff_lb, diff_ub, (0, (h * w) // 2))
        blacks = sample(totuple(inds), numbl)
        gi = fill(gi, 0, blacks)
        patt = asindices(canvas(-1, (oh, ow)))
        tocover = set()
        for occ in occurrences(gi, recolor(0, patt)):
            tocover.add(choice(totuple(shift(patt, occ))))
        tocover = {(choice(bgcols), ij) for ij in tocover}
        gi = paint(gi, tocover)
        noccs = unifint(diff_lb, diff_ub, (2, (h * w) // ((oh + 2) * (ow + 2))))
        tr = 0
        succ = 0
        maxtr = 5 * noccs
        go = tuple(e for e in gi)
        while tr < maxtr and succ < noccs:
            tr += 1
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            bd = shift(patt, loc)
            plcd = outbox(bd)
            if plcd.issubset(inds):
                succ += 1
                inds = inds - plcd
                gi = fill(gi, 0, bd)
                go = fill(go, 0, bd)
                if succ == 1:
                    gi = fill(gi, markercol, plcd)
                go = fill(go, markercol, plcd)
                loci, locj = loc
                ln1 = connect((loci-1, locj), (loci-1, locj+ow-1))
                ln2 = connect((loci+oh, locj), (loci+oh, locj+ow-1))
                ln3 = connect((loci, locj-1), (loci+oh-1, locj-1))
                ln4 = connect((loci, locj+ow), (loci+oh-1, locj+ow))
                if succ > 1:
                    fixxer = {
                        (choice(bgcols), choice(totuple(xx))) for xx in [ln1, ln2, ln3, ln4]
                    }
                    gi = paint(gi, fixxer)
        return {'input': gi, 'output': go}

    def generate_776ffc46(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc, sqc, inc, outc = sample(cols, 4)
        gi = canvas(bgc, (h, w))
        sqh = randint(3, h//3+1)
        sqw = randint(3, w//3+1)
        loci = randint(0, 3)
        locj = randint(0, w - sqw)
        bx = box(frozenset({(loci, locj), (loci + sqh - 1, locj + sqw - 1)}))
        bounds = asindices(canvas(-1, (sqh - 2, sqw - 2)))
        obj = {choice(totuple(bounds))}
        ncells = randint(1, (sqh - 2) * (sqw - 2))
        for k in range(ncells - 1):
            obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))
        obj = normalize(obj)
        oh, ow = shape(obj)
        objp = shift(obj, (loci+1+randint(0, sqh-oh-2), locj+1+randint(0, sqw-ow-2)))
        gi = fill(gi, sqc, bx)
        gi = fill(gi, inc, objp)
        inds = (ofcolor(gi, bgc) - backdrop(bx)) - mapply(neighbors, backdrop(bx))
        cands = sfilter(inds, lambda ij: shift(obj, ij).issubset(inds))
        loc = choice(totuple(cands))
        plcd = shift(obj, loc)
        gi = fill(gi, outc, plcd)
        inds = (inds - plcd) - mapply(neighbors, plcd)
        noccs = unifint(diff_lb, diff_ub, (0, (h * w) // 20))
        succ = 0
        tr = 0
        maxtr = 5 * noccs
        fullinds = asindices(gi)
        while tr < maxtr and succ < noccs:
            tr += 1
            if choice((True, False)):
                sqh = randint(3, h//3+1)
                sqw = randint(3, w//3+1)
                bx = box(frozenset({(0, 0), (sqh - 1, sqw - 1)}))
                bounds = asindices(canvas(-1, (sqh - 2, sqw - 2)))
                obj2 = {choice(totuple(bounds))}
                ncells = randint(1, (sqh - 2) * (sqw - 2))
                for k in range(ncells - 1):
                    obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))
                if normalize(obj2) == obj:
                    if len(obj2) < (sqh - 2) * (sqw - 2):
                        obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))
                    else:
                        continue
                obj2 = normalize(obj2)
                ooh, oow = shape(obj2)
                cands1 = connect((-1, -1), (-1, w - sqw + 1))
                cands2 = connect((h-sqh+1, -1), (h-sqh+1, w - sqw + 1))
                cands3 = connect((-1, -1), (h - sqh + 1, -1))
                cands4 = connect((-1, w-sqw+1), (h - sqh + 1, w-sqw+1))
                cands = cands1 | cands2 | cands3 | cands4
                if len(cands) == 0:
                    continue
                loc = choice(totuple(cands))
                sloci, slocj = loc
                plcdbx = shift(bx, loc)
                if (backdrop(plcdbx) & fullinds).issubset(inds):
                    succ += 1
                    oloci = randint(sloci+1, sloci+1+randint(0, sqh-ooh-2))
                    olocj = randint(slocj+1, slocj+1+randint(0, sqw-oow-2))
                    gi = fill(gi, sqc, plcdbx)
                    gi = fill(gi, inc, shift(obj2, (oloci, olocj)))
                    inds = inds - backdrop(outbox(plcdbx))
            else:
                ooh = randint(1, h//3-1)
                oow = randint(1, w//3-1)
                bounds = asindices(canvas(-1, (ooh, oow)))
                obj2 = {choice(totuple(bounds))}
                ncells = randint(1, oow * ooh)
                for k in range(ncells - 1):
                    obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))
                if normalize(obj2) == obj:
                    if len(obj2) < ooh * oow:
                        obj2.add(choice(totuple((bounds - obj2) & mapply(dneighbors, obj2))))
                    else:
                        continue
            if choice((True, False, False)):
                obj2 = obj
            obj2 = normalize(obj2)
            ooh, oow = shape(obj2)
            for kk in range(randint(1, 3)):
                cands = sfilter(inds, lambda ij: ij[0] <= h - ooh and ij[1] <= w - oow)
                if len(cands) == 0:
                    continue
                loc = choice(totuple(cands))
                plcd = shift(obj2, loc)
                if plcd.issubset(inds):
                    succ += 1
                    inds = (inds - plcd) - mapply(neighbors, plcd)
                    gi = fill(gi, outc, plcd)
        objs = objects(gi, T, F, F)
        objs = colorfilter(objs, outc)
        objs = mfilter(objs, lambda o: equality(normalize(toindices(o)), obj))
        go = fill(gi, inc, objs)
        return {'input': gi, 'output': go}

    def generate_e6721834(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 15))
        w = unifint(diff_lb, diff_ub, (8, 30))
        bgc1, bgc2, sqc = sample(cols, 3)
        remcols = difference(cols, (bgc1, bgc2, sqc))
        gi1 = canvas(bgc1, (h, w))
        gi2 = canvas(bgc2, (h, w))
        noccs = unifint(diff_lb, diff_ub, (1, (h * w) // 16))
        tr = 0
        succ = 0
        maxtr = 5 * noccs
        gi1inds = asindices(gi1)
        gi2inds = asindices(gi2)
        go = canvas(bgc2, (h, w))
        seen = []
        while tr < maxtr and succ < noccs:
            tr += 1
            oh = randint(2, min(6, h//2))
            ow = randint(2, min(6, w//2))
            cands = sfilter(gi1inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            bounds = shift(asindices(canvas(-1, (oh, ow))), loc)
            ncells = unifint(diff_lb, diff_ub, (1, (oh * ow) // 2))
            obj = set(sample(totuple(bounds), ncells))
            objc = choice(remcols)
            objn = normalize(obj)
            if (objn, objc) in seen:
                continue
            seen.append(((objn, objc)))
            if bounds.issubset(gi1inds):
                succ += 1
                gi1inds = (gi1inds - bounds) - mapply(neighbors, bounds)
                gi1 = fill(gi1, sqc, bounds)
                gi1 = fill(gi1, objc, obj)
                cands2 = sfilter(gi2inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
                if len(cands2) == 0:
                    continue
                loc2 = choice(totuple(cands2))
                bounds2 = shift(shift(bounds, invert(loc)), loc2)
                obj2 = shift(shift(obj, invert(loc)), loc2)
                if bounds2.issubset(gi2inds):
                    gi2inds = (gi2inds - bounds2) - mapply(neighbors, bounds2)
                    gi2 = fill(gi2, objc, obj2)
                    go = fill(go, sqc, bounds2)
                    go = fill(go, objc, obj2)
        gi = vconcat(gi1, gi2)
        mfs = (identity, dmirror, cmirror, vmirror, hmirror, rot90, rot180, rot270)
        nmfs = choice((1, 2))
        for fn in sample(mfs, nmfs):
            gi = fn(gi)
            go = fn(go)
        return {'input': gi, 'output': go}

    def generate_ef135b50(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(9, interval(0, 10, 1))
        while True:
            h = unifint(diff_lb, diff_ub, (8, 30))
            w = unifint(diff_lb, diff_ub, (8, 30))
            bgc = choice(cols)
            remcols = remove(bgc, cols)
            numc = unifint(diff_lb, diff_ub, (1, 8))
            ccols = sample(remcols, numc)
            gi = canvas(bgc, (h, w))
            nsq = unifint(diff_lb, diff_ub, (2, (h * w) // 30))
            succ = 0
            tr = 0
            maxtr = 5 * nsq
            inds = asindices(gi)
            pats = set()
            while tr < maxtr and succ < nsq:
                tr += 1
                oh = randint(1, (h//3*2))
                ow = randint(1, (w//3*2))
                cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
                if len(cands) == 0:
                    continue
                loc = choice(totuple(cands))
                loci, locj = loc
                bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
                if bd.issubset(inds):
                    succ += 1
                    inds = (inds - bd) - mapply(neighbors, bd)
                    gi = fill(gi, choice(ccols), bd)
                    pats.add(bd)
            res = set()
            ofc = ofcolor(gi, bgc)
            for pat1 in pats:
                for pat2 in remove(pat1, pats):
                    if hmatching(pat1, pat2):
                        um = max(uppermost(pat1), uppermost(pat2))
                        bm = min(lowermost(pat1), lowermost(pat2))
                        lm = min(rightmost(pat1), rightmost(pat2)) + 1
                        rm = max(leftmost(pat1), leftmost(pat2)) - 1
                        res = res | backdrop(frozenset({(um, lm), (bm, rm)}))
            res = (res & ofc) - box(asindices(gi))
            go = fill(gi, 9, res)
            if go != gi:
                break
        return {'input': gi, 'output': go}

    def generate_794b24be(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2))
        mpr = {1: (0, 0), 2: (0, 1), 3: (0, 2), 4: (1, 1)}
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        nblue = randint(1, 4)
        go = canvas(bgc, (3, 3))
        for k in range(nblue):
            go = fill(go, 2, {mpr[k+1]})
        gi = canvas(bgc, (h, w))
        locs = sample(totuple(asindices(gi)), nblue)
        gi = fill(gi, 1, locs)
        remlocs = ofcolor(gi, bgc)
        namt = unifint(diff_lb, diff_ub, (0, len(remlocs) // 2 - 1))
        remcols = remove(bgc, cols)
        numc = unifint(diff_lb, diff_ub, (1, 7))
        ccols = sample(remcols, numc)
        noise = sample(totuple(remlocs), namt)
        noise = {(choice(ccols), ij) for ij in noise}
        gi = paint(gi, noise)
        return {'input': gi, 'output': go}

    def generate_ff28f65a(diff_lb: float, diff_ub: float) -> dict:
        cols = difference(interval(0, 10, 1), (1, 2))
        mpr = {1: (0, 0), 2: (0, 2), 3: (1, 1), 4: (2, 0), 5: (2, 2)}
        h = unifint(diff_lb, diff_ub, (3, 30))
        w = unifint(diff_lb, diff_ub, (3, 30))
        bgc = choice(cols)
        nred = randint(1, 5)
        gi = canvas(bgc, (h, w))
        succ = 0
        tr = 0
        maxtr = 5 * nred
        inds = asindices(gi)
        while tr < maxtr and succ < nred:
            tr += 1
            oh = randint(1, h//2+1)
            ow = randint(1, w//2+1)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            bd = backdrop(frozenset({(loci, locj), (loci+oh-1, locj+ow-1)}))
            if bd.issubset(inds):
                succ += 1
                inds = (inds - bd) - mapply(dneighbors, bd)
                gi = fill(gi, 2, bd)
        nblue = succ
        namt = unifint(diff_lb, diff_ub, (0, nred * 2))
        succ = 0
        tr = 0
        maxtr = 5 * namt
        remcols = remove(bgc, cols)
        tr += 1
        while tr < maxtr and succ < namt:
            tr += 1
            oh = randint(1, h//2+1)
            ow = randint(1, w//2+1)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            loci, locj = loc
            bd = backdrop(frozenset({(loci, locj), (loci+oh-1, locj+ow-1)}))
            if bd.issubset(inds):
                succ += 1
                inds = (inds - bd) - mapply(dneighbors, bd)
                gi = fill(gi, choice(remcols), bd)
        go = canvas(bgc, (3, 3))
        for k in range(nblue):
            go = fill(go, 1, {mpr[k+1]})
        return {'input': gi, 'output': go}

    def generate_73251a56(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        while True:
            d = unifint(diff_lb, diff_ub, (10, 30))
            h, w = d, d
            noisec = choice(cols)
            remcols = remove(noisec, cols)
            nsl = unifint(diff_lb, diff_ub, (2, min(9, h//2)))
            slopes = [0] + sorted(sample(interval(1, h-1, 1), nsl - 1))
            ccols = sample(cols, nsl)
            gi = canvas(-1, (h, w))
            inds = asindices(gi)
            for col, hdelt in zip(ccols, slopes):
                slope = hdelt / w
                locs = sfilter(inds, lambda ij: slope * ij[1] <= ij[0])
                gi = fill(gi, col, locs)
            ln = connect((0, 0), (d - 1, d - 1))
            gi = fill(gi, ccols[-2], ln)
            obj = asobject(gi)
            obj = sfilter(obj, lambda cij: cij[1][1] >= cij[1][0])
            gi = paint(gi, dmirror(obj))
            cf1 = lambda g: ccols[-2] in palette(toobject(ln, g))
            cf2 = lambda g: len((ofcolor(g, noisec) & frozenset({ij[::-1] for ij in ofcolor(g, noisec)})) - ln) == 0
            ndist = unifint(diff_lb, diff_ub, (1, (h * w) // 15))
            tr = 0
            succ = 0
            maxtr = 10 * ndist
            go = tuple(e for e in gi)
            while tr < maxtr and succ < ndist:
                tr += 1
                oh = randint(1, 5)
                ow = randint(1, 5)
                loci = randint(1, h - oh - 1)
                locj = randint(1, w - ow - 1)
                bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
                gi2 = fill(gi, noisec, bd)
                if cf1(gi2) and cf2(gi2):
                    succ += 1
                    gi = gi2
            if gi != go:
                break
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_3631a71a(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (6, 15))
        w = h
        bgc, patchcol = sample(cols, 2)
        patchcol = choice(cols)
        bgc = choice(remove(patchcol, cols))
        remcols = difference(cols, (bgc, patchcol))
        c = canvas(bgc, (h, w))
        inds = sfilter(asindices(c), lambda ij: ij[0] >= ij[1])
        ncols = unifint(diff_lb, diff_ub, (1, 8))
        ccols = sample(remcols, ncols)
        ncells = unifint(diff_lb, diff_ub, (1, len(inds)))
        cells = set(sample(totuple(inds), ncells))
        obj = {(choice(ccols), ij) for ij in cells}
        c = paint(dmirror(paint(c, obj)), obj)
        c = hconcat(c, vmirror(c))
        c = vconcat(c, hmirror(c))
        cutoff = 2
        go = dmirror(dmirror(c[:-cutoff])[:-cutoff])
        gi = tuple(e for e in go)
        forbidden = asindices(canvas(-1, (cutoff, cutoff)))
        dmirrareaL = shift(asindices(canvas(-1, (h*2-2*cutoff, cutoff))), (cutoff, 0))
        dmirrareaT = shift(asindices(canvas(-1, (cutoff, 2*w-2*cutoff))), (0, cutoff))
        inds1 = sfilter(asindices(gi), lambda ij: cutoff <= ij[0] < h and cutoff <= ij[1] < w and ij[0] >= ij[1])
        inds2 = dmirror(inds1)
        inds3 = shift(hmirror(inds1), (h-cutoff, 0))
        inds4 = shift(hmirror(inds2), (h-cutoff, 0))
        inds5 = shift(vmirror(inds1), (0, w-cutoff))
        inds6 = shift(vmirror(inds2), (0, w-cutoff))
        inds7 = shift(hmirror(vmirror(inds1)), (h-cutoff, w-cutoff))
        inds8 = shift(hmirror(vmirror(inds2)), (h-cutoff, w-cutoff))
        f1 = identity
        f2 = dmirror
        f3 = lambda x: hmirror(shift(x, invert((h-cutoff, 0))))
        f4 = lambda x: dmirror(hmirror(shift(x, invert((h-cutoff, 0)))))
        f5 = lambda x: vmirror(shift(x, invert((0, w-cutoff))))
        f6 = lambda x: dmirror(vmirror(shift(x, invert((0, w-cutoff)))))
        f7 = lambda x: vmirror(hmirror(shift(x, invert((h-cutoff, w-cutoff)))))
        f8 = lambda x: dmirror(vmirror(hmirror(shift(x, invert((h-cutoff, w-cutoff))))))
        indsarr = [inds1, inds2, inds3, inds4, inds5, inds6, inds7, inds8]
        farr = [f1, f2, f3, f4, f5, f6, f7, f8]
        ndist = unifint(diff_lb, diff_ub, (1, int((2*h*2*w) ** 0.5)))
        succ = 0
        tr = 0
        maxtr = 10 * ndist
        fullh, fullw = shape(gi)
        while succ < ndist and tr < maxtr:
            tr += 1
            oh = randint(2, h//2+1)
            ow = randint(2, w//2+1)
            loci = randint(0, fullh - oh)
            locj = randint(0, fullw - ow)
            bd = backdrop(frozenset({(loci, locj), (loci + oh - 1, locj + ow - 1)}))
            isleft = set()
            gi2 = fill(gi, patchcol, bd)
            if patchcol in palette(toobject(forbidden, gi2)):
                continue
            oo1 = toindices(sfilter(toobject(dmirrareaL, gi2), lambda cij: cij[0] != patchcol))
            oo2 = toindices(sfilter(toobject(dmirrareaT, gi2), lambda cij: cij[0] != patchcol))
            oo2 = frozenset({(ij[1], ij[0]) for ij in oo2})
            if oo1 | oo2 != dmirrareaL:
                continue
            for ii, ff in zip(indsarr, farr):
                oo = toobject(ii, gi2)
                rem = toindices(sfilter(oo, lambda cij: cij[0] != patchcol))
                if len(rem) > 0:
                    isleft = isleft | ff(rem)
            if isleft != inds1:
                continue
            succ += 1
            gi = gi2
        return {'input': gi, 'output': go}

    def generate_234bbc79(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        while True:
            h = unifint(diff_lb, diff_ub, (5, 30))
            w = unifint(diff_lb, diff_ub, (6, 20))
            bgc, dotc = sample(cols, 2)
            remcols = difference(cols, (bgc, dotc))
            go = canvas(bgc, (h, 30))
            ncols = unifint(diff_lb, diff_ub, (1, 8))
            ccols = sample(remcols, ncols)
            spi = randint(0, h - 1)
            snek = [(spi, 0)]
            gi = fill(go, dotc, {(spi, 0)})
            while True:
                previ, prevj = snek[-1]
                if prevj == w - 1:
                    if choice((True, False, False)):
                        break
                options = []
                if previ < h - 1:
                    if go[previ+1][prevj] == bgc:
                        options.append((previ+1, prevj))
                if previ > 0:
                    if go[previ-1][prevj] == bgc:
                        options.append((previ-1, prevj))
                if prevj < w - 1:
                    options.append((previ, prevj+1))
                if len(options) == 0:
                    break
                loc = choice(options)
                snek.append(loc)
                go = fill(go, dotc, {loc})
            objs = []
            cobj = []
            for idx, cel in enumerate(snek):
                if len(cobj) > 2 and width(frozenset(cobj)) > 1 and snek[idx-1] == add(cel, (0, -1)):
                    objs.append(cobj)
                    cobj = [cel]
                else:
                    cobj.append(cel)
            objs[-1] += cobj
            nobjs = len(objs)
            if nobjs < 2:
                continue
            ntokeep = unifint(diff_lb, diff_ub, (2, nobjs))
            ntorem = nobjs - ntokeep
            for k in range(ntorem):
                idx = randint(0, len(objs) - 2)
                objs = objs[:idx] + [objs[idx] + objs[idx+1]] + objs[idx+2:]
            inobjs = []
            for idx, obj in enumerate(objs):
                col = choice(ccols)
                go = fill(go, col, set(obj))
                centerpart = recolor(col, set(obj[1:-1]))
                leftpart = {(dotc if idx > 0 else col, obj[0])}
                rightpart = {(dotc if idx < len(objs) - 1 else col, obj[-1])}
                inobj = centerpart | leftpart | rightpart
                inobjs.append(inobj)
            spacings = [1 for idx in range(len(inobjs) - 1)]
            fullw = unifint(diff_lb, diff_ub, (w, 30))
            for k in range(fullw - w - len(inobjs) - 1):
                idx = randint(0, len(spacings) - 1)
                spacings[idx] += 1
            lspacings = [0] + spacings
            gi = canvas(bgc, (h, fullw))
            ofs = 0
            for i, (lsp, obj) in enumerate(zip(lspacings, inobjs)):
                obj = set(obj)
                if i == 0:
                    ulc = ulcorner(obj)
                else:
                    ulci = randint(0, h - height(obj))
                    ulcj = ofs + lsp
                    ulc = (ulci, ulcj)
                ofs += width(obj) + lsp
                plcd = shift(normalize(obj), ulc)
                gi = paint(gi, plcd)
            break
        ins = size(merge(fgpartition(gi)))
        while True:
            go2 = dmirror(dmirror(go)[:-1])
            if size(sfilter(asobject(go2), lambda cij: cij[0] != bgc)) < ins:
                break
            else:
                go = go2
        return {'input': gi, 'output': go}

    def generate_cbded52d(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        oh = unifint(diff_lb, diff_ub, (1, 4))
        ow = unifint(diff_lb, diff_ub, (1, 4))
        numh = unifint(diff_lb, diff_ub, (3, 31 // (oh + 1)))
        numw = unifint(diff_lb, diff_ub, (3, 31 // (ow + 1)))
        bgc, linc = sample(cols, 2)
        remcols = difference(cols, (bgc, linc))
        ncols = unifint(diff_lb, diff_ub, (1, min(8, (numh * numh) // 3)))
        ccols = sample(remcols, ncols)
        fullh = numh * oh + numh - 1
        fullw = numw * ow + numw - 1
        gi = canvas(linc, (fullh, fullw))
        sgi = asindices(canvas(bgc, (oh, ow)))
        for a in range(numh):
            for b in range(numw):
                gi = fill(gi, bgc, shift(sgi, (a * (oh + 1), b * (ow + 1))))
        go = tuple(e for e in gi)
        for col in ccols:
            inds = ofcolor(go, bgc)
            if len(inds) == 0:
                break
            loc = choice(totuple(inds))
            narms = randint(1, 4)
            armdirs = sample(totuple(dneighbors((0, 0))), narms)
            succ = 0
            for armdir in armdirs:
                x, y = armdir
                arm = []
                for k in range(1, max(numh, numw)):
                    nextloc = add(loc, (k * x * (oh + 1), k * y * (ow + 1)))
                    if nextloc not in inds:
                        break
                    arm.append(nextloc)
                if len(arm) < 2:
                    continue
                aidx = unifint(diff_lb, diff_ub, (1, len(arm) - 1))
                endp = arm[aidx]
                gi = fill(gi, col, {endp})
                go = fill(go, col, set(arm[:aidx+1]))
                succ += 1
            if succ > 0:
                gi = fill(gi, col, {loc})
                go = fill(go, col, {loc})
        return {'input': gi, 'output': go}

    def generate_06df4c85(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        oh = unifint(diff_lb, diff_ub, (1, 4))
        ow = unifint(diff_lb, diff_ub, (1, 4))
        numh = unifint(diff_lb, diff_ub, (3, 31 // (oh + 1)))
        numw = unifint(diff_lb, diff_ub, (3, 31 // (ow + 1)))
        bgc, linc = sample(cols, 2)
        remcols = difference(cols, (bgc, linc))
        ncols = unifint(diff_lb, diff_ub, (1, min(8, (numh * numh) // 3)))
        ccols = sample(remcols, ncols)
        fullh = numh * oh + numh - 1
        fullw = numw * ow + numw - 1
        gi = canvas(linc, (fullh, fullw))
        sgi = asindices(canvas(bgc, (oh, ow)))
        for a in range(numh):
            for b in range(numw):
                gi = fill(gi, bgc, shift(sgi, (a * (oh + 1), b * (ow + 1))))
        go = tuple(e for e in gi)
        sinds = asindices(canvas(-1, (oh, ow)))
        for col in ccols:
            inds = occurrences(go, recolor(bgc, sinds))
            if len(inds) == 0:
                break
            loc = choice(totuple(inds))
            narms = randint(1, 4)
            armdirs = sample(totuple(dneighbors((0, 0))), narms)
            succ = 0
            for armdir in armdirs:
                x, y = armdir
                arm = []
                for k in range(1, max(numh, numw)):
                    nextloc = add(loc, (k * x * (oh + 1), k * y * (ow + 1)))
                    if nextloc not in inds:
                        break
                    arm.append(nextloc)
                if len(arm) < 2:
                    continue
                aidx = unifint(diff_lb, diff_ub, (1, len(arm) - 1))
                endp = arm[aidx]
                gi = fill(gi, col, shift(sinds, endp))
                go = fill(go, col, mapply(lbind(shift, sinds), set(arm[:aidx+1])))
                succ += 1
            gi = fill(gi, col, shift(sinds, loc))
            go = fill(go, col, shift(sinds, loc))
        return {'input': gi, 'output': go}

    def generate_90f3ed37(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(1, interval(0, 10, 1))
        while True:
            h = unifint(diff_lb, diff_ub, (8, 30))
            w = unifint(diff_lb, diff_ub, (8, 30))
            pathh = unifint(diff_lb, diff_ub, (1, max(1, h//4)))
            pathh = unifint(diff_lb, diff_ub, (pathh, max(1, h//4)))
            Lpatper = unifint(diff_lb, diff_ub, (1, w//7))
            Rpatper = unifint(diff_lb, diff_ub, (1, w//7))
            hh = randint(1, pathh)
            Linds = asindices(canvas(-1, (hh, Lpatper)))
            Rinds = asindices(canvas(-1, (hh, Rpatper)))
            lpatsd = unifint(diff_lb, diff_ub, (0, (hh * Lpatper) // 2))
            rpatsd = unifint(diff_lb, diff_ub, (0, (hh * Rpatper) // 2))
            lpats = choice((lpatsd, hh * Lpatper - lpatsd))
            rpats = choice((rpatsd, hh * Rpatper - rpatsd))
            lpats = min(max(Lpatper, lpats), hh * Lpatper)
            rpats = min(max(Rpatper, rpats), hh * Rpatper)
            lpat = set(sample(totuple(Linds), lpats))
            rpat = set(sample(totuple(Rinds), rpats))
            midpatw = randint(0, w-2*Lpatper-2*Rpatper)
            if midpatw == 0 or Lpatper == hh == 1:
                midpat = set()
                midpatw = 0
            else:
                midpat = set(sample(totuple(asindices(canvas(-1, (hh, midpatw)))), randint(midpatw, (hh * midpatw))))
            if shift(midpat, (0, 2*Lpatper-midpatw)).issubset(lpat):
                midpat = set()
                midpatw = 0
            loci = randint(0, h - pathh)
            lplac = shift(lpat, (loci, 0)) | shift(lpat, (loci, Lpatper))
            mplac = shift(midpat, (loci, 2*Lpatper))
            rplac = shift(rpat, (loci, 2*Lpatper+midpatw)) | shift(rpat, (loci, 2*Lpatper+midpatw+Rpatper))
            sp = 2*Lpatper+midpatw+Rpatper
            for k in range(w//Lpatper+1):
                lplac |= shift(lpat, (loci, -k*Lpatper))
            for k in range(w//Rpatper+1):
                rplac |= shift(rpat, (loci, sp+k*Rpatper))
            pat = lplac | mplac | rplac
            patn = shift(pat, (-loci, 0))
            bgc, fgc = sample(cols, 2)
            gi = canvas(bgc, (h, w))
            gi = fill(gi, fgc, pat)
            options = interval(0, h - pathh + 1, 1)
            options = difference(options, interval(loci-pathh-1, loci+2*pathh, 1))
            nplacements = unifint(diff_lb, diff_ub, (1, max(1, len(options) // pathh)))
            go = tuple(e for e in gi)
            for k in range(nplacements):
                if len(options) == 0:
                    break
                locii = choice(options)
                options = difference(options, interval(locii-pathh-1, locii+2*pathh, 1))
                hoffs = randint(0, max(Rpatper, w-sp-2))
                cutoffopts = interval(2*Lpatper+midpatw, 2*Lpatper+midpatw+hoffs+1, 1)
                cutoffopts = cutoffopts[::-1]
                idx = unifint(diff_lb, diff_ub, (0, len(cutoffopts) - 1))
                cutoff = cutoffopts[idx]
                patnc = sfilter(patn, lambda ij: ij[1] <= cutoff)
                go = fill(go, 1, shift(patn, (locii, hoffs)))
                gi = fill(gi, fgc, shift(patnc, (locii, hoffs)))
                go = fill(go, fgc, shift(patnc, (locii, hoffs)))
            if 1 in palette(go):
                break
        return {'input': gi, 'output': go}

    def generate_36d67576(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        while True:
            h = unifint(diff_lb, diff_ub, (10, 30))
            w = unifint(diff_lb, diff_ub, (10, 30))
            bgc, mainc, markerc = sample(cols, 3)
            remcols = difference(cols, (bgc, mainc, markerc))
            ncols = unifint(diff_lb, diff_ub, (1, len(remcols)))
            ccols = sample(remcols, ncols)
            gi = canvas(bgc, (h, w))
            oh = unifint(diff_lb, diff_ub, (2, 5))
            ow = unifint(diff_lb, diff_ub, (3 if oh == 2 else 2, 5))
            if choice((True, False)):
                oh, ow = ow, oh
            bounds = asindices(canvas(-1, (oh, ow)))
            ncells = unifint(diff_lb, diff_ub, (4, len(bounds)))
            obj = {choice(totuple(bounds))}
            for k in range(ncells - 1):
                obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))
            obj = normalize(obj)
            oh, ow = shape(obj)
            ntocompc = unifint(diff_lb, diff_ub, (1, ncells - 3))
            markercell = choice(totuple(obj))
            remobj = remove(markercell, obj)
            markercellobj = {(markerc, markercell)}
            tocompc = set(sample(totuple(remobj), ntocompc))
            mainpart = (obj - {markercell}) - tocompc
            mainpartobj = recolor(mainc, mainpart)
            tocompcobj = {(choice(remcols), ij) for ij in tocompc}
            obj = tocompcobj | mainpartobj | markercellobj
            smobj = mainpartobj | markercellobj
            smobjn = normalize(smobj)
            isfakesymm = False
            for symmf in [dmirror, cmirror, hmirror, vmirror]:
                if symmf(smobjn) == smobjn and symmf(obj) != obj:
                    isfakesymm = True
                    break
            if isfakesymm:
                continue
            loci = randint(0, h - oh)
            locj = randint(0, w - ow)
            plcd = shift(obj, (loci, locj))
            gi = paint(gi, plcd)
            plcdi = toindices(plcd)
            inds = (asindices(gi) - plcdi) - mapply(neighbors, plcdi)
            noccs = unifint(diff_lb, diff_ub, (1, max(1, (h * w) // (2 * len(obj)))))
            succ = 0
            tr = 0
            maxtr = noccs * 5
            go = tuple(e for e in gi)
            while tr < maxtr and succ < noccs:
                tr += 1
                mf1 = choice((identity, dmirror, cmirror, hmirror, vmirror))
                mf2 = choice((identity, dmirror, cmirror, hmirror, vmirror))
                mf = compose(mf1, mf2)
                outobj = normalize(mf(obj))
                inobj = sfilter(outobj, lambda cij: cij[0] in [mainc, markerc])
                oh, ow = shape(outobj)
                cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
                if len(cands) == 0:
                    continue
                loc = choice(totuple(cands))
                outobjp = shift(outobj, loc)
                inobjp = shift(inobj, loc)
                outobjpi = toindices(outobjp)
                if outobjpi.issubset(inds):
                    succ += 1
                    inds = (inds - outobjpi) - mapply(neighbors, outobjpi)
                    gi = paint(gi, inobjp)
                    go = paint(go, outobjp)
            break
        return {'input': gi, 'output': go}

    def generate_4522001f(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (3, 10))
        w = unifint(diff_lb, diff_ub, (3, 10))
        bgc, sqc, dotc = sample(cols, 3)
        gi = canvas(bgc, (h, w))
        go = canvas(bgc, (3*h, 3*w))
        sqi = {(dotc, (1, 1))} | recolor(sqc, {(0, 0), (0, 1), (1, 0)})
        sqo = backdrop(frozenset({(0, 0), (3, 3)}))
        sqo |= shift(sqo, (4, 4))
        loci = randint(0, min(h-2, 3*h-8))
        locj = randint(0, min(w-2, 3*w-8))
        loc = (loci, locj)
        plcdi = shift(sqi, loc)
        plcdo = shift(sqo, loc)
        gi = paint(gi, plcdi)
        go = fill(go, sqc, plcdo)
        noccs = unifint(diff_lb, diff_ub, (0, (h*w) // 9))
        succ = 0
        tr = 0
        maxtr = 10 * noccs
        iinds = ofcolor(gi, bgc) - mapply(dneighbors, toindices(plcdi))
        while tr < maxtr and succ < noccs:
            tr += 1
            cands = sfilter(iinds, lambda ij: ij[0] <= h - 2 and ij[1] <= w - 2)
            if len(cands) == 0:
                break
            loc = choice(totuple(cands))
            plcdi = shift(sqi, loc)
            plcdo = shift(sqo, loc)
            plcdii = toindices(plcdi)
            if plcdii.issubset(iinds):
                succ += 1
                iinds = (iinds - plcdii) - mapply(dneighbors, plcdii)
                gi = paint(gi, plcdi)
                go = fill(go, sqc, plcdo)
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_72322fa7(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        h = unifint(diff_lb, diff_ub, (10, 30))
        w = unifint(diff_lb, diff_ub, (10, 30))
        bgc = choice(cols)
        remcols = remove(bgc, cols)
        nobjs = unifint(diff_lb, diff_ub, (1, 4))
        ccols = sample(remcols, 2*nobjs)
        cpairs = list(zip(ccols[:nobjs], ccols[nobjs:]))
        objs = []
        gi = canvas(bgc, (h, w))
        inds = asindices(gi)
        for ca, cb in cpairs:
            oh = unifint(diff_lb, diff_ub, (1, 4))
            ow = unifint(diff_lb, diff_ub, (2 if oh == 1 else 1, 4))
            if choice((True, False)):
                oh, ow = ow, oh
            bounds = asindices(canvas(-1, (oh, ow)))
            obj = {choice(totuple(bounds))}
            ncells = randint(2, oh * ow)
            for k in range(ncells - 1):
                obj.add(choice(totuple((bounds - obj) & mapply(neighbors, obj))))
            objn = normalize(obj)
            objt = totuple(objn)
            apart = sample(objt, randint(1, len(objt) - 1))
            bpart = difference(objt, apart)
            obj = recolor(ca, set(apart)) | recolor(cb, set(bpart))
            oh, ow = shape(obj)
            cands = sfilter(inds, lambda ij: shift(objn, ij).issubset(inds))
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            gi = paint(gi, plcd)
            plcdi = toindices(plcd)
            inds = (inds - plcdi) - mapply(neighbors, plcdi)
            objs.append(obj)
        avgs = sum([len(o) for o in objs]) / len(objs)
        ub = max(1, (h * w) // (avgs * 2))
        noccs = unifint(diff_lb, diff_ub, (1, ub))
        succ = 0
        tr = 0
        maxtr = 5 * noccs
        go = tuple(e for e in gi)
        while tr < maxtr and succ < noccs:
            tr += 1
            obj = choice(objs)
            ca, cb = list(palette(obj))
            oh, ow = shape(obj)
            cands = sfilter(inds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
            if len(cands) == 0:
                continue
            loc = choice(totuple(cands))
            plcd = shift(obj, loc)
            plcdi = toindices(plcd)
            if plcdi.issubset(inds):
                succ += 1
                inds = (inds - plcdi) - mapply(neighbors, plcdi)
                go = paint(go, plcd)
                col = choice((ca, cb))
                gi = paint(gi, sfilter(plcd, lambda cij: cij[0] == col))
        return {'input': gi, 'output': go}

    def generate_4290ef0e(diff_lb: float, diff_ub: float) -> dict:
        cols = interval(0, 10, 1)
        while True:
            d = unifint(diff_lb, diff_ub, (2, 7))
            h, w = d, d
            fullh = unifint(diff_lb, diff_ub, (4*d, 30))
            fullw = unifint(diff_lb, diff_ub, (4*d, 30))
            bgc = choice(cols)
            remcols = remove(bgc, cols)
            ccols = sample(remcols, d)
            quad = canvas(bgc, (d+1, d+1))
            for idx, c in enumerate(ccols):
                linlen = randint(2, w-idx+1)
                quad = fill(quad, c, (connect((idx, idx), (idx+linlen-1, idx))))
                quad = fill(quad, c, (connect((idx, idx), (idx, idx+linlen-1))))
            go = canvas(bgc, (d+1, 2*d+1))
            qobj1 = asobject(quad)
            qobj2 = shift(asobject(vmirror(quad)), (0, d))
            go = paint(go, qobj1)
            go = paint(go, qobj2)
            go = vconcat(go, hmirror(go)[1:])
            if choice((True, False)):
                go = fill(go, choice(difference(remcols, ccols)), {center(asindices(go))})
            objs = partition(go)
            objs = sfilter(objs, lambda o: color(o) != bgc)
            gi = canvas(bgc, (fullh, fullw))
            objs = order(objs, width)
            fullinds = asindices(gi)
            inds = asindices(gi)
            fullsuc = True
            for obj in objs:
                objn = normalize(obj)
                obji = toindices(objn)
                d = width(obj)
                dh = max(0, d//2-1)
                cands = sfilter(fullinds, lambda ij: ij[0] <= fullh - d and ij[1] <= fullw - d)
                cands = cands | shift(cands, (-dh, 0)) | shift(cands, (0, -dh)) | shift(cands, (dh, 0)) | shift(cands, (0, dh))
                maxtr = 10
                tr = 0
                succ = False
                if len(cands) == 0:
                    break
                while tr < maxtr and not succ:
                    tr += 1    
                    loc = choice(totuple(cands))
                    if (shift(obji, loc) & fullinds).issubset(inds):
                        succ = True
                        break
                if not succ:
                    fullsuc = False
                    break
                gi = paint(gi, shift(objn, loc))
                inds = inds - shift(obji, loc)
            if not fullsuc:
                continue
            break
        return {'input': gi, 'output': go}

    def generate_6a1e5592(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(1, interval(0, 10, 1))
        h = unifint(diff_lb, diff_ub, (9, 30))
        w = unifint(diff_lb, diff_ub, (5, 30))
        barh = randint(3, h//3)
        maxobjh = h - barh - 1
        nobjs = unifint(diff_lb, diff_ub, (1, w//3))
        barc, bgc, objc = sample(cols, 3)
        c1 = canvas(barc, (barh, w))
        c2 = canvas(bgc, (h - barh, w))
        gi = vconcat(c1, c2)
        go = tuple(e for e in gi)
        tr = 0
        succ = 0
        maxtr = 10 * nobjs
        placopts = interval(1, w - 1, 1)
        iinds = ofcolor(gi, bgc)
        oinds = asindices(go)
        barinds = ofcolor(gi, barc)
        forbmarkers = set()
        while tr < maxtr and succ < nobjs:
            tr += 1
            oh = randint(1, maxobjh)
            ow = randint(1, min(4, w//2))
            bounds = asindices(canvas(-1, (oh, ow)))
            ncells = randint(1, oh * ow)
            sp = choice(totuple(connect((0, 0), (0, ow - 1))))
            obj = {sp}
            for k in range(ncells - 1):
                obj.add(choice(totuple((bounds - obj) & mapply(dneighbors, obj))))
            obj = normalize(obj)
            oh, ow = shape(obj)
            markerh = randint(1, min(oh, barh-1))
            markpart = sfilter(obj, lambda ij: ij[0] < markerh)
            markpartn = normalize(markpart)
            isinvalid = False
            for k in range(1, markerh+1):
                if normalize(sfilter(markpartn, lambda ij: ij[0] < k)) in forbmarkers:
                    isinvalid = True
            if isinvalid:
                continue
            for k in range(1, markerh+1):
                forbmarkers.add(normalize(sfilter(markpartn, lambda ij: ij[0] < k)))
            placoptcands = sfilter(placopts, lambda jj: set(interval(jj, jj+ow+1, 1)).issubset(set(placopts)))
            if len(placoptcands) == 0:
                continue
            jloc = choice(placoptcands)
            iloc = barh - markerh
            oplcd = shift(obj, (iloc, jloc))
            if oplcd.issubset(oinds):
                icands = sfilter(iinds, lambda ij: ij[0] <= h - oh and ij[1] <= w - ow)
                if len(icands) == 0:
                    continue
                loc = choice(totuple(icands))
                iplcd = shift(obj, loc)
                if iplcd.issubset(iinds):
                    succ += 1
                    iinds = (iinds - iplcd) - mapply(neighbors, iplcd)
                    oinds = (oinds - oplcd)
                    gi = fill(gi, objc, iplcd)
                    gi = fill(gi, bgc, oplcd & barinds)
                    go = fill(go, 1, oplcd)
                    jm = apply(last, ofcolor(go, 1))
                    placopts = sorted(difference(placopts, jm | apply(decrement, jm) | apply(increment, jm)))
            if len(placopts) == 0:
                break
        rotf = choice((identity, rot90, rot180, rot270))
        gi = rotf(gi)
        go = rotf(go)
        return {'input': gi, 'output': go}

    def generate_e73095fd(diff_lb: float, diff_ub: float) -> dict:
        cols = remove(4, interval(0, 10, 1))
        while True:
            h = unifint(diff_lb, diff_ub, (10, 32))
            w = unifint(diff_lb, diff_ub, (10, 32))
            bgc, fgc = sample(cols, 2)
            gi = canvas(bgc, (h, w))
            nsplits = unifint(diff_lb, diff_ub, (2, min(h, w) // 3))
            for k in range(nsplits):
                objs = objects(gi, T, F, F)
                objs = colorfilter(objs, bgc)
                objs = apply(toindices, objs)
                hobjs = sfilter(objs, lambda o: height(o) > 6)
                wobjs = sfilter(objs, lambda o: width(o) > 6)
                if len(hobjs) == 0 and len(wobjs) == 0:
                    break
                cgroups = [(g, ax) for g, ax in zip([hobjs, wobjs], [0, 1]) if len(g) > 0]
                g, ax = choice(cgroups)
                obj = choice(totuple(g))
                ulci, ulcj = ulcorner(obj)
                oh, ow = shape(obj)
                if ax == 0:
                    iloc = randint(ulci + 3, ulci+oh-3)
                    bar = sfilter(obj, lambda ij: ij[0] == iloc)
                else:
                    jloc = randint(ulcj + 3, ulcj+ow-3)
                    bar = sfilter(obj, lambda ij: ij[1] == jloc)
                gi = fill(gi, fgc, bar)
            copts = sfilter(
                ofcolor(gi, fgc),
                lambda ij: len(sfilter(toobject(dneighbors(ij), gi), lambda cij: cij[0] == fgc)) > 2
            )
            copts = sfilter(copts, lambda ij: len(sfilter(toobject(outbox(outbox({ij})), gi), lambda cij: cij[0] == fgc)) in {3, 4})
            if len(copts) == 0:
                continue
            noccs = unifint(diff_lb, diff_ub, (1, len(copts)))
            noccs = unifint(diff_lb, diff_ub, (noccs, len(copts)))
            occs = sample(totuple(copts), noccs)
            go = tuple(e for e in gi)
            forb = set()
            for occ in occs:
                ulci, ulcj = decrement(occ)
                lrci, lrcj = increment(occ)
                if len(sfilter(toobject(box({(ulci, ulcj), (lrci, lrcj)}), gi), lambda cij: cij[0] == fgc)) in {3, 4}:
                    boptions = []
                    for ulcioffs in [-2, -1, 0]:
                        for ulcjoffs in [-2, -1, 0]:
                            for lrcioffs in [0, 1, 2]:
                                for lrcjoffs in [0, 1, 2]:
                                    bx = box({(ulci+ulcioffs, ulcj+ulcjoffs), (lrci+lrcioffs, lrcj+lrcjoffs)})
                                    bxobj = toobject(bx, gi)
                                    if len(sfilter(toobject(bxobj, gi), lambda cij: cij[0] == fgc)) in {3, 4} and len(sfilter(toobject(outbox(bxobj), gi), lambda cij: cij[0] == fgc)) in {3, 4}:
                                        boptions.append(bx)
                    boptions = sfilter(boptions, lambda bx: len(backdrop(bx) & forb) == 0)
                    if len(boptions) > 0:
                        bx = choice(boptions)
                        bd = backdrop(bx)
                        gi = fill(gi, bgc, bd)
                        gi = fill(gi, fgc, bx)
                        go = fill(go, 4, bd)
                        go = fill(go, fgc, bx)
                        forb |= bd
            gi = trim(gi)
            go = trim(go)
            if 4 in palette(go):
                break
        return {'input': gi, 'output': go}

class Tasker:  #加载任务
    def load(base, train=True):
        import os, json
        path = f'{base}/{"training" if train else "evaluation"}'
        data = {}
        for file in os.listdir(path):
            with open(f'{path}/{file}') as f:
                data[file.rstrip('.json')] = json.load(f)
        ast = lambda g: tuple(tuple(r) for r in g)
        return {'train': {k: [{'input': ast(e['input']), 'output': ast(e['output'])} for e in v['train']] for k, v in data.items()}, 'test':{k: [{'input': ast(e['input']), 'output': ast(e['output'])} for e in v['test']]  for k, v in data.items()}}

import ast
class Hunter:  #解图必经   
    class DependencyExtractor(ast.NodeVisitor):
        def __init__(self):
            self.edges = []

        def visit_Assign(self, node):
            def _collect_names(node):  #递归收集表达式中的变量名
                names = set()
                for child in ast.walk(node):
                    if isinstance(child, ast.Name):
                        names.add(child.id)
                return names
            
            if isinstance(node.targets[0], ast.Name):  #左值：变量名
                deps = _collect_names(node.value)      #右值：收集依赖
                for dep in deps:
                    self.edges.append((dep, node.targets[0].id))
            self.generic_visit(node)

        def visit_Return(self, node):
            if isinstance(node.value, ast.Name):
                self.return_var = node.value.id

    def hunt(func):
        def _compute_dominators(edges, start, end):
            import networkx
            G = networkx.DiGraph()
            G.add_edges_from(edges)
            idoms = networkx.immediate_dominators(G, start)
            dominators = set()
            node = end
            while True:
                dominators.add(node)
                if node == start:
                    break
                node = idoms[node]
            return dominators        
        import inspect, textwrap
        code = inspect.getsource(func)
        code = textwrap.dedent(code)
        print('code:', code)
        tree = ast.parse(code)
        extractor = Hunter.DependencyExtractor()
        extractor.visit(tree)
        dominators = _compute_dominators(extractor.edges, start=tree.body[0].args.args[0].arg, end=extractor.return_var)  #函数参数名字, 假设只有一个参数
        return dominators, extractor.edges 

class TesterCaller:
    def __init__(self, key):         
        for clss in [Worker,Rander]:
            for name, attr in clss.__dict__.items():
                if callable(attr):
                    globals()[name] = attr        
        self.func = getattr(Tester, f'verify_{key}')
        
    def __call__(self, I):
        O = self.func(I)
        return O

class JoinerCaller:
    def __init__(self, key):         
        for clss in [Worker,Rander]:
            for name, attr in clss.__dict__.items():
                if callable(attr):
                    globals()[name] = attr     
        self.func = getattr(Joiner, f'generate_{key}')
        
    def __call__(self, diff_lb=0.0, diff_ub=1.0):
        O = self.func(diff_lb, diff_ub)
        return O

class TracerCaller:  #调用求解
    def __init__(self, key):
        for clss in [Worker,Rander]:
            for name, attr in clss.__dict__.items():
                if callable(attr):
                    globals()[name] = attr
        self.func = getattr(Seeker, f'solve_{key}')
        import inspect
        self._lines = [line.lstrip() for line in inspect.getsource(self.func).splitlines()[1:] if line.strip()]
        
    def __call__(self, I, dominators):
        locals = {}
        locals['I'] = I
        for line in self._lines:
            if line.startswith("return "):
                expr = line[len("return "):]
                O = eval(expr, globals(), locals)
                locals['O'] = O
            else:
                exec(line, globals(), locals)
        digraph = {}
        for k,v in locals.items():
            digraph[k] = (k in dominators, v)            
        return O, digraph

def main(todo='97a05b5b'):  #e40b9e2f  2dc579da  007bbfb7
    if 1:
        data = Tasker.load(base='./data/arcagi1/', train=True)
        ok_all=0; no_all=0
        for key in data['train'].keys():
            if todo!=None and key not in todo: continue
            tracerCaller = TracerCaller(key)
            dominators, _edges = Hunter.hunt(tracerCaller.func)  #compute dominator(articulation-point) variable in function digraph(acyclic), e.g Lengauer–Tarjan
            task = data['train'][key] + data['test'][key]
            ok_one=0; no_one=0
            for case in task:
                answer, traces = tracerCaller(case['input'], dominators)
                if answer==case['output']:
                    ok_one += 1
                else:
                    no_one += 1
            if no_one==0: 
                ok_all += 1
            else:
                no_all += 1
            print('TASK:', key, '     ', 'OK:',ok_all,'&', 'NO:',no_all, ' ', '/', ' ', ok_all+no_all)
            for k,(d,v) in traces.items():
                print(k, '  ','dominator:',d)
                print(v)
                print()
            print()

    if 1:
        task = JoinerCaller(todo)()
        print('task', task)

        outs = TesterCaller(todo)(task['input'])
        print('outs', outs)

        print('equa', outs==task['output'])
        
if __name__ == '__main__':  
    main()

